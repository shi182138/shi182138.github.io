<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL(3)</title>
      <link href="/2022/10/26/MySQL-3/"/>
      <url>/2022/10/26/MySQL-3/</url>
      
        <content type="html"><![CDATA[<h2 id="1、视图（view）"><a href="#1、视图（view）" class="headerlink" title="1、视图（view）"></a>1、视图（view）</h2><h3 id="1-1、什么是视图"><a href="#1-1、什么是视图" class="headerlink" title="1.1、什么是视图?"></a>1.1、什么是视图?</h3><p>站在不同的角度去看到数据。(同一张表的数据，通过不同的角度去看待）。</p><h3 id="1-2、怎么创建视图-怎么删除视图"><a href="#1-2、怎么创建视图-怎么删除视图" class="headerlink" title="1.2、怎么创建视图?怎么删除视图?"></a>1.2、怎么创建视图?怎么删除视图?</h3><p>create view myview as select empno ,ename from emp;</p><p>drop view myview ;</p><p>注意:只有DQr语句才能以视图对象的方式创建出来。</p><h3 id="1-3、对视图进行增删改查，会影响到原表数据。-通过视图影响原表数据的，不是直接操作的原表"><a href="#1-3、对视图进行增删改查，会影响到原表数据。-通过视图影响原表数据的，不是直接操作的原表" class="headerlink" title="1.3、对视图进行增删改查，会影响到原表数据。(通过视图影响原表数据的，不是直接操作的原表)"></a>1.3、对视图进行增删改查，会影响到原表数据。(通过视图影响原表数据的，不是直接操作的原表)</h3><h3 id="1-4、面向视图操作"><a href="#1-4、面向视图操作" class="headerlink" title="1.4、面向视图操作?"></a>1.4、面向视图操作?</h3><p>mysql&gt; select * from myview;</p><p>create table emp_bak as select * from emp ;<br>create view myview1 as select empno , ename ,sal from emp_bak;</p><p>update myview1 set ename&#x3D;’hehe ‘ ,sal&#x3D;1 where empno &#x3D; 7369;&#x2F;&#x2F;通过视图修改原表数据。delete from myview1 where empno &#x3D; 7369;&#x2F;&#x2F;通过视图删除原表数据。</p><p>select * from myview1;</p><p>select * from emp_bak;</p><h3 id="1-5、视图的作用"><a href="#1-5、视图的作用" class="headerlink" title="1.5、视图的作用?"></a>1.5、视图的作用?</h3><p>视图可以隐藏表的实现细节。保密级别较高的系统，数据库只对外提供相关的视图，java程序员只对视图对象进行CRUD。</p><h2 id="2、DBA命令"><a href="#2、DBA命令" class="headerlink" title="2、DBA命令"></a>2、DBA命令</h2><h3 id="2-1、将数据库当中的数据导出"><a href="#2-1、将数据库当中的数据导出" class="headerlink" title="2.1、将数据库当中的数据导出"></a>2.1、将数据库当中的数据导出</h3><p>在windows的dos命令窗口中执行:(导出整个库)<br>mysqldump bjpowernode&gt;D: lbjpowernode.sql -uroot -p333<br>在windows的dos命令窗口中执行:（导出指定数据库当中的指定表)<br>mysqldump bjpowernode emp&gt;D: \bjpowernode.sql -uroot -p123</p><h3 id="2-2、导入数据"><a href="#2-2、导入数据" class="headerlink" title="2.2、导入数据"></a>2.2、导入数据</h3><p>create database bjpowernode ;use bjpowernode;<br>source D: \bjpowernode.sql</p><h2 id="3、数据库设计三范式-重点内容-面试经常问"><a href="#3、数据库设计三范式-重点内容-面试经常问" class="headerlink" title="3、数据库设计三范式(重点内容,面试经常问)"></a>3、数据库设计三范式(重点内容,面试经常问)</h2><h3 id="3-1、什么是设计范式"><a href="#3-1、什么是设计范式" class="headerlink" title="3.1、什么是设计范式?"></a>3.1、什么是设计范式?</h3><p>设计表的依据。按照这个三范式设计的表不会出现数据冗余。</p><h3 id="3-2、三范式都是哪些"><a href="#3-2、三范式都是哪些" class="headerlink" title="3.2、三范式都是哪些?"></a>3.2、三范式都是哪些?</h3><p>第一范式:任何一张表都应该有主键，并且每一个字段原子性不可再分。<br>第二范式:建立在第一范式的基础之上，所有非主键字段完全依赖主键，不能产生部分依赖。<br>多对多?三张表,关系表两个外键。</p><p>第三范式:建立在第二范式的基础之上，所有非主键字段直接依赖主键,<br>不能产生传递依赖。<br>一对多?两张表,多的表加外键。</p><p>提醒:在实际的开发中，以满足客户的需求为主，有的时候会拿冗余换执行速度。</p><h3 id="3-3、一对一怎么设计"><a href="#3-3、一对一怎么设计" class="headerlink" title="3.3、一对一怎么设计?"></a>3.3、一对一怎么设计?</h3><p>一对一设计有两种方案:主键共享</p><p>一对一设计有两种方案:外键唯一。</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL(2)</title>
      <link href="/2022/10/26/MySQL-2/"/>
      <url>/2022/10/26/MySQL-2/</url>
      
        <content type="html"><![CDATA[<h2 id="1、关于查询结果集的去重"><a href="#1、关于查询结果集的去重" class="headerlink" title="1、关于查询结果集的去重"></a>1、关于查询结果集的去重</h2><p>mysql&gt; select distinct job from emp; &#x2F;&#x2F; distinct关键字去除重复记录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+-----------+</span><br><span class="line">| job       |</span><br><span class="line">+-----------+</span><br><span class="line">| CLERK     |</span><br><span class="line">| SALESMAN  |</span><br><span class="line">| MANAGER   |</span><br><span class="line">| ANALYST   |</span><br><span class="line">| PRESIDENT |</span><br><span class="line">+-----------+</span><br></pre></td></tr></table></figure><p>mysql&gt; select ename ,distinct job from emp ;</p><p>以上的sql语句是错误的。</p><p>记住:distinct只能出现在所有字段的最前面。</p><p>mysql&gt; select distinct deptno,job from emp;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+--------+-----------+</span><br><span class="line">| deptno | job       |</span><br><span class="line">+--------+-----------+</span><br><span class="line">|     20 | CLERK     |</span><br><span class="line">|     30 | SALESMAN  |</span><br><span class="line">|     20 | MANAGER   |</span><br><span class="line">|     30 | MANAGER   |</span><br><span class="line">|     10 | MANAGER   |</span><br><span class="line">|     20 | ANALYST   |</span><br><span class="line">|     10 | PRESIDENT |</span><br><span class="line">|     30 | CLERK     |</span><br><span class="line">|     10 | CLERK     |</span><br><span class="line">+--------+-----------+</span><br></pre></td></tr></table></figure><h5 id="案例-统计岗位的数量"><a href="#案例-统计岗位的数量" class="headerlink" title="案例:统计岗位的数量?"></a>案例:统计岗位的数量?</h5><p>select count(distinct job)from emp ;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+---------------------+</span><br><span class="line">| count(distinct job) |</span><br><span class="line">+---------------------+</span><br><span class="line">|                   5 |</span><br><span class="line">+---------------------+</span><br></pre></td></tr></table></figure><h2 id="2、连接查询"><a href="#2、连接查询" class="headerlink" title="2、连接查询"></a>2、连接查询</h2><h3 id="2-1、什么是连接查询"><a href="#2-1、什么是连接查询" class="headerlink" title="2.1、什么是连接查询"></a>2.1、什么是连接查询</h3><p>2.1、什么是连接查询?<br>在实际开发中，大部分的情况下都不是从单表中查询数据，一般都是多张表联合查询取出最终的结果。在实际开发中，一般一个业务都会对应多张表，比如:学生和班级，起码两张表。</p><p>stunostunameclassnoclassname</p><hr><p>1zs1北京大兴区亦庄经济技术开发区第二中学高三1班</p><p>21s1北京大兴区亦庄经济技术开发区第二中学高三1班</p><p>…………..</p><p>学生和班级信息存储到一张表中，结果就像上面一样，数据会存在大量的重复，导致数据的冗余。</p><h3 id="2-2、连接查询的分类"><a href="#2-2、连接查询的分类" class="headerlink" title="2.2、连接查询的分类?"></a>2.2、连接查询的分类?</h3><p>根据语法出现的年代来划分的话,包括:<br>    SQL.92(一些老的DBA可能还在使用这种语法。DBA: DataBase administrator，数据库管理员)<br>    sQL99 (比较新的语法)</p><p>- </p><ul><li>根据表的连接方式来划分,包括:</li><li>内连接:<ul><li>等值连接</li><li>非等值连接</li><li>自连接</li></ul></li><li>外连接</li><li>全连接(这个不讲,很少用!)</li></ul><h3 id="2-3、在表的连接查询方面有一种现象被称为-笛卡尔积现象。（笛卡尔乘积现象"><a href="#2-3、在表的连接查询方面有一种现象被称为-笛卡尔积现象。（笛卡尔乘积现象" class="headerlink" title="2.3、在表的连接查询方面有一种现象被称为:笛卡尔积现象。（笛卡尔乘积现象)"></a>2.3、在表的连接查询方面有一种现象被称为:笛卡尔积现象。（笛卡尔乘积现象)</h3><p>案例:找出每一个员工的部门名称,要求显示员工名和部门名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">emp</span><br><span class="line">mysql&gt; select ename,deptno from emp;</span><br><span class="line">+--------+--------+</span><br><span class="line">| ename  | deptno |</span><br><span class="line">+--------+--------+</span><br><span class="line">| SMITH  |     20 |</span><br><span class="line">| ALLEN  |     30 |</span><br><span class="line">| WARD   |     30 |</span><br><span class="line">| JONES  |     20 |</span><br><span class="line">| MARTIN |     30 |</span><br><span class="line">| BLAKE  |     30 |</span><br><span class="line">| CLARK  |     10 |</span><br><span class="line">| SCOTT  |     20 |</span><br><span class="line">| KING   |     10 |</span><br><span class="line">| TURNER |     30 |</span><br><span class="line">| ADAMS  |     20 |</span><br><span class="line">| JAMES  |     30 |</span><br><span class="line">| FORD   |     20 |</span><br><span class="line">| MILLER |     10 |</span><br><span class="line">+--------+--------+</span><br><span class="line"></span><br><span class="line">mysql&gt; select deptno,dname,loc from dept;</span><br><span class="line">+--------+------------+----------+</span><br><span class="line">| deptno | dname      | loc      |</span><br><span class="line">+--------+------------+----------+</span><br><span class="line">|     10 | ACCOUNTING | NEW YORK |</span><br><span class="line">|     20 | RESEARCH   | DALLAS   |</span><br><span class="line">|     30 | SALES      | CHICAGO  |</span><br><span class="line">|     40 | OPERATIONS | BOSTON   |</span><br><span class="line">+--------+------------+----------+</span><br><span class="line"></span><br><span class="line">mysql&gt; select ename , dname from emp , dept;</span><br><span class="line">+--------+------------+</span><br><span class="line">| ename  | dname      |</span><br><span class="line">+--------+------------+</span><br><span class="line">| SMITH  | OPERATIONS |</span><br><span class="line">| SMITH  | SALES      |</span><br><span class="line">| SMITH  | RESEARCH   |</span><br><span class="line">| SMITH  | ACCOUNTING |</span><br><span class="line">| ALLEN  | OPERATIONS |</span><br><span class="line">| ALLEN  | SALES      |</span><br><span class="line">| ALLEN  | RESEARCH   |</span><br><span class="line">| ALLEN  | ACCOUNTING |</span><br><span class="line">| WARD   | OPERATIONS |</span><br><span class="line">| WARD   | SALES      |</span><br><span class="line">| WARD   | RESEARCH   |</span><br><span class="line">| WARD   | ACCOUNTING |</span><br><span class="line">| JONES  | OPERATIONS |</span><br><span class="line">| JONES  | SALES      |</span><br><span class="line">| JONES  | RESEARCH   |</span><br><span class="line">| JONES  | ACCOUNTING |</span><br><span class="line">| MARTIN | OPERATIONS |</span><br><span class="line">| MARTIN | SALES      |</span><br><span class="line">| MARTIN | RESEARCH   |</span><br><span class="line">| MARTIN | ACCOUNTING |</span><br><span class="line">| BLAKE  | OPERATIONS |</span><br><span class="line">| BLAKE  | SALES      |</span><br><span class="line">| BLAKE  | RESEARCH   |</span><br><span class="line">| BLAKE  | ACCOUNTING |</span><br><span class="line">...............</span><br><span class="line">56 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p><strong>笛卡尔积现象:当两张表进行连接查询的时候，没有任何条件进行限制,</strong><br><strong>最终的查询结果条数是两张表记录条数的乘积。</strong></p><p>ename和dname要联合起来一块显示，粘到一块。</p><h4 id="关于表的别名"><a href="#关于表的别名" class="headerlink" title="关于表的别名:"></a>关于表的别名:</h4><p>select e.ename ,d.dname from emp e ,dept d;表的别名有什么好处?</p><ul><li>第一:执行效率高。</li><li>第二:可读性好。</li></ul><h3 id="2-4、怎么避免笛卡尔积现象-当然是加条件进行过滤。"><a href="#2-4、怎么避免笛卡尔积现象-当然是加条件进行过滤。" class="headerlink" title="2.4、怎么避免笛卡尔积现象?当然是加条件进行过滤。"></a>2.4、怎么避免笛卡尔积现象?当然是加条件进行过滤。</h3><p>思考:避免了笛卡尔积现象,会减少记录的匹配次数吗?<br>不会,次数还是56次。只不过显示的是有效记录。</p><p>案例:找出每一个员工的部门名称,要求显示员工名和部门名。<br>select</p><p>​e.ename ,d. dname</p><p>from</p><p>​emp e , dept d</p><p>where<br>    e.deptno &#x3D; d.deptno;  <strong>&#x2F;&#x2F;SQL92以后不用</strong></p><h3 id="2-5、内连接之等值连接-最大特点是-条件是等量关系。"><a href="#2-5、内连接之等值连接-最大特点是-条件是等量关系。" class="headerlink" title="2.5、内连接之等值连接:最大特点是:条件是等量关系。"></a>2.5、内连接之等值连接:最大特点是:条件是等量关系。</h3><p>案例:查询每个员工的部门名称,要求显示员工名和部门名。</p><p>SQL92:(太老，不用了)<br>select e.ename ,d.dname from emp e, dept d where e.deptno &#x3D; d.deptno;</p><p>SQL99:(常用的)</p><p>select</p><p>​e.ename ,d.dname</p><p>from</p><p>​emp e</p><p>join<br>    dept d<br>on<br>    e.deptno &#x3D; d.deptno;</p><p><strong>SQL99语法结构更清晰一些:表的连接条件和后来的where条件分离了。</strong></p><h3 id="2-6、内连接之非等值连接-最大的特点是-连接条件中的关系是非等量关系。"><a href="#2-6、内连接之非等值连接-最大的特点是-连接条件中的关系是非等量关系。" class="headerlink" title="2.6、内连接之非等值连接:最大的特点是:连接条件中的关系是非等量关系。"></a>2.6、内连接之非等值连接:最大的特点是:连接条件中的关系是非等量关系。</h3><p><strong>inner可以省略</strong></p><p>案例:找出每个员工的工资等级，要求显示员工名、工资、工资等级。<br>mysql&gt; select ename , sal from emp ;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+--------+---------+</span><br><span class="line">| ename  | sal     |</span><br><span class="line">+--------+---------+</span><br><span class="line">| SMITH  |  800.00 |</span><br><span class="line">| ALLEN  | 1600.00 |</span><br><span class="line">| WARD   | 1250.00 |</span><br><span class="line">| JONES  | 2975.00 |</span><br><span class="line">| MARTIN | 1250.00 |</span><br><span class="line">| BLAKE  | 2850.00 |</span><br><span class="line">| CLARK  | 2450.00 |</span><br><span class="line">| SCOTT  | 3000.00 |</span><br><span class="line">| KING   | 5000.00 |</span><br><span class="line">| TURNER | 1500.00 |</span><br><span class="line">| ADAMS  | 1100.00 |</span><br><span class="line">| JAMES  |  950.00 |</span><br><span class="line">| FORD   | 3000.00 |</span><br><span class="line">| MILLER | 1300.00 |</span><br><span class="line">+--------+---------+</span><br></pre></td></tr></table></figure><p>mysql&gt; select * from salgrade;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+-------+-------+-------+</span><br><span class="line">| GRADE | LOSAL | HISAL |</span><br><span class="line">+-------+-------+-------+</span><br><span class="line">|     1 |   700 |  1200 |</span><br><span class="line">|     2 |  1201 |  1400 |</span><br><span class="line">|     3 |  1401 |  2000 |</span><br><span class="line">|     4 |  2001 |  3000 |</span><br><span class="line">|     5 |  3001 |  9999 |</span><br><span class="line">+-------+-------+-------+</span><br></pre></td></tr></table></figure><p>select e.ename, e.sal, s.grade from emp e join salgrade s on e.sal between s.losal and s.hisal;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+--------+---------+-------+</span><br><span class="line">| ename  | sal     | grade |</span><br><span class="line">+--------+---------+-------+</span><br><span class="line">| SMITH  |  800.00 |     1 |</span><br><span class="line">| ALLEN  | 1600.00 |     3 |</span><br><span class="line">| WARD   | 1250.00 |     2 |</span><br><span class="line">| JONES  | 2975.00 |     4 |</span><br><span class="line">| MARTIN | 1250.00 |     2 |</span><br><span class="line">| BLAKE  | 2850.00 |     4 |</span><br><span class="line">| CLARK  | 2450.00 |     4 |</span><br><span class="line">| SCOTT  | 3000.00 |     4 |</span><br><span class="line">| KING   | 5000.00 |     5 |</span><br><span class="line">| TURNER | 1500.00 |     3 |</span><br><span class="line">| ADAMS  | 1100.00 |     1 |</span><br><span class="line">| JAMES  |  950.00 |     1 |</span><br><span class="line">| FORD   | 3000.00 |     4 |</span><br><span class="line">| MILLER | 1300.00 |     2 |</span><br><span class="line">+--------+---------+-------+</span><br></pre></td></tr></table></figure><h3 id="2-7、自连接-最大的特点是-一张表看做两张表。自己连接自己。"><a href="#2-7、自连接-最大的特点是-一张表看做两张表。自己连接自己。" class="headerlink" title="2.7、自连接:最大的特点是:一张表看做两张表。自己连接自己。"></a>2.7、自连接:最大的特点是:一张表看做两张表。自己连接自己。</h3><p>案例:找出每个员工的上级领导，要求显示员工名和对应的领导名。</p><p>mysql&gt; select empno , ename ,mgr from emp ;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+-------+--------+------+</span><br><span class="line">| empno | ename  | mgr  |</span><br><span class="line">+-------+--------+------+</span><br><span class="line">|  7369 | SMITH  | 7902 |</span><br><span class="line">|  7499 | ALLEN  | 7698 |</span><br><span class="line">|  7521 | WARD   | 7698 |</span><br><span class="line">|  7566 | JONES  | 7839 |</span><br><span class="line">|  7654 | MARTIN | 7698 |</span><br><span class="line">|  7698 | BLAKE  | 7839 |</span><br><span class="line">|  7782 | CLARK  | 7839 |</span><br><span class="line">|  7788 | SCOTT  | 7566 |</span><br><span class="line">|  7839 | KING   | NULL |</span><br><span class="line">|  7844 | TURNER | 7698 |</span><br><span class="line">|  7876 | ADAMS  | 7788 |</span><br><span class="line">|  7900 | JAMES  | 7698 |</span><br><span class="line">|  7902 | FORD   | 7566 |</span><br><span class="line">|  7934 | MILLER | 7782 |</span><br><span class="line">+-------+--------+------+</span><br></pre></td></tr></table></figure><p>员工的领导编号&#x3D;领导的员工编号<br>select a.ename as’员工名’ ,b.ename as ‘领导名’ from emp a inner join emp b on a.mgr &#x3D; b.empno;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+--------+--------+</span><br><span class="line">| 员工名 | 领导名 |</span><br><span class="line">+--------+--------+</span><br><span class="line">| SMITH  | FORD   |</span><br><span class="line">| ALLEN  | BLAKE  |</span><br><span class="line">| WARD   | BLAKE  |</span><br><span class="line">| JONES  | KING   |</span><br><span class="line">| MARTIN | BLAKE  |</span><br><span class="line">| BLAKE  | KING   |</span><br><span class="line">| CLARK  | KING   |</span><br><span class="line">| SCOTT  | JONES  |</span><br><span class="line">| TURNER | BLAKE  |</span><br><span class="line">| ADAMS  | SCOTT  |</span><br><span class="line">| JAMES  | BLAKE  |</span><br><span class="line">| FORD   | JONES  |</span><br><span class="line">| MILLER | CLARK  |</span><br><span class="line">+--------+--------+</span><br><span class="line">13 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="2-8、外连接"><a href="#2-8、外连接" class="headerlink" title="2.8、外连接?"></a>2.8、外连接?</h3><ul><li>什么是外连接,和内连接有什么区别?<ul><li>内连接:<ul><li>假设A和s表进行连接，使用内连接的话，凡是a表和s表能够匹配上的记录查询出来，这就是内连接。AB两张表没有主副之分,两张表是平等的。</li></ul></li><li>外连接:<ul><li>假设A和B表进行连接，使用外连接的话，aB两张表中有一张表是主表，一张表是副表，主要查询主表中的数据，捎带着查询副表，当副表中的数据没有和主表中的数据匹配上，副表自动模拟出N与之匹配。</li></ul></li><li>外连接的分类?<ul><li>左外连接(左连接):表示左边的这张表是主表。</li><li>右外连接(右连接) :表示右边的这张表是主表。</li><li>左连接有右连接的写法，右连接也会有对应的左连接的写法。</li></ul></li></ul></li></ul><p>案例:找出每个员工的上级领导?</p><p>外连接:</p><p>select a.ename ‘员工’, b.ename ‘领导’ from emp a left join emp b on a.mgr&#x3D;b.empno;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">+--------+-------+</span><br><span class="line">| 员工   | 领导  |</span><br><span class="line">+--------+-------+</span><br><span class="line">| SMITH  | FORD  |</span><br><span class="line">| ALLEN  | BLAKE |</span><br><span class="line">| WARD   | BLAKE |</span><br><span class="line">| JONES  | KING  |</span><br><span class="line">| MARTIN | BLAKE |</span><br><span class="line">| BLAKE  | KING  |</span><br><span class="line">| CLARK  | KING  |</span><br><span class="line">| SCOTT  | JONES |</span><br><span class="line">| KING   | NULL  |</span><br><span class="line">| TURNER | BLAKE |</span><br><span class="line">| ADAMS  | SCOTT |</span><br><span class="line">| JAMES  | BLAKE |</span><br><span class="line">| FORD   | JONES |</span><br><span class="line">| MILLER | CLARK |</span><br><span class="line">+--------+-------+</span><br><span class="line"></span><br><span class="line">14 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p><strong>外连接最重要的特点是:主表的数据无条件的全部查询出来。</strong></p><h3 id="2-9、三张表怎么连接查询"><a href="#2-9、三张表怎么连接查询" class="headerlink" title="2.9、三张表怎么连接查询?"></a>2.9、三张表怎么连接查询?</h3><p>案例:找出每一个员工的部门名称以及工资等级。</p><p>案例:找出每一个员工的部门名称、工资等级、以及上级领导。</p><p>select e.ename ‘员工’,d.dname ,s.grade ,e1.ename ‘领导’ from emp e join dept d on e.deptno &#x3D; d.deptnojoin salgrade s on e.sal between s.1osal and s.hisalleft join emp e1on e.mgr &#x3D; e1.empno ;</p><h2 id="3、子查询"><a href="#3、子查询" class="headerlink" title="3、子查询"></a>3、子查询</h2><h3 id="3-1、什么是子查询"><a href="#3-1、什么是子查询" class="headerlink" title="3.1、什么是子查询"></a>3.1、什么是子查询</h3><p>select语句当中嵌套select语句，被嵌套的select语句是子查询。子查询可以出现在哪里?<br>select</p><p>​..(select) </p><p>from</p><p>​..(select) </p><p>where</p><p>​..(select) .</p><h3 id="3-2、where子语句中使用子查询"><a href="#3-2、where子语句中使用子查询" class="headerlink" title="3.2、where子语句中使用子查询"></a>3.2、where子语句中使用子查询</h3><p>案例:找出高于平均薪资的员工信息。</p><p>select * from emp where sal &gt; avg(sal);&#x2F;&#x2F;错误的写法，where后面不能直接使用分组函数。</p><p>第一步:找出平均薪资<br>select avg (sal)from emp ;</p><p>第二步</p><p>select avg (sal) from emp</p><p>第一步和第二步合并:<br>select * from emp where sal &gt;(select avg (sal) from emp) ;</p><h3 id="3-3、from后面嵌套子查询"><a href="#3-3、from后面嵌套子查询" class="headerlink" title="3.3、from后面嵌套子查询"></a>3.3、from后面嵌套子查询</h3><p>案例:找出每个部门平均薪水的薪资等级。<br>第一步:找出每个部门平均薪水（按照部门编号分组，求sal的平均值)</p><p>select deptno ,avg (sal) as avgsal from emp group by deptno;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+--------+-------------+</span><br><span class="line">| deptno | avgsal      |</span><br><span class="line">+--------+-------------+</span><br><span class="line">|     20 | 2175.000000 |</span><br><span class="line">|     30 | 1566.666667 |</span><br><span class="line">|     10 | 2916.666667 |</span><br><span class="line">+--------+-------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>第二步:将以上的查询结果当做临时表t，让t表和salgrade s表连接，条件是: t.avgsal between s.losal and s.hisal</p><p>select t.* ,s.grade from (select deptno ,avg(sal) as avgsal from emp group by deptno) t join salgrade s on t.avgsal between s.losal and s.hisal;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+--------+-------------+-------+</span><br><span class="line">| deptno | avgsal      | grade |</span><br><span class="line">+--------+-------------+-------+</span><br><span class="line">|     20 | 2175.000000 |     4 |</span><br><span class="line">|     30 | 1566.666667 |     3 |</span><br><span class="line">|     10 | 2916.666667 |     4 |</span><br><span class="line">+--------+-------------+-------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>案例:找出每个部门平均的薪水等级。</p><p>第一步:找出每个员工的薪水等级。<br>select e.ename ,e.sal,e.deptno ,s.grade from emp e join salgrade s on e.sal between s.losal and s.hisal;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+--------+---------+--------+-------+</span><br><span class="line">| ename  | sal     | deptno | grade |</span><br><span class="line">+--------+---------+--------+-------+</span><br><span class="line">| SMITH  |  800.00 |     20 |     1 |</span><br><span class="line">| ALLEN  | 1600.00 |     30 |     3 |</span><br><span class="line">| WARD   | 1250.00 |     30 |     2 |</span><br><span class="line">| JONES  | 2975.00 |     20 |     4 |</span><br><span class="line">| MARTIN | 1250.00 |     30 |     2 |</span><br><span class="line">| BLAKE  | 2850.00 |     30 |     4 |</span><br><span class="line">| CLARK  | 2450.00 |     10 |     4 |</span><br><span class="line">| SCOTT  | 3000.00 |     20 |     4 |</span><br><span class="line">| KING   | 5000.00 |     10 |     5 |</span><br><span class="line">| TURNER | 1500.00 |     30 |     3 |</span><br><span class="line">| ADAMS  | 1100.00 |     20 |     1 |</span><br><span class="line">| JAMES  |  950.00 |     30 |     1 |</span><br><span class="line">| FORD   | 3000.00 |     20 |     4 |</span><br><span class="line">| MILLER | 1300.00 |     10 |     2 |</span><br><span class="line">+--------+---------+--------+-------+</span><br></pre></td></tr></table></figure><p>第二步:基于以上结果，继续按照deptno分组，求grade平均值。<br>select e.deptno ,avg(s.grade) from emp e join salgrade s on e.sal between s.losal and s.hisal group by e.deptno ;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+--------+--------------+</span><br><span class="line">| deptno | avg(s.grade) |</span><br><span class="line">+--------+--------------+</span><br><span class="line">|     20 |       2.8000 |</span><br><span class="line">|     30 |       2.5000 |</span><br><span class="line">|     10 |       3.6667 |</span><br><span class="line">+--------+--------------+</span><br></pre></td></tr></table></figure><h3 id="3-4、在select后面嵌套子查询。"><a href="#3-4、在select后面嵌套子查询。" class="headerlink" title="3.4、在select后面嵌套子查询。"></a>3.4、在select后面嵌套子查询。</h3><p>案例:找出每个员工所在的部门名称，要求显示员工名和部门名。</p><p>select d.dname from dept d where e.deptno &#x3D; d.deptno</p><p>select e.ename,(select d.dname from dept d where e.deptno &#x3D; d.deptno) as dname from emp e</p><h2 id="4、union-可以将查询结果集相加"><a href="#4、union-可以将查询结果集相加" class="headerlink" title="4、union (可以将查询结果集相加)"></a>4、union (可以将查询结果集相加)</h2><p>案例:找出工作岗位是SALESMAN和MANAGER的员工?</p><p>第一种: select ename ,job from emp where job &#x3D; ‘MANAGER’ or job &#x3D; ‘SALESMAN’</p><p>第二种: select ename,job from emp where job in ( ‘MANAGER’，’SALESMAN</p><p>第三种: union<br>select ename ,job from emp where job &#x3D; ‘MANAGER ‘ union select ename ,job from emp where job &#x3D; ‘SAL,ESMAN’ ;</p><p>两张不相千的表中的数据拼接在一起显示?</p><p>select ename from emp union select dname rom dept;</p><h2 id="5、limit〈重点中的重点-以后分页查询全靠它了。"><a href="#5、limit〈重点中的重点-以后分页查询全靠它了。" class="headerlink" title="5、limit〈重点中的重点,以后分页查询全靠它了。)"></a>5、limit〈重点中的重点,以后分页查询全靠它了。)</h2><h3 id="5-1、1imit是mysq1特有的，其他数据库中没有，不通用。-oracle中有一个相同的机制，叫做rownum"><a href="#5-1、1imit是mysq1特有的，其他数据库中没有，不通用。-oracle中有一个相同的机制，叫做rownum" class="headerlink" title="5.1、1imit是mysq1特有的，其他数据库中没有，不通用。(oracle中有一个相同的机制，叫做rownum)"></a>5.1、1imit是mysq1特有的，其他数据库中没有，不通用。(oracle中有一个相同的机制，叫做rownum)</h3><h3 id="5-2、limit取结果集中的部分数据-这时它的作用。"><a href="#5-2、limit取结果集中的部分数据-这时它的作用。" class="headerlink" title="5.2、limit取结果集中的部分数据,这时它的作用。"></a>5.2、limit取结果集中的部分数据,这时它的作用。</h3><h3 id="5-3、语法机制"><a href="#5-3、语法机制" class="headerlink" title="5.3、语法机制:"></a>5.3、语法机制:</h3><p>​limit startIndex, length<br>​</p><p>startIndex表示起始位置 从0开始,0表示第一条数据。</p><p>length表示取几个</p><h3 id="5-4、limit是sql语句最后执行的一个环节"><a href="#5-4、limit是sql语句最后执行的一个环节" class="headerlink" title="5.4、limit是sql语句最后执行的一个环节:"></a>5.4、limit是sql语句最后执行的一个环节:</h3><p>select5</p><p>from1</p><p>where2</p><p>group by 3</p><p>having4</p><p>order by6</p><p>limit7<br>…;</p><h3 id="5-5、案例-找出工资排名在第4到第9名的员工"><a href="#5-5、案例-找出工资排名在第4到第9名的员工" class="headerlink" title="5.5、案例:找出工资排名在第4到第9名的员工?"></a>5.5、案例:找出工资排名在第4到第9名的员工?</h3><p>select ename ,sal from emp order by sal desc limit 3,6;</p><h3 id="5-6、通用的标准分页sql"><a href="#5-6、通用的标准分页sql" class="headerlink" title="5.6、通用的标准分页sql ?"></a>5.6、通用的标准分页sql ?</h3><p>每页显示3条记录:</p><p>第1页:0,3</p><p>第2页:3,3</p><p>第3页:6,3</p><p>第4页:9,3</p><p>第5页:12,3</p><p>每页显示pagesize条记录:<br>第pageNo页: (pageNo - 1) * pagesize, pagesize</p><p>pagesize是什么?是每页显示多少条记录</p><p>pageNo是什么?显示第几页</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java代码&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">pageNo</span> <span class="operator">=</span> <span class="number">2</span>; <span class="comment">//页码是2</span></span><br><span class="line"><span class="type">int</span> <span class="variable">pagesize</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">//每页显示10条</span></span><br><span class="line">limit (pageNo - <span class="number">1</span>)*pagesize, pagesize</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、创建表"><a href="#6、创建表" class="headerlink" title="6、创建表:"></a>6、创建表:</h2><p>建表语句的语法格式:<br>    create table表名(</p><p>​字段名1数据类型，</p><p>​字段名2数据类型，</p><p>​字段名3数据类型，<br>​);</p><p>关于MysQL当中字段的数据类型?以下只说常见的<br>int整数型(java中的int)<br>bigint长整型(java中的long)<br>float浮点型(java中的float double)char定长字符串(string)<br>varchar可变长字符串(stringBuffer&#x2F;stringBuilder)</p><p>date日期类型(对应Java中的java.sql.Date类型)<br>BLOB二进制大对象（存储图片、视频等流媒体信息) Binary Large 0Bject(对应java中的object)<br>CLOB字符大对象（存储较大文本，比如，可以存储4c的字符串。) </p><p>Character Large OBject(对应java中的object)</p><p>char和varchar怎么选择?<br>在实际的开发中，当某个字段中的数据长度不发生改变的时候，是定长的，例如:性别、生日等都是采用char。</p><p>当一个字段的数据长度不确定，例如:简介、姓名等都是米用varchar.<br>BLOB和CLOB类型的使用?<br>电影表:t movie<br>id(int)name (varchar)playtime (date&#x2F;char)haibao (BLOB)history (CLOB)</p><p>1蜘蛛侠<br>2</p><p>表名在数据库当中一般建议以:t_或者tb1_开始。创建学生表:<br>学生信息包括:<br>学号、姓名、性别、班级编号、生日学号: bigint<br>姓名: varchar性别: char班级编号:int生日: char<br>create table t_student (<br>no bigint,<br>name varchar (255),</p><p>sex char (1),<br>classno varchar(255),</p><p>birth char (10)</p><p>}</p><h2 id="7、insert语句插入数据"><a href="#7、insert语句插入数据" class="headerlink" title="7、insert语句插入数据"></a>7、insert语句插入数据</h2><p>语法格式:<br>insert into表名(字段名1,字段名2,字段名3,… .) values(值1,值2,值3,….)</p><p>要求:字段的数量和值的数量相同，并且数据类型要对应相同。</p><p>insert into t student(no ,name , sex,classno,birth) values(1, ‘ zhangsan’ , ‘1 ‘ , ‘gaosan1ban’ );</p><p>mysql&gt;insert into t student (no ,name , sex,classno ,birth) values(1, ‘ zhangsan’ ,’1’,’ gaosan1ban ‘);ERROR 1136 (21s01): column count doesn’t match value count at row 1</p><p>insert into t_student (name) values ( ‘ wangwu ‘ );&#x2F;&#x2F;除name字段之外，<br>剩下的所有字段自动插入NULL。</p><p>drop table if exists t_student; &#x2F;&#x2F;当这个表存在的话删除。</p><p>create table t _student(<br>no bigint,<br>name varchar (255),sex char(1)default 1,classno varchar (255),birth char (10)<br>);</p><p><strong>需要注意的地方:</strong><br><strong>当一条insert语句执行成功之后,表格当中必然会多一行记录。即使多的这一行记录当中某些字段是NULL，后期也没有办法在执行insert语句插入数据了，只能使用update进行更新。</strong></p><h2 id="8、表的复制"><a href="#8、表的复制" class="headerlink" title="8、表的复制"></a>8、表的复制</h2><p>语法:<br>create table表名as select语句;将查询结果当做表创建出来。</p><h2 id="9、将查询结果插入到一张表中"><a href="#9、将查询结果插入到一张表中" class="headerlink" title="9、将查询结果插入到一张表中?"></a>9、将查询结果插入到一张表中?</h2><p>mysql&gt; insert into dept1 select *from dept;mysql&gt; select *from dept1 ;</p><h2 id="10、修改数据-update"><a href="#10、修改数据-update" class="headerlink" title="10、修改数据:update"></a>10、修改数据:update</h2><p>语法格式:<br>update 表名set字段名1&#x3D;值1,字段名2&#x3D;值2… where条件;注意:没有条件整张表数据全部更新。<br>案例:将部门10的Ioc修改为SHANGHAI，将部门名称修改为RENSHIBU<br>update dept1 set loc &#x3D; ‘SHANGEAT’,dname &#x3D;’RENSHIBU’ where deptno &#x3D; 10;mysql&gt; select *from dept1 ;</p><h2 id="11、删除数据"><a href="#11、删除数据" class="headerlink" title="11、删除数据?"></a>11、删除数据?</h2><p>语法格式:<br>delete from表名where条件;<br>注意:没有条件全部删除。<br>删除10部门数据?<br>delete from dept1 where deptno &#x3D; 10;<br>删除所有记录?<br>delete from dept1;<br>怎么删除大表?(重点)<br>truncate table emp;&#x2F;&#x2F;表被截断，不可回滚。永久丢失。</p><h2 id="12、"><a href="#12、" class="headerlink" title="12、"></a>12、</h2><p>对于表结构的修改，使用工具完成即可，因为在实际开发中表一旦设计好之后，对表结构的修改是很少的，修改表结构就是对之前的设计进行了否定，即使<br>需要修改表结构，我们也可以直接使用工具操作。修改表结构的语句不会出现在Java代码当中。出现在java代码当中的sql包括: insert delete update select(这些都是表中的数据操作。)<br>增删改查有一个术语:CRUD操作<br>create(增)Retrieve(检索)update（修改)Delete （删除)</p><h2 id="13、约束-Constraint"><a href="#13、约束-Constraint" class="headerlink" title="13、约束(Constraint)"></a>13、约束(Constraint)</h2><p>13.1、什么是约束?</p><p>常见的约束有哪些呢?</p><p>表格<br>id(唯一性约束)password(非空约束)</p><h3 id="13-1、什么是约束-常见的约束有哪些呢"><a href="#13-1、什么是约束-常见的约束有哪些呢" class="headerlink" title="13.1、什么是约束?常见的约束有哪些呢?"></a>13.1、什么是约束?常见的约束有哪些呢?</h3><p>在创建表的时候，可以给表的字段添加相应的约束，<strong>添加约束的目的是为了保证表中数据的合法性、有效性、完整性。</strong></p><ul><li>常见的约束有哪些呢?<ul><li>非空约束(not null):约束的字段不能为NULL</li><li>唯一约束(unique):约束的字段不能重复</li><li>主键约束(primary key):约束的字段既不能为NULL，也不能重复（简称PR)</li><li>外键约束(foreign key) : …(简称PK)</li><li>检查约束(check):注意oracle数据库有check约束，但是mysql没有，目前mysq1不支持该约束。</li></ul></li></ul><p>13.2、非空约束not null<br>drop table if exists t user;</p><p>create table t user(<br>id int,<br>username varchar (255) not null,</p><p>password varchar(255)</p><p>);</p><p>insert into t user(id,password)values(1,’123’) ;</p><h3 id="13-2、唯一性约束-unique"><a href="#13-2、唯一性约束-unique" class="headerlink" title="13.2、唯一性约束(unique)"></a>13.2、唯一性约束(unique)</h3><p><em>唯一约束修饰的字段具有唯一性,不能重复。但可以为NULL。</em>案例:给某一列添加unique<br>drop table if exists t _user;</p><p>create table t user (<br>id int,<br>username varchar (255) unique &#x2F;&#x2F;列级约束) ;<br>insert into t _user values (1, izhangsan ‘ ) ;</p><p>insert into t _user values(2 , ‘ zhangsan ‘) ;<br>ERROR 1062 (23000): Duplicate entry ‘zhangsan’ for key ‘use</p><p>insert into t _user (id)values (2);</p><p>insert into t_user (id) values (3);insert into t _user(id)values (4);</p><p>案例:给两个列或者多个列添加unique<br>drop table if exists t _user;<br>create table t _user (<br>id int,<br>usercode varchar (255),username varchar (255),</p><p>unique (usercode , username)&#x2F;&#x2F; 多个字段联合起来添加1个约束unique【表级约刺】);<br>insert into t_user values (1,’111’,’zs’) ;</p><p>insert into t _user values (2,’111’, ‘ls ‘) ;</p><p>insert into t user values (3 , ‘222’,’zs ‘) ;select * from t _user;<br>insert into t _user values (4,’111’, ‘zs’ );<br>ERROR 1062 (23000): Duplicate entry ‘111-zs’ for key ‘usercode ‘</p><h3 id="13-3主键约束"><a href="#13-3主键约束" class="headerlink" title="13.3主键约束"></a>13.3主键约束</h3><p>怎么给一张表添加主键约束呢?&#x2F;&#x2F;列级约束<br>drop table if exists t_user ;</p><p>create table t_user (</p><p>id int primary key, </p><p>username varchar (255),</p><p>email varchar (255)<br>) ;<br>insert into t_user(id,username,email) values(1, ‘zs’,’ <a href="mailto:&#122;&#x73;&#64;&#49;&#50;&#51;&#x2e;&#x63;&#x6f;&#109;">&#122;&#x73;&#64;&#49;&#50;&#51;&#x2e;&#x63;&#x6f;&#109;</a>‘ ) ;</p><p>insert into t_user(id,username , email) values(2,’1s’,‘<a href="mailto:&#x31;&#x73;&#64;&#x31;&#50;&#x33;&#x2e;&#99;&#111;&#x6d;">&#x31;&#x73;&#64;&#x31;&#50;&#x33;&#x2e;&#99;&#111;&#x6d;</a> ‘ ) ;</p><p>insert into t_user(id,username , email) values(3 , ‘ww’ ,’ <a href="mailto:&#x77;&#119;&#x40;&#x31;&#50;&#x33;&#x2e;&#99;&#x6f;&#x6d;">&#x77;&#119;&#x40;&#x31;&#50;&#x33;&#x2e;&#99;&#x6f;&#x6d;</a>‘ ) ;</p><p>select *from t_user;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+----+----------+-------------+</span><br><span class="line">| id | username | email       |</span><br><span class="line">+----+----------+-------------+</span><br><span class="line">|  1 | zs       |  zs@123.com |</span><br><span class="line">|  2 | 1s       | 1s@123.com  |</span><br><span class="line">|  3 | ww       |  ww@123.com |</span><br><span class="line">+----+----------+-------------+</span><br></pre></td></tr></table></figure><p>insert into t_user(id,username , email) values(1, ‘jack ‘ , ‘<a href="mailto:&#106;&#97;&#99;&#107;&#x40;&#49;&#x32;&#x33;&#x2e;&#99;&#x6f;&#109;">&#106;&#97;&#99;&#107;&#x40;&#49;&#x32;&#x33;&#x2e;&#99;&#x6f;&#109;</a>‘ ) ;</p><p>ERROR 1062 (23000): Duplicate entry ‘1’ for key ‘t_user.PRIMARY’</p><p><strong>根据以上的测试得出: id是主键，因为添加了主键约束，主键字段中的数据不能为NUL，也不能重复。主键的特点:不能为NULL，也不能重复。</strong><br>*主键相关的术语?<br>主健约束: primary key<br>主键字段: id字段添加primary key之后,id叫做主键字段主键值: id字段中的每一个值都是主键值。<br>主键有什么作用?</p><p>-<strong>表的设计三范式中有要求，第一范式就要求任何一张表都应该有主键。</strong><br>-主键的作用:<strong>主键值是这行记录在这张表当中的唯一标识</strong>。(就像一个人的身份证号码一样。)<br>主健的分类?<br>根据主键字段的字段数量来划分:<br><strong>单一主键(推荐的,常用的。)</strong><br>复合主键(多个字段联合起来添加一个主键约束)(复合主键不建议使用，因为复合主键违背三范式。)根据主键性质来划分:<br>自然主键<strong>：主键值最好就是一个和业务没有任何关系的自然数。</strong><br>业务主键</p><p>​主键值和系统的业务挂钩，例如:拿着银行卡的卡号做主键，拿着身份证号码作为主键。(不推荐用)最好不要拿着和业务挂钩的字段作为主键。因为以后的业务一旦发生改变的时候，主键值可能也需要随着发生变化，但有的时候没有办法变化，因为变化可能会导致主键值重复。</p><p>*<strong>一张表的主键约束只能有1个。(必须记住)</strong></p><h3 id="使用表级约束方式定义主键"><a href="#使用表级约束方式定义主键" class="headerlink" title="*使用表级约束方式定义主键:"></a>*使用表级约束方式定义主键:</h3><p>drop table if exists t_user;</p><p>create table t_user (<br>id int,<br>username varchar (255),</p><p>primary key (id)<br>);<br>insert into t_user(id, username) values(1,’zs ‘);</p><p>insert into t_user(id,username) values(2 , ‘ ls ‘ ) ;</p><p>insert into t_user(id,username) values(3 , ‘ws ‘ ) ;</p><p>insert into t_user(id,username) values(4 , ‘cs ‘);</p><p>select * from t_user;</p><h5 id="mysql提供主健值自增-非常重要。"><a href="#mysql提供主健值自增-非常重要。" class="headerlink" title="mysql提供主健值自增:(非常重要。)"></a>mysql提供主健值自增:(非常重要。)</h5><p>&#x2F;&#x2F; id字段自动维护一个自增的数字，从1开始，以1递增。</p><p>drop table if exists t_user;<br>create table t_user (<br>id int primary key auto_increment,</p><p>username varchar (255)<br>) ;<br>insert into t_user (username) values ( ‘a ‘) ;</p><p>insert into t_user (username) values ( ‘b’ );</p><p>insert into t_user (username) values ( ‘c’) ;</p><p>insert into t_user(username) values ( ‘d’ );</p><p>insert into t_user (username) values ( ‘e’) ;</p><p>insert into t_user (username) values ( ‘f’);</p><p>select * from t_user;</p><p>提示:oracle当中也提供了一个自增机制,叫做:序列(sequence)</p><h3 id="13-4、外键约束"><a href="#13-4、外键约束" class="headerlink" title="13.4、外键约束"></a>13.4、外键约束</h3><p>关于外键约束的相关术语:<br>外键约束:foreign key<br>外键字段:添加有外键约束的字段外键值:外键字段中的每一个值。<br>业务背景:<br>请设计数据库表,用来维护学生和班级的信息?<br>第一种方案:一张表存储所有数据</p><p>业务背景:<br>请设计数据库表,用来维护学生和班级的信息?<br>第一种方案:一张表存储所有数据<br>no (pk)nameclassnoclassname</p><p>1zs101北京大兴区经济技术开发区亦庄二中高三1班<br>2zs101北京大兴区经济技术开发区亦庄二中高三1班<br>3zs101北京大兴区经济技术开发区亦庄二中高三1班<br>4zs101北京大兴区经济技术开发区亦庄二中高三1班<br>5zs101北京大兴区经济技术开发区亦庄二中高三1班</p><p>第二种方案:两张表(班级表和学生表)t _class班级表<br>cno (pk)cname</p><p>101北京大兴区经济技术开发区亦庄二中高三1班<br>102北京大兴区经济技术开发区亦庄二中高三2班</p><p>t student学生表<br>sno (pk)   snamecno(该字段添加外键约束fk)<br>1zs1101<br>2zs2101<br>3zs3102<br>4zs4102<br>5zs5102</p><p>*将以上表的建表语句写出来:<br>t_student中的classno字段引用t_class表中的cno字段，此时t_student表叫做子表。t_class表叫做父表。</p><p>顺序要求:<br>删除数据的时候,先删除子表,再删除父表。</p><p>添加数据的时候,先添加父表,在添加子表。</p><p>创建表的时候,先创建父表,再创建子表。</p><p>删除表的时候,先删除子表,在删除父表。</p><p><strong>外键值可以为NULL?</strong><br><strong>外键可以为NULL.</strong><br>*<strong>外键字段引用其他表的某个字段的时候，被引用的字段必须是主键吗?</strong><br>注意:<strong>被引用的字段不一定是主键,但至少具有unique约束。</strong></p><h2 id="14、存储引擎"><a href="#14、存储引擎" class="headerlink" title="14、存储引擎"></a>14、存储引擎</h2><h3 id="14-1、"><a href="#14-1、" class="headerlink" title="14.1、"></a>14.1、</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show create table `t_user`;</span><br><span class="line">+--------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| Table  | Create Table                                                                                                                                                                                                 |</span><br><span class="line">+--------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| t_user | CREATE TABLE `t_user` (</span><br><span class="line">  `id` int NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `username` varchar(255) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci |</span><br><span class="line">+--------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>注意:在MysQ当中，凡是标识符是可以使用飘号括起来的。最好别用，不通用。<br>建表的时候可以指定存储引擎,也可以指定字符集。<br>mysq1默认使用的存储引擎是InnoDB方式。<br>默认采用的字符集是UTF8</p><h3 id="14-2、什么是存储引擎呢"><a href="#14-2、什么是存储引擎呢" class="headerlink" title="14.2、什么是存储引擎呢?"></a>14.2、什么是存储引擎呢?</h3><p>存储引擎这个名字只有在mysq1中存在。(oracle中有对应的机制，但是不叫做存储引擎。oracle中没有特殊的名字，就是”表的存储方式”)<br>mysql支持很多存储引擎，每一个存储引擎都对应了一种不同的存储方式。每一个存储引擎都有自己的优缺点，需要在合适的时机选择合适的存储引擎。</p><h3 id="14-3、查看当前mysql支持的存储引擎"><a href="#14-3、查看当前mysql支持的存储引擎" class="headerlink" title="14.3、查看当前mysql支持的存储引擎?"></a>14.3、查看当前mysql支持的存储引擎?</h3><p>show engines \G</p><h3 id="14-4、常见的存储引擎"><a href="#14-4、常见的存储引擎" class="headerlink" title="14.4、常见的存储引擎?"></a>14.4、常见的存储引擎?</h3><h5 id="Engine-MyISAM"><a href="#Engine-MyISAM" class="headerlink" title="Engine: MyISAM"></a>Engine: MyISAM</h5><pre><code> Support: YES</code></pre><p> Comment: MyISAM storage engine</p><p><strong>Transactions: NO</strong><br>          XA: NO<br>  Savepoints: NO</p><ul><li>MylSAM存储引擎是MySQL最常用的引擎。<ul><li>它管理的表具有以下特征:<ul><li>使用三个文件表示每个表:<ul><li><strong>格式文件―存储表结构的定义〈 mytable.frm)</strong> </li><li><strong>数据文件一存储表行的内容( mytable.MYD)</strong></li><li><strong>索引文件―存储表上索引( mytable.MYI)</strong></li></ul></li><li>灵活的AUTO_INCREMENT字段处理</li><li>可被转换为压缩、只读表来节省空间</li></ul></li></ul></li></ul><p><strong>MyISAM这种存储引擎不支持事务。</strong><br>MyISAM是mysql最常用的存储引擎，但是这种引擎不是默认的。MyISAM采用三个文件组织一张表:<br>xxx.frm (存储格式的文件)<br>xxx.MYD(存储表中数据的文件)xxx.MYI (存储表中索引的文件)<br><strong>优点:可被压缩，节省存储空间。并且可以转换为只读表，提高检索效率。</strong></p><p><strong>缺点:不支持事务。</strong></p><h5 id="Engine-InnoDB"><a href="#Engine-InnoDB" class="headerlink" title="Engine: InnoDB"></a>Engine: InnoDB</h5><p> Support: DEFAULT<br> Comment: Supports transactions, row-level locking, and foreign keys</p><p><strong>Transactions: YES</strong><br>          XA: YES<br>  Savepoints: YES</p><ul><li>InnoDB存储引擎是MySQL 的缺省引擎。</li><li>它管理的表具有下列主要特征:<ul><li>-每个InnoDB表在数据库目录中以.frm格式文件表示</li><li>InnoDB表空间tablespace被用于存储表的内容。</li><li>提供一组用来记录事务性活动的日志文件v</li><li>用COMMIT(提交)、SAVEPOINT及ROLLBACK(回滚)</li><li>支持事务处理</li><li>提供全ACID兼容·</li><li>在MySQL服务器崩溃后提供自动恢复-</li><li>多版本（MNCC)和行级锁定</li><li>支持外键及引用的完整性，包括级联删除和更新</li></ul></li></ul><p><strong>优点:支持事务、行级锁、外键等。这种存储引擎数据的安全得到保障</strong><br><strong>表的结构存储在xxx.frm文件中</strong><br><strong>数据存储在tablespace这样的表空间中（逻辑概念），无法被压缩，无法转换成只读。</strong></p><p><strong>InnoDB支持级联删除和级联更新。</strong></p><h5 id="Engine-MEMORY"><a href="#Engine-MEMORY" class="headerlink" title="Engine: MEMORY"></a>Engine: MEMORY</h5><p> Support: YES<br> Comment: Hash based, stored in memory, useful for temporary tables</p><p><strong>Transactions: NO</strong><br>          XA: NO<br>  Savepoints: NO</p><p><strong>缺点:不支持事务。数据容易丢失。因为所有数据和索引都是存储在内存当中的。优点:查询速度最快。</strong><br><strong>以前叫做HEPA引擎。</strong></p><h2 id="15、事务（Transaction）"><a href="#15、事务（Transaction）" class="headerlink" title="15、事务（Transaction）"></a>15、事务（Transaction）</h2><h3 id="15-1、什么是事务"><a href="#15-1、什么是事务" class="headerlink" title="15.1、什么是事务?"></a>15.1、什么是事务?</h3><p>一个事务是一个完整的业务逻辑单元,不可再分。<br>比如:银行账户转账，从z账户向z账户转账10000.需要执行两条update语句:<br>update t_act set balance &#x3D; balance - 10000 where actno &#x3D; ‘act-001’;</p><p>update t_act set balance &#x3D; balance + 10000 where actno &#x3D; ‘act-002 ‘ ;</p><p>以上两条DM语句必须同时成功，或者同时失败，不允许出现一条成功，一条失败</p><p>要想保证以上的两条DM.语句同时成功或者同时失败，那么就需要使用数据库的”事务机制”。</p><h3 id="15-2、和事务相关的语句只有-DM语句。-insert-delete-update"><a href="#15-2、和事务相关的语句只有-DM语句。-insert-delete-update" class="headerlink" title="15.2、和事务相关的语句只有:DM语句。(insert delete update)"></a>15.2、和事务相关的语句只有:DM语句。(insert delete update)</h3><p><strong>为什么?因为它们这三个语句都是和数据库表当中的”数据”相关的。</strong></p><p><strong>事务的存在是为了保证数据的完整性,安全性。</strong></p><h3 id="15-3、假设所有的业务都能使用1条DM语句搞定，还需要事务机制吗"><a href="#15-3、假设所有的业务都能使用1条DM语句搞定，还需要事务机制吗" class="headerlink" title="15.3、假设所有的业务都能使用1条DM语句搞定，还需要事务机制吗?"></a>15.3、假设所有的业务都能使用1条DM语句搞定，还需要事务机制吗?</h3><p>不需要事务。</p><p>但实际情况不是这样的，通常一个”事儿(事务【业务】)”需要多条DM语句共同联合完成。</p><h3 id="15-4、事务的特性"><a href="#15-4、事务的特性" class="headerlink" title="15.4、事务的特性?"></a>15.4、事务的特性?</h3><p>事务包括四大特性:ACID<br>A:原子性:事务是最小的工作单元,不可再分。<br>c:一致性:事务必须保证多条DML语句同时成功或者同时失败。</p><p>I:隔离性:事务A与事务B之间具有隔离。<br>D:持久性:持久性说的是最终数据必须持久化到硬盘文件中，事务才算成功的结束。</p><h3 id="15-5、关于事务之间的隔离性"><a href="#15-5、关于事务之间的隔离性" class="headerlink" title="15.5、关于事务之间的隔离性"></a>15.5、关于事务之间的隔离性</h3><ul><li>事务隔离性存在隔离级别,理论上隔离级别包括4个:<ul><li>第一级别:读未提交( read uncommitted)<ul><li>对方事务还没有提交，我们当前事务可以读取到对方未提交的数据。</li><li>读未提交存在脏读(Dirty Read)现象:表示读到了脏的数据</li></ul></li><li>第二级别:读己提交(read committed)<ul><li>对方事务提交之后的数据我方可以读取到。读已提交存在的问题是:不可重复读。</li></ul></li><li>第三级别:可重复读(repeatable read)<ul><li>这种隔离级别解决了:不可重复读问题。</li><li>这种隔离级别存在的问题是:读取到的数据是幻象。</li></ul></li><li>第四级别:序列化读&#x2F;串行化读<ul><li>解决了所有问题。</li><li>效率低。需要事务排队。</li></ul></li></ul></li><li>oracle数据库默认的隔离级别是:读已提交。mysql数据库默认的隔离级别是:可重复读。</li><li>mysql默认的事务隔离级别是三挡起步:可重复读（repeatable read)</li></ul><h3 id="15-6、演示事务"><a href="#15-6、演示事务" class="headerlink" title="15.6、演示事务"></a>15.6、演示事务</h3><p>mysql事务默认情况下是自动提交的。<br><strong>(什么是自动提交﹖只要执行任意一条DMz语句则提交一次。)</strong></p><p><strong>怎么关闭自动提交? start transaction;</strong></p><p>*准备表:<br>drop table if exists t_user;</p><p>create table t_user (<br>id int primary key auto_increment,</p><p>username varchar (255)<br>);</p><p><strong>演示: mysql中的事务是支持自动提交的，只要执行一条DML，则提交一次。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">insert into t_user(username) values(&#x27;zs&#x27;);</span><br><span class="line">select * from t_user;</span><br><span class="line">rollback;</span><br><span class="line">select * from t_user;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t_user(username) values(&#x27;zs&#x27;);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t_user;</span><br><span class="line">+----+----------+</span><br><span class="line">| id | username |</span><br><span class="line">+----+----------+</span><br><span class="line">|  1 | zs       |</span><br><span class="line">+----+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; rollback;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t_user;</span><br><span class="line">+----+----------+</span><br><span class="line">| id | username |</span><br><span class="line">+----+----------+</span><br><span class="line">|  1 | zs       |</span><br><span class="line">+----+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>演示:使用start transaction;关闭自动提交机制,<br>mysql&gt; start transaction ;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> start transaction ;</span><br><span class="line"> insert into t_user(username) values(&#x27;lsas&#x27;);</span><br><span class="line">select * from t_user;</span><br><span class="line">rollback;</span><br><span class="line">select * from t_user;</span><br><span class="line">mysql&gt;  insert into t_user(username) values(&#x27;lsas&#x27;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t_user;</span><br><span class="line">+----+----------+</span><br><span class="line">| id | username |</span><br><span class="line">+----+----------+</span><br><span class="line">|  1 | zs       |</span><br><span class="line">|  2 | lsas     |</span><br><span class="line">+----+----------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; rollback;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; select * from t_user;</span><br><span class="line">+----+----------+</span><br><span class="line">| id | username |</span><br><span class="line">+----+----------+</span><br><span class="line">|  1 | zs       |</span><br><span class="line">+----+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="15-7、使用两个事务演示以上的隔离级别"><a href="#15-7、使用两个事务演示以上的隔离级别" class="headerlink" title="15.7、使用两个事务演示以上的隔离级别"></a>15.7、使用两个事务演示以上的隔离级别</h3><h4 id="第一-演示read-uncommitted"><a href="#第一-演示read-uncommitted" class="headerlink" title="第一:演示read uncommitted"></a>第一:演示read uncommitted</h4><ul><li><p>设置事务的隔离级别: </p><ul><li>set global transaction isolation level read uncommitted;</li></ul></li><li><p>查看事务的全局隔离级别:</p><ul><li><p>mysql&gt; select @@global.transaction_isolation;(5.0)</p></li><li><p>mysql&gt; select @@global.transaction_isolation;(8.0)</p></li><li><p>&#96;&#96;&#96;<br>+——————————–+<br>| @@global.transaction_isolation |<br>+——————————–+<br>| READ-UNCOMMITTED               |<br>+——————————–+<br>1 row in set (0.00 sec)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">- mysql -uroot -proot</span><br><span class="line"></span><br><span class="line">- use bjpowernode;</span><br><span class="line"></span><br><span class="line">- start transaction ;</span><br><span class="line"></span><br><span class="line">- insert into t_user(username) value(&quot;SMITH1&quot;);</span><br><span class="line"></span><br><span class="line">- select * from t_user;</span><br><span class="line"></span><br><span class="line">**能够读到1窗口未提交的数据**</span><br><span class="line"></span><br><span class="line">![image-20221025204113351](./MySQL-2/1.png)</span><br><span class="line"></span><br><span class="line">第二:演示read committed</span><br><span class="line">第三:演示repeatable read</span><br><span class="line">第四:演示serializabie</span><br><span class="line"></span><br><span class="line">## 16、索引</span><br><span class="line"></span><br><span class="line">### 4.1、什么是索引?有什么用?</span><br><span class="line"></span><br><span class="line">- **索引就相当于一本书的目录，通过目录可以快速的找到对应的资源**。</span><br><span class="line">- 在数据库方面,查询一张表的时候有两种检索方式:</span><br><span class="line">  - 第一种方式:全表扫播</span><br><span class="line">  - 第二种方式:根据索引检索(效率很高)索引为什么可以提高检索效率呢?</span><br><span class="line">    - **其实最根本的原理是缩小了扫描的范围。**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">索引虽然可以提高检索效率，但是不能随意的添加索引，因为索引也是数据库当中的对象，也需要数据库不断的维护。是有维护成本的。比如，表中的数据经常被修改这样就不适合添加索引，因为数据一旦修改，索引需要重新排序，进行维护。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">select ename ,sal from emp where ename = &#x27;SMITH&#x27;;</span><br><span class="line">当ename字段上没有添加索引的时候，以上sql语句会进行全表扫描，扫描ename字段中所有的值。</span><br><span class="line"></span><br><span class="line">当ename字段上添加索引的时候，以上sql语句会根据索引扫描，快速定位。</span><br><span class="line"></span><br><span class="line">### 4.2、怎么创建索引对象?怎么删除索引对象?</span><br><span class="line"></span><br><span class="line">创建索引对象:</span><br><span class="line">create index 索引名称 on 表名（字段名);</span><br><span class="line"></span><br><span class="line">删除索引对象:</span><br><span class="line">drop index索引名称on表名;</span><br><span class="line"></span><br><span class="line">### 4.3、什么时候考虑给字段添加索引?（满足什么条件)</span><br><span class="line"></span><br><span class="line">- 数据量庞大。（根据客户的需求，根据线上的环境)</span><br><span class="line">- 该字段很少的DM操作。(因为字段进行修改操作，索引也需要维护)*</span><br><span class="line">- 该字段经常出现在where子句中。（经常根据哪个字段查询)</span><br><span class="line"></span><br><span class="line">### 4.4、注意:主键和具有unique约束的字段自动会添加索引。</span><br><span class="line"></span><br><span class="line">根据主键查询效率较高。尽量根据主键检索。</span><br><span class="line"></span><br><span class="line">### 4.5、查看sql语句的执行计划:</span><br><span class="line"></span><br><span class="line">mysq1&gt; explain select ename ,sal from emp where  sal=5000;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul><p>+—-+————-+——-+————+——+—————+——+———+——+——+———-+————-+<br>| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |<br>+—-+————-+——-+————+——+—————+——+———+——+——+———-+————-+<br>|  1 | SIMPLE      | emp   | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   14 |    10.00 | Using where |<br>+—-+————-+——-+————+——+—————+——+———+——+——+———-+————-+</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">给薪资sal字段添加索引:</span><br><span class="line">create index emp_sal_index on emp (sal) ;</span><br><span class="line"></span><br><span class="line">mysq1&gt; explain select ename ,sal from emp where  sal=5000;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>+—-+————-+——-+————+——+—————+—————+———+——-+——+———-+——-+<br>| id | select_type | table | partitions | type | possible_keys | key           | key_len | ref   | rows | filtered | Extra |<br>+—-+————-+——-+————+——+—————+—————+———+——-+——+———-+——-+<br>|  1 | SIMPLE      | emp   | NULL       | ref  | emp_sal_index | emp_sal_index | 9       | const |    1 |   100.00 | NULL  |<br>+—-+————-+——-+————+——+—————+—————+———+——-+——+———-+——-+</p><pre><code>### 4.6、索引底层采用的数据结构是:B +Tree### 4.7、索引的实现原理?通过B Tree缩小扫描范围，底层索引进行了排序，分区，索引会携带数据在表中的&quot;物理地址&quot;,**最终通过索引检索到数据之后，获取到关联的物理地址，通过物理地址定位表中的数据，效率是最高的。**select ename from emp where ename = &#39;SMITH&#39;;通过索引转换为:select ename from emp where物理地址= 0x3 ;![image-20221025211620681](./MySQL-2/2.png)### 4.8、索引的分类?单一索引:给单个字段添加索引复合索引:给多个字段联合起来添加1个索引主键索引:主键上会自动添加索引唯一索引:有unique约束的字段上会自动添加索引### 4.9、索引什么时候失效?select ename from emp where enane like &#39;%A%&#39;;**模糊查询的时候，第一个通配符使用的是8，这个时候索引是失效的**</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL(1)</title>
      <link href="/2022/10/26/MySQL-1/"/>
      <url>/2022/10/26/MySQL-1/</url>
      
        <content type="html"><![CDATA[<h2 id="1、什么是数据库﹖什么是数据库管理系统-什么是sQr-他们之间的关系是什么"><a href="#1、什么是数据库﹖什么是数据库管理系统-什么是sQr-他们之间的关系是什么" class="headerlink" title="1、什么是数据库﹖什么是数据库管理系统?什么是sQr?他们之间的关系是什么"></a>1、什么是数据库﹖什么是数据库管理系统?什么是sQr?他们之间的关系是什么</h2><p>数据库:<br>英文单词DataBase，简称DB。按照一定格式存储数据的一些文件的组合。顾名思义:存储数据的仓库，实际上就是一堆文件。这些文件中存储了具有特定格式的数据。<br>数据库管理系统:</p><p><strong>DataBaseManagement,简称DBMs.</strong><br>数据库管理系统是专门用来管理数据库中数据的，数据库管理系统可以对数据库当中的数据进行增删改查。<br>常见的数据库管理系统:<br>MysQL、Oracle、MS sqlserver、DB2、sybase等….</p><p><strong>SQL:结构化查询语言</strong><br>程序员需要学习sQL语句，程序员通过编写sQL语句，然后DBMs负责执行soI语句，最终来完成数据库中孪据的增删改查操作。</p><p>SQL是一套标准，程序员主要学习的就是sQr语句，这个sQL在mysql中可以使用，同时在oracle中也可以使用，在DB2中也可以使用。</p><p><strong>三者之间的关系?</strong><br>DBMs-―执行―-&gt;sQL.-―操作–&gt;DE</p><p>安装</p><p><strong>设置密码的同时,可以激活root账户远程访问.激活:表示root账号可以在外地登录.</strong><br><strong>不激活:表示root账号只能在本机上使用.</strong></p><h2 id="2、数据库当中最基本的单元—-表"><a href="#2、数据库当中最基本的单元—-表" class="headerlink" title="2、数据库当中最基本的单元—-表"></a>2、数据库当中最基本的单元—-表</h2><p>什么是表table?为什么用表来存储数据呢?</p><p>姓名性别年龄（列：字段）</p><hr><p>张三  男20———–&gt;行（记录）<br>李四  女21———–&gt;行（记录）<br>王五  男22———–&gt;行（记录）</p><p>数据库当中是以表格的形式表示数据的.因为表比较直观</p><p>每一个字段都有:字段名、数据类型、约束等属性.字段名可以理解，是一个普通的名字，见名知意就行。数据类型:字符串,数字，日期等,<br><strong>约束:约束有很多，其中一个叫做唯一性约束，这种约束添加之后,该字段中的数据不能重复。</strong></p><h2 id="3、SQL语句有很多，最好进行分门别类，这样更容易记忆。"><a href="#3、SQL语句有很多，最好进行分门别类，这样更容易记忆。" class="headerlink" title="3、SQL语句有很多，最好进行分门别类，这样更容易记忆。"></a>3、SQL语句有很多，最好进行分门别类，这样更容易记忆。</h2><p>分为:</p><p><strong>DQL:</strong></p><ul><li>数据查询语言（凡是带有select关键字的都是查询语句)select. ..</li></ul><p><strong>DML:</strong></p><ul><li>数据操作语言（凡是对表当中的数据进行增删改的都是DML)insert delete update</li><li>insert增</li><li>delete删</li><li>update改</li><li>这个主要是操作<strong>表中的数据data.</strong></li></ul><p><strong>DDL:</strong> </p><ul><li>数据定义语言</li><li>凡是带有create、drop- alter的都是DDL.</li><li>DDL主要操作的是表的结构。不是表中的数据。create:新建，等同于增</li><li>drop:删除</li><li>alter:修改</li><li>这个增删改和DML不同，这个主要是<strong>对表结构进行操作。</strong></li></ul><p>TCL:</p><ul><li>不是王牌电视-是事务控制语言包括:</li><li>事务提交:commit;</li><li>事务回滚: rollback ;</li></ul><p><strong>DCL:</strong></p><ul><li>是数据控制语言-</li><li>例如:授权grant、撤销权限revoke . . . .</li></ul><h2 id="4、导入数据（后期练习的时候使用这个演示的数据"><a href="#4、导入数据（后期练习的时候使用这个演示的数据" class="headerlink" title="4、导入数据（后期练习的时候使用这个演示的数据)"></a>4、导入数据（后期练习的时候使用这个演示的数据)</h2><ul><li>第一步:登录mysql数据库管理系统<br>dos命令窗口:<br>mysql -uroot -proot</li><li>第二步:查看有哪些数据库<br>show databases;(这个不是SQL语句，属于MySQL的命令。)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| pet                |</span><br><span class="line">| shopping           |</span><br><span class="line">| sys                |</span><br><span class="line">+--------------------+</span><br></pre></td></tr></table></figure><ul><li>第三步:创建属于我们自己的数据库<br>create database bjpowernode;(这个不是SQL语句，属于MySQL的命令。)</li><li>第四步:使用bjpowernode数据<br>use bjpowernode;(这个不是SQL语句，属于MySQL的命令。)</li><li>第五步:查看当前使用的数据库中有哪些表?</li><li>show tables;(这个不是SQL语句，属于MySQL的命令。)</li><li>第六步:初始化数据<br>mysql&gt; source D:\mods\bjpowernode.sql<br>注意:数据初始化完成之后,有三张表:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------+</span><br><span class="line">| Tables_in_bjpowernode |</span><br><span class="line">+-----------------------+</span><br><span class="line">| dept                  |</span><br><span class="line">| emp                   |</span><br><span class="line">| salgrade              |</span><br><span class="line">+-----------------------+</span><br></pre></td></tr></table></figure><h2 id="5、bjpowernode-sql，这个文件以sql结尾，这样的文件被称为”sql脚本”。什么是sql脚本呢"><a href="#5、bjpowernode-sql，这个文件以sql结尾，这样的文件被称为”sql脚本”。什么是sql脚本呢" class="headerlink" title="5、bjpowernode.sql，这个文件以sql结尾，这样的文件被称为”sql脚本”。什么是sql脚本呢?"></a>5、bjpowernode.sql，这个文件以sql结尾，这样的文件被称为”sql脚本”。什么是sql脚本呢?</h2><p>当一个文件的扩展名是.sql，并且该文件中编写了大量的sql语句，我们称这样的文件为sql脚本。</p><p><strong>注意:直接使用source命令可以执行sql脚本。</strong><br><strong>sql脚本中的数据量太大的时候，无法打开，请使用source命令完成初始化。</strong></p><h2 id="6、删除数据库-drop-database-bjpowernode"><a href="#6、删除数据库-drop-database-bjpowernode" class="headerlink" title="6、删除数据库: drop database bjpowernode ;"></a>6、删除数据库: drop database bjpowernode ;</h2><h2 id="7、查看表结构"><a href="#7、查看表结构" class="headerlink" title="7、查看表结构"></a>7、查看表结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------+</span><br><span class="line">| Tables_in_bjpowernode |</span><br><span class="line">+-----------------------+</span><br><span class="line">| dept                  |（部门表）</span><br><span class="line">| emp                   |（员工表）</span><br><span class="line">| salgrade              |（工资等级表）</span><br><span class="line">+-----------------------+</span><br></pre></td></tr></table></figure><p>desc dept;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field  | Type        | Null | Key | Default | Extra |</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| DEPTNO | int         | NO   | PRI | NULL    |       |部门编号</span><br><span class="line">| DNAME  | varchar(14) | YES  |     | NULL    |       |部门名称</span><br><span class="line">| LOC    | varchar(13) | YES  |     | NULL    |       |部门位置</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br></pre></td></tr></table></figure><p>desc emp;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+----------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field    | Type        | Null | Key | Default | Extra |</span><br><span class="line">+----------+-------------+------+-----+---------+-------+</span><br><span class="line">| EMPNO    | int         | NO   | PRI | NULL    |       |员工编号</span><br><span class="line">| ENAME    | varchar(10) | YES  |     | NULL    |       |员工姓名</span><br><span class="line">| JOB      | varchar(9)  | YES  |     | NULL    |       |工作岗位</span><br><span class="line">| MGR      | int         | YES  |     | NULL    |       |上级领导</span><br><span class="line">| HIREDATE | date        | YES  |     | NULL    |       |编号入职日期</span><br><span class="line">| SAL      | double(7,2) | YES  |     | NULL    |       |月薪</span><br><span class="line">| COMM     | double(7,2) | YES  |     | NULL    |       |补助/津贴</span><br><span class="line">| DEPTNO   | int         | YES  |     | NULL    |       |部门编号</span><br><span class="line">+----------+-------------+------+-----+---------+-------+</span><br></pre></td></tr></table></figure><p>desc salgrade;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+-------+------+------+-----+---------+-------+</span><br><span class="line">| Field | Type | Null | Key | Default | Extra |</span><br><span class="line">+-------+------+------+-----+---------+-------+</span><br><span class="line">| GRADE | int  | YES  |     | NULL    |       |等级</span><br><span class="line">| LOSAL | int  | YES  |     | NULL    |       |最低薪资</span><br><span class="line">| HISAL | int  | YES  |     | NULL    |       |最高薪资</span><br><span class="line">+-------+------+------+-----+---------+-------+</span><br></pre></td></tr></table></figure><h2 id="8、表中得数据？"><a href="#8、表中得数据？" class="headerlink" title="8、表中得数据？"></a>8、表中得数据？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from emp;</span><br><span class="line">+-------+--------+-----------+------+------------+---------+---------+--------+</span><br><span class="line">| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |</span><br><span class="line">+-------+--------+-----------+------+------------+---------+---------+--------+</span><br><span class="line">|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |</span><br><span class="line">|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |</span><br><span class="line">|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |</span><br><span class="line">|  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |</span><br><span class="line">|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |</span><br><span class="line">|  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |</span><br><span class="line">|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     10 |</span><br><span class="line">|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 |</span><br><span class="line">|  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 |</span><br><span class="line">|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |</span><br><span class="line">|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 |</span><br><span class="line">|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 |</span><br><span class="line">|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 |</span><br><span class="line">|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |</span><br><span class="line">+-------+--------+-----------+------+------------+---------+---------+--------+</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from dept;</span><br><span class="line">+--------+------------+----------+</span><br><span class="line">| DEPTNO | DNAME      | LOC      |</span><br><span class="line">+--------+------------+----------+</span><br><span class="line">|     10 | ACCOUNTING | NEW YORK |</span><br><span class="line">|     20 | RESEARCH   | DALLAS   |</span><br><span class="line">|     30 | SALES      | CHICAGO  |</span><br><span class="line">|     40 | OPERATIONS | BOSTON   |</span><br><span class="line">+--------+------------+----------+</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from salgrade;</span><br><span class="line">+-------+-------+-------+</span><br><span class="line">| GRADE | LOSAL | HISAL |</span><br><span class="line">+-------+-------+-------+</span><br><span class="line">|     1 |   700 |  1200 |</span><br><span class="line">|     2 |  1201 |  1400 |</span><br><span class="line">|     3 |  1401 |  2000 |</span><br><span class="line">|     4 |  2001 |  3000 |</span><br><span class="line">|     5 |  3001 |  9999 |</span><br><span class="line">+-------+-------+-------+</span><br></pre></td></tr></table></figure><h2 id="9、-c命令，结束一条语句。exit命令，退出mysql。"><a href="#9、-c命令，结束一条语句。exit命令，退出mysql。" class="headerlink" title="9、\c命令，结束一条语句。exit命令，退出mysql。"></a>9、\c命令，结束一条语句。exit命令，退出mysql。</h2><h2 id="10、查看创建表的语句"><a href="#10、查看创建表的语句" class="headerlink" title="10、查看创建表的语句:"></a>10、查看创建表的语句:</h2><p>show create table emp ;</p><h2 id="11、简单的查询语句-DQL"><a href="#11、简单的查询语句-DQL" class="headerlink" title="11、简单的查询语句(DQL)"></a>11、简单的查询语句(DQL)</h2><p>语法格式:<br>    select 字段名1,字段名2,字段名3,.. .. from 表名;</p><p>提示:<br>    <strong>1、任何一条sql语句以”;”结尾。</strong></p><p>​<strong>2、sql语句不区分大小写。</strong></p><h4 id="查询员工的年薪-字段可以参与数学运算。"><a href="#查询员工的年薪-字段可以参与数学运算。" class="headerlink" title="查询员工的年薪?(字段可以参与数学运算。)"></a>查询员工的年薪?(字段可以参与数学运算。)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select ename , sal *12 from emp;</span><br><span class="line">+--------+----------+</span><br><span class="line">| ename  | sal *12  |</span><br><span class="line">+--------+----------+</span><br><span class="line">| SMITH  |  9600.00 |</span><br><span class="line">| ALLEN  | 19200.00 |</span><br><span class="line">| WARD   | 15000.00 |</span><br><span class="line">| JONES  | 35700.00 |</span><br><span class="line">| MARTIN | 15000.00 |</span><br><span class="line">| BLAKE  | 34200.00 |</span><br><span class="line">| CLARK  | 29400.00 |</span><br><span class="line">| SCOTT  | 36000.00 |</span><br><span class="line">| KING   | 60000.00 |</span><br><span class="line">| TURNER | 18000.00 |</span><br><span class="line">| ADAMS  | 13200.00 |</span><br><span class="line">| JAMES  | 11400.00 |</span><br><span class="line">| FORD   | 36000.00 |</span><br><span class="line">| MILLER | 15600.00 |</span><br><span class="line">+--------+----------+</span><br></pre></td></tr></table></figure><h4 id="给查询结果的列重命名"><a href="#给查询结果的列重命名" class="headerlink" title="给查询结果的列重命名?"></a>给查询结果的列重命名?</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">select ename , sal *12 as yearsal from emp;</span><br><span class="line">别名中有中文?</span><br><span class="line">select ename ,sal * 12 as 年薪 from emp; //错误</span><br><span class="line">select ename , sal*12 as &#x27;年薪&#x27; from emp;</span><br><span class="line"></span><br><span class="line">mysql&gt; select ename , sal*12 as &#x27;年薪&#x27; from emp;</span><br><span class="line">+--------+----------+</span><br><span class="line">| ename  | 年薪     |</span><br><span class="line">+--------+----------+</span><br><span class="line">| SMITH  |  9600.00 |</span><br><span class="line">| ALLEN  | 19200.00 |</span><br><span class="line">| WARD   | 15000.00 |</span><br><span class="line">| JONES  | 35700.00 |</span><br><span class="line">| MARTIN | 15000.00 |</span><br><span class="line">| BLAKE  | 34200.00 |</span><br><span class="line">| CLARK  | 29400.00 |</span><br><span class="line">| SCOTT  | 36000.00 |</span><br><span class="line">| KING   | 60000.00 |</span><br><span class="line">| TURNER | 18000.00 |</span><br><span class="line">| ADAMS  | 13200.00 |</span><br><span class="line">| JAMES  | 11400.00 |</span><br><span class="line">| FORD   | 36000.00 |</span><br><span class="line">| MILLER | 15600.00 |</span><br><span class="line">+--------+----------+</span><br></pre></td></tr></table></figure><h4 id="注意-标准sql语句中要求字符串使用单引号括起来。虽然mysql支持双引号，尽量别用。"><a href="#注意-标准sql语句中要求字符串使用单引号括起来。虽然mysql支持双引号，尽量别用。" class="headerlink" title="注意:标准sql语句中要求字符串使用单引号括起来。虽然mysql支持双引号，尽量别用。"></a>注意:标准sql语句中要求字符串使用单引号括起来。虽然mysql支持双引号，尽量别用。</h4><p>as关键字可以省略?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select empno ,ename ,sal * 12 yearsal from emp;</span><br><span class="line">+-------+--------+----------+</span><br><span class="line">| empno | ename  | yearsal  |</span><br><span class="line">+-------+--------+----------+</span><br><span class="line">|  7369 | SMITH  |  9600.00 |</span><br><span class="line">|  7499 | ALLEN  | 19200.00 |</span><br><span class="line">|  7521 | WARD   | 15000.00 |</span><br><span class="line">|  7566 | JONES  | 35700.00 |</span><br><span class="line">|  7654 | MARTIN | 15000.00 |</span><br><span class="line">|  7698 | BLAKE  | 34200.00 |</span><br><span class="line">|  7782 | CLARK  | 29400.00 |</span><br><span class="line">|  7788 | SCOTT  | 36000.00 |</span><br><span class="line">|  7839 | KING   | 60000.00 |</span><br><span class="line">|  7844 | TURNER | 18000.00 |</span><br><span class="line">|  7876 | ADAMS  | 13200.00 |</span><br><span class="line">|  7900 | JAMES  | 11400.00 |</span><br><span class="line">|  7902 | FORD   | 36000.00 |</span><br><span class="line">|  7934 | MILLER | 15600.00 |</span><br><span class="line">+-------+--------+----------+</span><br></pre></td></tr></table></figure><h4 id="查询所有字段？"><a href="#查询所有字段？" class="headerlink" title="查询所有字段？"></a>查询所有字段？</h4><p>​select * from emp; <strong>&#x2F;&#x2F;实际开发中不推荐使用，效率低</strong></p><h2 id="12、条件查询"><a href="#12、条件查询" class="headerlink" title="12、条件查询"></a>12、条件查询</h2><p>语法格式:<br>    select<br>        字段,字段…</p><p>​from<br>​表名<br>​where<br>​条件;</p><p><strong>执行顺序:先from，然后where，最后select查询</strong></p><h5 id="工资等于5000的员工姓名"><a href="#工资等于5000的员工姓名" class="headerlink" title="工资等于5000的员工姓名?"></a>工资等于5000的员工姓名?</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select ename from emp where sal = 5000 ;</span><br><span class="line">+-------+</span><br><span class="line">| ename |</span><br><span class="line">+-------+</span><br><span class="line">| KING  |</span><br><span class="line">+-------+</span><br></pre></td></tr></table></figure><h5 id="查询SM工TH的工资"><a href="#查询SM工TH的工资" class="headerlink" title="查询SM工TH的工资?"></a>查询SM工TH的工资?</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select sal from emp where ename = &#x27;SMITH&#x27;; //字符串使用单引号括起来。</span><br><span class="line">+--------+</span><br><span class="line">| sal    |</span><br><span class="line">+--------+</span><br><span class="line">| 800.00 |</span><br><span class="line">+--------+</span><br></pre></td></tr></table></figure><h5 id="找出工资高于3000的员工"><a href="#找出工资高于3000的员工" class="headerlink" title="找出工资高于3000的员工?"></a>找出工资高于3000的员工?</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select ename , sal from emp where sal &gt; 3000;</span><br><span class="line">select ename , sal from emp where sal &gt;= 300o ;select ename ,sal from emp where sal &lt; 3000;select ename ,sal from emp </span><br></pre></td></tr></table></figure><h5 id="where-sal-lt-x3D-3000-找出工资不等于3000的"><a href="#where-sal-lt-x3D-3000-找出工资不等于3000的" class="headerlink" title="where sal &lt;&#x3D; 3000 ;找出工资不等于3000的?"></a>where sal &lt;&#x3D; 3000 ;找出工资不等于3000的?</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select ename ,sal from emp where sal &lt;&gt; 3000 ;</span><br><span class="line">x select ename ,sal from emp where sal != 3000 ;</span><br></pre></td></tr></table></figure><h5 id="找出工资在1100和3000之间的员工-包括1100和3000"><a href="#找出工资在1100和3000之间的员工-包括1100和3000" class="headerlink" title="找出工资在1100和3000之间的员工,包括1100和3000?"></a>找出工资在1100和3000之间的员工,包括1100和3000?</h5><p>select ename ,sal from emp where sal &gt;&#x3D; 1100 and sal &lt;&#x3D; 3000;<br>select ename ,sal from emp where sal between 1100 and 3000; &#x2F;&#x2F; between…and…是闭区间[1100 ～ 3000]</p><p>select ename ,sal from emp where sal between 3000 and 1100;&#x2F;&#x2F;查询不到任何数据<br><strong>between and在使用的时候必须左小右大。</strong><br>between and除了可以使用在数字方面之外，还可以使用在字符串方面</p><p>select ename from emp where ename between ‘A’ and ‘C’; &#x2F;&#x2F;左闭右开。</p><h5 id="找出哪些人没有津贴"><a href="#找出哪些人没有津贴" class="headerlink" title="找出哪些人没有津贴?"></a>找出哪些人没有津贴?</h5><p><strong>在数据库当中NULL不是一个值,代表什么也没有，为空。空不是一个值,不能用等号衡量。</strong><br><strong>必须使用is null或者is not null</strong><br>select ename ,sal , comm from emp where corm is null;</p><h5 id="找出哪些人津贴不为NULL"><a href="#找出哪些人津贴不为NULL" class="headerlink" title="找出哪些人津贴不为NULL?"></a>找出哪些人津贴不为NULL?</h5><p>select ename ,sal, comm from emp where comm <strong>is not null;</strong></p><h5 id="找出工作岗位是MANAGER和SALESMAN的员工"><a href="#找出工作岗位是MANAGER和SALESMAN的员工" class="headerlink" title="找出工作岗位是MANAGER和SALESMAN的员工?"></a>找出工作岗位是MANAGER和SALESMAN的员工?</h5><p>select ename ,job from emp where job &#x3D; ‘MANAGER’ or job &#x3D; ‘SALESMAN’</p><p><strong>AND永远是并且</strong></p><h5 id="and和or联合起来用-找出薪资大于1000的并且部门编号是20或30部门的员工。"><a href="#and和or联合起来用-找出薪资大于1000的并且部门编号是20或30部门的员工。" class="headerlink" title="and和or联合起来用:找出薪资大于1000的并且部门编号是20或30部门的员工。"></a>and和or联合起来用:找出薪资大于1000的并且部门编号是20或30部门的员工。</h5><p>select ename ,sal,deptno from emp wheresal &gt; 1000 and deptno &#x3D; 20 or deptno &#x3D; 30;  &#x2F;&#x2F;false</p><p>select ename ,sal,deptno from emp wheresal &gt; 1000 and <strong>(<strong>deptno &#x3D; 20 or deptno &#x3D; 30</strong>)</strong>;&#x2F;&#x2F;true</p><p><strong>注意:当运算符的优先级不确定的时候加小括号。</strong></p><h5 id="in等同于or-找出工作岗位是MANAGER和SATESMAN的员工"><a href="#in等同于or-找出工作岗位是MANAGER和SATESMAN的员工" class="headerlink" title="in等同于or:找出工作岗位是MANAGER和SATESMAN的员工?"></a>in等同于or:找出工作岗位是MANAGER和SATESMAN的员工?</h5><p>select ename , job from emp where job &#x3D; ‘SATESMAN’ or job &#x3D;’MANAGER’;</p><p>select ename , job from emp where job in ( ‘ SALESMAN’，’MANAGER’);</p><p>select ename,job from emp where sal in(800，5000);<strong>&#x2F;&#x2F; in后面的值不是区间，是具体的值。</strong></p><p><strong>not in:不在这几个值当中。</strong><br>select ename ,job from emp where sal in(800,5000);</p><h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><p>模糊查询Like ?</p><h5 id="找出名字当中含有o的"><a href="#找出名字当中含有o的" class="headerlink" title="找出名字当中含有o的?"></a>找出名字当中含有o的?</h5><p><strong>(在模糊查询当中，必须掌握两个特殊的符号，一个是%，一个是 _</strong>  )名代表任意多个字符， _代表任意1个字符。</p><p>select ename from emp where ename like ‘%o%’;</p><h5 id="找出名字中第二个字母是A的"><a href="#找出名字中第二个字母是A的" class="headerlink" title="找出名字中第二个字母是A的?"></a>找出名字中第二个字母是A的?</h5><p>select ename from emp where ename like ‘_A%’;</p><p>​</p><h5 id="找出名字中有下划线的"><a href="#找出名字中有下划线的" class="headerlink" title="找出名字中有下划线的?"></a>找出名字中有下划线的?</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name from t user where name like &#x27;\_&#x27;;</span><br></pre></td></tr></table></figure><h2 id="13、排序"><a href="#13、排序" class="headerlink" title="13、排序"></a>13、排序</h2><h5 id="接照工资升序-找出员工名和薪资"><a href="#接照工资升序-找出员工名和薪资" class="headerlink" title="接照工资升序,找出员工名和薪资?"></a>接照工资升序,找出员工名和薪资?</h5><p>select<br>    ename , sal</p><p>from<br>    emp</p><p>order by<br>    ??;</p><p><strong>注意:默认是升序</strong>。怎么指定升序或者降序呢? asc表示升序，desc表示降序。</p><p>select ename , sal from emp order by sal; &#x2F;&#x2F;升序</p><p>select ename , sal from emp order by sal asc; &#x2F;&#x2F;升序</p><p>select ename , sal from emp order by sal desc;&#x2F;&#x2F;降序。</p><p>按照工资的降序排列，<strong>当工资相同的时候再按照名字的升序排列。</strong></p><p>select ename ,sal from emp order by sal desc;<br>select ename ,sal from emp order by sal desc , ename asc;</p><p><strong>注意:越靠前的字段越能起到主导作用。只有当前面的字段无法完成排序的时候，才会启用后面的字段。</strong></p><h5 id="找出工作岗位是SALESMAN的员工，并且要求按照薪资的降序排列。"><a href="#找出工作岗位是SALESMAN的员工，并且要求按照薪资的降序排列。" class="headerlink" title="找出工作岗位是SALESMAN的员工，并且要求按照薪资的降序排列。"></a>找出工作岗位是SALESMAN的员工，并且要求按照薪资的降序排列。</h5><p>select<br>    ename ,job ,sal</p><p>from<br>    emp</p><p>where<br>    job &#x3D; ‘SALESMAN’ order by sal desc;</p><p>select<br>    *  3<br>from<br>    tablename 1<br>where<br>    条件2<br>order by 4<br><strong>order by是最后执行的。</strong></p><h2 id="14、分组函数"><a href="#14、分组函数" class="headerlink" title="14、分组函数"></a>14、分组函数</h2><ul><li>count计数</li><li>sum求和</li><li>avg平均值</li><li>max最大值</li><li>min最小值</li></ul><p><strong>记住:所有的分组函数都是对”某一组”数据进行操作的。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">找出工资总和?</span><br><span class="line">select sum (sal) from emp ;</span><br><span class="line">找出最高工资?</span><br><span class="line">select max (sal) from emp ;</span><br><span class="line">找出最低工资?</span><br><span class="line">select min (sal) from emp ;</span><br><span class="line">找出平均工资?</span><br><span class="line">select avg ( sal) from emp;</span><br><span class="line">找出总人数?</span><br><span class="line">select count (*) from emp;</span><br><span class="line">select count (ename) from emp ;</span><br></pre></td></tr></table></figure><p><strong>分组函数一共5个。</strong><br><strong>分组函数还有另一个名字:多行处理函数。</strong><br><strong>多行处理函数的特点:输入多行,最终输出的结果是1行。</strong></p><p><strong>分组函数自动忽略NULL。</strong></p><p>select sum(comm) from emp where comm is not null;&#x2F;&#x2F;<strong>不需要额外添加这个过滤条件。sum函数自动忽略Null。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">找出工资高于平均工资的员工?</span><br><span class="line">select avg (sal) from emp; //平均工资</span><br><span class="line">+-------------+</span><br><span class="line">| avg (sal)   |</span><br><span class="line">+-------------+</span><br><span class="line">| 2073.214286 |</span><br><span class="line">+-------------+</span><br></pre></td></tr></table></figure><p>select ename ,sal from emp where sal &gt; avg(sal);&#x2F;&#x2F;ERROR 1111 (HY000): Invalid use of group function</p><p>思考以上的错误信息:无效的使用了分组函数?</p><p><strong>原因:SQL语句当中有一个语法规则，分组函数不可直接使用在where子句当中。why????</strong></p><p><strong>怎么解释?</strong><br>                <strong>因为group by是在where执行之后才会执行的。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">count(*)和count(具体的某个字段),他们有什么区别?</span><br><span class="line"></span><br><span class="line">count(*):不是统计某个字段中数据的个数，而是统计总记录条数。(和某个字段无关)</span><br><span class="line"></span><br><span class="line">count (comm):表示统计comm字段中不为NUIL的数据总数量。</span><br></pre></td></tr></table></figure><p>分组函数也能组合起来用:<br>select count(*) ,sum(sal) ,avg(sal) ,max(sal),min(sal) from emp;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----------+----------+-------------+----------+----------+</span><br><span class="line">| count(*) | sum(sal) | avg(sal)    | max(sal) | min(sal) |</span><br><span class="line">+----------+----------+-------------+----------+----------+</span><br><span class="line">|       14 | 29025.00 | 2073.214286 |  5000.00 |   800.00 |</span><br><span class="line">+----------+----------+-------------+----------+----------+</span><br></pre></td></tr></table></figure><h5 id="找出工资高于平均工资的员工"><a href="#找出工资高于平均工资的员工" class="headerlink" title="找出工资高于平均工资的员工?"></a>找出工资高于平均工资的员工?</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">第一步:找出平均工资</span><br><span class="line">select avg (sal)from emp;</span><br><span class="line">+-------------+</span><br><span class="line">| avg (sal)   |</span><br><span class="line">+-------------+</span><br><span class="line">| 2073.214286 |</span><br><span class="line">+-------------+</span><br><span class="line">第二步:找出高于平均工资的员工</span><br><span class="line">select ename ,sal from emp where sal &gt; 2073.214286;</span><br><span class="line">+-------+---------+</span><br><span class="line">| ename | sal     |</span><br><span class="line">+-------+---------+</span><br><span class="line">| JONES | 2975.00 |</span><br><span class="line">| BLAKE | 2850.00 |</span><br><span class="line">| CLARK | 2450.00 |</span><br><span class="line">| SCOTT | 3000.00 |</span><br><span class="line">| KING  | 5000.00 |</span><br><span class="line">| FORD  | 3000.00 |</span><br><span class="line">+-------+---------+</span><br><span class="line"></span><br><span class="line">select ename ,sal from emp where sal &gt; (select avg (sal)from emp);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="15、单行处理函数"><a href="#15、单行处理函数" class="headerlink" title="15、单行处理函数"></a>15、单行处理函数</h2><p>什么是单行处理函数?<br>输入一行,输出一行。</p><h5 id="计算每个员工的年薪"><a href="#计算每个员工的年薪" class="headerlink" title="计算每个员工的年薪?"></a>计算每个员工的年薪?</h5><p>select ename , (800+NULL)*12 as yearsal from emp;</p><p><strong>重点:所有数据库都是这样规定的，只要有NU参与的运算结果一定是NULL。</strong></p><p>使用ifnull函数:<br>select ename , (sal+ifnull(comm,0))*12 as yearsa1 from emp;</p><p>ifnull()空处理函数?<br>ifnull(可能为NUz的数据,被当做什么处理):属于单行处理函数。</p><p>select ename ,ifnull (comm,0) as comm from emp;</p><h2 id="16、group-by-和-having"><a href="#16、group-by-和-having" class="headerlink" title="16、group by 和 having"></a>16、group by 和 having</h2><p>group by :按照某个字段或者某些字段进行分组。</p><p>having : having是对分组之后的数据进行再次过滤。</p><h5 id="案例-找出每个工作岗位的最高薪资。"><a href="#案例-找出每个工作岗位的最高薪资。" class="headerlink" title="案例:找出每个工作岗位的最高薪资。"></a>案例:找出每个工作岗位的最高薪资。</h5><p>select max(sal), job from emp group by job;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+----------+-----------+</span><br><span class="line">| max(sal) | job       |</span><br><span class="line">+----------+-----------+</span><br><span class="line">|  1300.00 | CLERK     |</span><br><span class="line">|  1600.00 | SALESMAN  |</span><br><span class="line">|  2975.00 | MANAGER   |</span><br><span class="line">|  3000.00 | ANALYST   |</span><br><span class="line">|  5000.00 | PRESIDENT |</span><br><span class="line">+----------+-----------+</span><br></pre></td></tr></table></figure><p><strong>注意:分组函数一般都会和group by联合使用，这也是为什么它被称为分组函数的原因。</strong><br><strong>并且任何一个分组函数(count sum avg max min）都是在group by语句执行结束之后才会执行的。</strong></p><p><strong>当一条sql语句没有group by的话,整张表的数据会自成一组。</strong></p><p>select ename ,max(sal) ,job from emp group by job;<br>以上在mysql当中，查询结果是有的，但是结果没有意义，在oracle数据库当中会报错。语法错误。oracle的语法规则比MysQL语法规则严谨。<br><strong>记住一个规则:当一条语句中有group by的话，select后面只能跟分组函数和参与分组的字段。</strong></p><h5 id="每个工作岗位的平均薪资"><a href="#每个工作岗位的平均薪资" class="headerlink" title="每个工作岗位的平均薪资?"></a>每个工作岗位的平均薪资?</h5><p>select job,avg(sal) from emp group by job;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+-----------+-------------+</span><br><span class="line">| job       | avg (sal)   |</span><br><span class="line">+-----------+-------------+</span><br><span class="line">| CLERK     | 1037.500000 |</span><br><span class="line">| SALESMAN  | 1400.000000 |</span><br><span class="line">| MANAGER   | 2758.333333 |</span><br><span class="line">| ANALYST   | 3000.000000 |</span><br><span class="line">| PRESIDENT | 5000.000000 |</span><br><span class="line">+-----------+-------------+</span><br></pre></td></tr></table></figure><h5 id="多个字段能不能联合起来一块分组"><a href="#多个字段能不能联合起来一块分组" class="headerlink" title="多个字段能不能联合起来一块分组?"></a>多个字段能不能联合起来一块分组?</h5><p>案例:找出每个部门不同工作岗位的最高薪资。</p><p>select<br>    deptno ,job ,max (sal)</p><p>from<br>    emp</p><p>group by<br>    deptno ,job;</p><h5 id="找出每个部门的最高薪资-要求显示薪资大于2500的数据。"><a href="#找出每个部门的最高薪资-要求显示薪资大于2500的数据。" class="headerlink" title="找出每个部门的最高薪资,要求显示薪资大于2500的数据。"></a>找出每个部门的最高薪资,要求显示薪资大于2500的数据。</h5><p>第一步:找出每个部门的最高薪资</p><p>select max(sal) ,deptno from emp group by deptno;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+----------+--------+</span><br><span class="line">| max(sal) | deptno |</span><br><span class="line">+----------+--------+</span><br><span class="line">|  3000.00 |     20 |</span><br><span class="line">|  2850.00 |     30 |</span><br><span class="line">|  5000.00 |     10 |</span><br><span class="line">+----------+--------+</span><br></pre></td></tr></table></figure><p>第二步:找出薪资大于290o</p><p>select max(sal) ,deptno from emp group by deptno having max(sal)&gt;2900;<strong>&#x2F;&#x2F;这种方式效率低。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----------+--------+</span><br><span class="line">| max(sal) | deptno |</span><br><span class="line">+----------+--------+</span><br><span class="line">|  3000.00 |     20 |</span><br><span class="line">|  5000.00 |     10 |</span><br><span class="line">+----------+--------+</span><br></pre></td></tr></table></figure><p>select max(sal) ,deptno from emp where sal &gt;2900 group by deptno;<strong>&#x2F;&#x2F;效率较高，建议能够使用where过滤的尽量使用where.</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----------+--------+</span><br><span class="line">| max(sal) | deptno |</span><br><span class="line">+----------+--------+</span><br><span class="line">|  3000.00 |     20 |</span><br><span class="line">|  5000.00 |     10 |</span><br><span class="line">+----------+--------+</span><br></pre></td></tr></table></figure><h5 id="找出每个部门的平均薪资，要求显示薪资大于2000的数据。"><a href="#找出每个部门的平均薪资，要求显示薪资大于2000的数据。" class="headerlink" title="找出每个部门的平均薪资，要求显示薪资大于2000的数据。"></a>找出每个部门的平均薪资，要求显示薪资大于2000的数据。</h5><p>第一步:找出每个部门的平均薪资<br>select deptno ,avg (sal) from emp group by deptno;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+--------+-------------+</span><br><span class="line">| deptno | avg (sal)   |</span><br><span class="line">+--------+-------------+</span><br><span class="line">|     20 | 2175.000000 |</span><br><span class="line">|     30 | 1566.666667 |</span><br><span class="line">|     10 | 2916.666667 |</span><br><span class="line">+--------+-------------+</span><br></pre></td></tr></table></figure><p>第二步:要求显示薪资大于2000的数据<br>select deptno ,avg(sal) from emp group by deptno having avg(sal)&gt; 2000;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+--------+-------------+</span><br><span class="line">| deptno | avg(sal)    |</span><br><span class="line">+--------+-------------+</span><br><span class="line">|     20 | 2175.000000 |</span><br><span class="line">|     10 | 2916.666667 |</span><br><span class="line">+--------+-------------+</span><br></pre></td></tr></table></figure><h2 id="17、总结一个完整的DQ语句怎么写"><a href="#17、总结一个完整的DQ语句怎么写" class="headerlink" title="17、总结一个完整的DQ语句怎么写?"></a>17、总结一个完整的DQ语句怎么写?</h2><p>select5</p><p>…</p><p>from1</p><p>…</p><p>where2</p><p>…</p><p>group by3</p><p>….</p><p>having4<br>…<br>order by6</p><p>…</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC</title>
      <link href="/2022/10/26/JDBC/"/>
      <url>/2022/10/26/JDBC/</url>
      
        <content type="html"><![CDATA[<h2 id="1、JDBC是什么"><a href="#1、JDBC是什么" class="headerlink" title="1、JDBC是什么?"></a>1、JDBC是什么?</h2><p>Java DataBase Connectivity (Java语言连接数据库)</p><h2 id="2、JDBC的本质是什么"><a href="#2、JDBC的本质是什么" class="headerlink" title="2、JDBC的本质是什么?"></a>2、JDBC的本质是什么?</h2><p>JDBC是SUN公司制定的一套接口(interface)<br>java. sql.*;(这个软件包下有很多接口。)<br>接口都有调用者和实现者。<br>面向接口调用、面向接口写实现类，这都属于面向接口编程。<br>为什么要面向接口编程?<br>解耦合:降低程序的耦合度,提高程序的扩展力。<br>多态机制就是非常典型的:面向抽象编程。(不要面向具体编程)<br>建议:<br>Animal a &#x3D; new cat;</p><p>Animal a &#x3D;new Dog;&#x2F;&#x2F;喂养的方法<br>public void feed (Animal a){&#x2F;&#x2F;面向父类型编程。</p><p>}</p><p>不建议:</p><p>Dog d &#x3D; new Dog () ;</p><p>cat c &#x3D;new cat();</p><p>public void feed (Dog a){&#x2F;&#x2F;只能喂养Dog</p><p>}</p><p>public void feed (Cat a){&#x2F;&#x2F;只能喂养猫。</p><p>}</p><h2 id="思考-为什么SUN制定一套JDBC接口呢"><a href="#思考-为什么SUN制定一套JDBC接口呢" class="headerlink" title="思考:为什么SUN制定一套JDBC接口呢?"></a><strong>思考:为什么SUN制定一套JDBC接口呢?</strong></h2><p>因为每一个数据库的底层实现原理都不一样。oracle数据库有自己的原理。<br>MySQL数据库也有自己的原理。<br>MS sqlServer数据库也有自己的原理。</p><p>….</p><p>每一个数据库产品都有自己独特的实现原理。</p><p><strong>JDBC的本质到底是什么?</strong><br>一套接口。</p><h2 id="3、JDBC开发前的准备工作，"><a href="#3、JDBC开发前的准备工作，" class="headerlink" title="3、JDBC开发前的准备工作，"></a>3、JDBC开发前的准备工作，</h2><p>先从官网下载对应的驱动jar包，然后将其配置到环境变量classpath当中。<br>classpath&#x3D;**. ;**D: \course\06-DBC\resources\Mysql connector Java 5.1.23\mysql-connector-java-5.1.23-bin. jar<br>以上的配置是针对于文本编辑器的方式开发，使用IDEA工具的时候,<br>不需要配置以上的环境变量。<br><strong>IDEA有自己的配置方式。</strong></p><p><img src="/2022/10/26/JDBC/1.png" alt="image-20221021082214186"></p><h2 id="为什么各大数据库厂家为什么这么听话（你懂的）"><a href="#为什么各大数据库厂家为什么这么听话（你懂的）" class="headerlink" title="为什么各大数据库厂家为什么这么听话（你懂的）"></a>为什么各大数据库厂家为什么这么听话（你懂的）</h2><p>为什么各大数据库厂家为什么这么听话，乖乖的实现sun提供的接口</p><p>我们不需要关心你是哪个品牌的数据库</p><p>就像电脑的硬盘，不用关心你是金士顿还是其他的，只要接口一样，难道我电脑主板只能用金士顿吗？</p><h5 id="SUN"><a href="#SUN" class="headerlink" title="SUN"></a>SUN</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">SUN公司负责制定这套JDBC接口。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">JDBC</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    连接数据库的方法。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">getconnection</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h5><p>&#x2F;&#x2F;实现类被称为驱动。(mysql驱动)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MysQL的数据库厂家负责编写JDBC接口的实现类</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MysQimplements</span> JDBC&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getconnection</span> <span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//具体这里的代码怎么写，对于我们Java程序员来说没关系</span></span><br><span class="line">    <span class="comment">//这段代码涉及到mysq1底层数据库的实现原理。</span></span><br><span class="line">System.out.println(<span class="string">&quot;连接MYsQL数据库成功!&quot;</span>) ;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h5 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">oracle的数据库厂家负责编写JDBC接口的实现类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">oracle</span> <span class="keyword">implements</span> <span class="title class_">JDBC</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getconnection</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println (<span class="string">&quot;连接oracle数据库成功! &quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="程序员"><a href="#程序员" class="headerlink" title="程序员"></a>程序员</h5><p>&#x2F;*<br>Java程序员角色。<br>不需要关心具体是哪个品牌的数据库，只需要面向JDBC接口写代码。<strong>面向接口编程,面向抽象编程,不要面向具体编程。</strong><br>*&#x2F;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import java.util.* ;</span><br><span class="line">public class JavaProgrammer &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // JDBC jdbc = new MysQL() ;</span><br><span class="line">        // JDBC jdbc = new sqlserver() ;</span><br><span class="line"></span><br><span class="line">        // 创建对象可以通过反射机制。</span><br><span class="line">        ResourceBundle bundle = ResourceBundle.getBundle(&quot;jdbc&quot;); //资源绑定器，只能对properties文件</span><br><span class="line">        String className = bundle.getString(&quot;className &quot;);</span><br><span class="line">        Class c = Class.forName(className);</span><br><span class="line">        JDBC jdbc = (JDBC) c.newInstance();</span><br><span class="line">        //以下代码都是面向接口调用方法,不需要修改</span><br><span class="line">        jdbc.getconnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">className</span>=<span class="string">MySQL</span></span><br></pre></td></tr></table></figure><h2 id="4、JDBC编程六步（需要背会"><a href="#4、JDBC编程六步（需要背会" class="headerlink" title="4、JDBC编程六步（需要背会)"></a>4、<strong>JDBC编程六步（需要背会)</strong></h2><p>第一步:注册驱动（<strong>作用:告诉Java程序，即将要连接的是哪个品牌的数据库)</strong></p><p>第二步:获取连接（表示JVM的进程和数据库进程之间的通道打开了，这属于进程之间的通信，重量级的，使用完之后一定要关闭通道</p><p>第三步:获取数据库操作对象（(专门执行sql语句的对象)</p><p>第四步:执行SQL语句(DQLDML. . ..)</p><p>第五步:处理查询结果集（<strong>只有当第四步执行的是select语句的时候，才有这第五步处理查询结果集</strong>。)</p><p>第六步:释放资源（<strong>使用完资源之后一定要关闭资源。Java和数据库属于进程间的通信，开启之后一定要关闭</strong>。)</p><h5 id="url"><a href="#url" class="headerlink" title="url"></a>url</h5><ul><li>ur1:统一资源定位符（网络中某个资源的绝对路径)</li><li>https: &#x2F;&#x2F;<a href="http://www.baidu/">www.baidu</a> . com&#x2F;这就是URL</li><li>URI包括哪几部分?<ul><li>协议</li><li>IP</li><li>PORT</li><li>资源名</li></ul></li><li><a href="http://182.61.200.7/index.html">http://182.61.200.7:80/index.html</a><ul><li>http:&#x2F;&#x2F;通信协议</li><li>182.61.200.7服务器IP地址</li><li>80服务器上软件的端口</li><li>index.html是服务器上某个资源名</li></ul></li><li>jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;bjpowernode<ul><li>jdbc:mysql:&#x2F;&#x2F;协议</li><li>127.0.0.1 工P地址</li><li>3306 mysql数据库端口号</li><li>bjpowernode具体的数据库实例名。</li><li>说明: localhost和127.0.0.1都是本机ip地址。</li></ul></li></ul><p>什么是通信协议,有什么用?<br>通信协议是通信之前就提前定好的数据传送格式。数据包具体怎么传数据,格式提前定好的。</p><h5 id="编程6步"><a href="#编程6步" class="headerlink" title="编程6步"></a>编程6步</h5><p>&#x2F;&#x2F;专门执行DML如语句的(insert delete update)<br>            &#x2F;&#x2F;返回值是”影响数据库中的记录条数”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCtest01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1、注册驱动</span></span><br><span class="line">            <span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.mysql.jdbc.Driver(); <span class="comment">//多态，父类型引用指向子类型对象。</span></span><br><span class="line">            DriverManager.registerDriver(driver);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2、获取连接</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://127.0.0.1:3306/bjpowernode&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;333&quot;</span>;</span><br><span class="line">            conn = DriverManager.getConnection(url, user, password);</span><br><span class="line">            <span class="comment">//com.mysql.jdbc.JDBC4Connection41cf53f9</span></span><br><span class="line">            System.out.println(<span class="string">&quot;数据库连接对象= &quot;</span> + conn);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3、获取数据库操作对象(statement专门执行sql语句的)</span></span><br><span class="line">            stmt = conn.createStatement();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4、执行sql</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into dept (deptno, dname,loc) values(50, &#x27;人事部&#x27;,&#x27;北京&#x27;)&quot;</span> ;</span><br><span class="line">            <span class="comment">//专门执行DML如语句的(insert delete update)</span></span><br><span class="line">            <span class="comment">//返回值是&quot;影响数据库中的记录条数&quot;</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> stmt.executeUpdate(sql);</span><br><span class="line">            System.out.println ((count==<span class="number">1</span>?<span class="string">&quot;保存成功&quot;</span>:<span class="string">&quot;保存失败&quot;</span>));</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//6、释放资源</span></span><br><span class="line">            <span class="comment">// 为了保证资源一定释放,在finally语句块中关闭资源1/并且要遵循从小到大依次关闭</span></span><br><span class="line">            <span class="comment">//分别对其try . .catch</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (stmt != <span class="literal">null</span>) &#123;</span><br><span class="line">                    stmt.close () ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace () ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">                    conn. close () ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace () ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、类加载的方式注册驱动（常用）"><a href="#5、类加载的方式注册驱动（常用）" class="headerlink" title="5、类加载的方式注册驱动（常用）"></a>5、类加载的方式注册驱动（常用）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为什么这种方式常用﹖因为参数是一个字符串，字符串可以写到xxx.properties文件中。</span></span><br><span class="line"><span class="comment">// 以下方法不需要接收返回值，因为我们只想用它的类加载动作。</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    直接new也可以啊</span></span><br><span class="line"><span class="comment">    注册驱动的另一种方式(这种方式常用)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String [] args)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//1、注册驱动</span></span><br><span class="line">                <span class="comment">//这是注册驱动的第一种写法。</span></span><br><span class="line">                <span class="comment">// DriverManager.registerDriver(new com.mysql.jdbc.Driver() ) ;</span></span><br><span class="line">                <span class="comment">// 注册驱动的第二种方式:常用的。</span></span><br><span class="line">                <span class="comment">//为什么这种方式常用﹖因为参数是一个字符串，字符串可以写到xxx.properties文件中。</span></span><br><span class="line">                <span class="comment">// 以下方法不需要接收返回值，因为我们只想用它的类加载动作。</span></span><br><span class="line"></span><br><span class="line">                Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>)</span><br><span class="line">                <span class="comment">//2、获取连接</span></span><br><span class="line">                <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot; jdbc:mysq1://localhost:3306/bjpowernode&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line">                <span class="comment">//com.mysql .jdbc.JDBC4Connection@ 41cf53f9</span></span><br><span class="line">                System.out.println(conn);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="6、从属性文件中读取连接数据库信息"><a href="#6、从属性文件中读取连接数据库信息" class="headerlink" title="6、从属性文件中读取连接数据库信息"></a>6、从属性文件中读取连接数据库信息</h2><h5 id="properties-1"><a href="#properties-1" class="headerlink" title="properties"></a>properties</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driver</span>=<span class="string">com. mysql. jdbc. Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:nysql:/ /192.168.151.9:3306/bjpowernode</span></span><br><span class="line"><span class="attr">user</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">981127</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="JDBCtest04"><a href="#JDBCtest04" class="headerlink" title="JDBCtest04"></a>JDBCtest04</h5><p>&#x2F;&#x2F;将连接数据库的所有信息配置到配置文件中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ResourceBundle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCtest04</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用资源绑定器绑定属性配置文件</span></span><br><span class="line">        <span class="type">ResourceBundle</span> <span class="variable">bundle</span> <span class="operator">=</span> ResourceBundle.getBundle(<span class="string">&quot;jdbe&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">driver</span> <span class="operator">=</span> bundle.getString(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> bundle.getString(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> bundle.getString(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> bundle.getString(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//注册驱动</span></span><br><span class="line">            Class.forName(driver);</span><br><span class="line">            <span class="comment">// 2、获取连接</span></span><br><span class="line">            conn = DriverManager.getConnection(<span class="string">&quot; jdbc:mysql://localhost:3306/bjpowernode&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;n333 &quot;</span>);</span><br><span class="line">            <span class="comment">//3、获取数据库操作对象</span></span><br><span class="line">            stmt = conn.createStatement();</span><br><span class="line">            <span class="comment">// 4、执行SQL语句</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update dept set dname = &#x27;销售部&#x27;,loc = &#x27;天津&#x27; where deptno = 20 &quot;</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> stmt.executeUpdate(sql);</span><br><span class="line">            System.out.println(count == <span class="number">1</span> ? <span class="string">&quot;删除成功&quot;</span> : <span class="string">&quot;删除失败&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (stmt != <span class="literal">null</span>) &#123;</span><br><span class="line">                    stmt.close () ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace () ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">                    conn. close () ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace () ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7、处理查询结果集"><a href="#7、处理查询结果集" class="headerlink" title="7、处理查询结果集"></a>7、处理查询结果集</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">重点注意:列名称不是表中的列名称，是查询结果集的列名称。</span><br><span class="line"> //这个不是以列的下标获取,以列的名字获取</span><br><span class="line"> //getstring()方法的特点是:不管数据库中的数据类型是什么，都以string的形式取出。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCtest05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//注册驱动</span></span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.driver&quot;</span>);</span><br><span class="line">            <span class="comment">// 2、获取连接</span></span><br><span class="line">            conn = DriverManager.getConnection(<span class="string">&quot; jdbc:mysql://localhost:3306/bjpowernode&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;n333 &quot;</span>);</span><br><span class="line">            <span class="comment">//3、获取数据库操作对象</span></span><br><span class="line">            stmt = conn.createStatement();</span><br><span class="line">            <span class="comment">// 4、执行SQL语句</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//String sql = &quot;select empno , ename , sal from emp&quot;;</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select empno as a , ename , sal from emp&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//int executeUpdate(insert/ delete/update)ll</span></span><br><span class="line">            <span class="comment">//ResultSet executeQuery (select)</span></span><br><span class="line">            rs = stmt.executeQuery(sql); <span class="comment">//专门执行Dgr语句的方法。</span></span><br><span class="line">            <span class="comment">// 5、处理查询结果集</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            boolean flag1 = rs.next();</span></span><br><span class="line"><span class="comment">            //System.out.println(flag1) ; // true</span></span><br><span class="line"><span class="comment">            if (flag1) &#123;</span></span><br><span class="line"><span class="comment">                //光标指向的行有数据</span></span><br><span class="line"><span class="comment">                // 取数据</span></span><br><span class="line"><span class="comment">                //getstring()方法的特点是:不管数据库中的数据类型是什么，都以string的形式取出。</span></span><br><span class="line"><span class="comment">                String empno = rs.getString(1);//JDBC中所有下标从1开始。不是从0开始。</span></span><br><span class="line"><span class="comment">                String ename = rs.getString(2);</span></span><br><span class="line"><span class="comment">                String sal = rs.getString(3);</span></span><br><span class="line"><span class="comment">                System.out.println(empno + &quot; , &quot; + ename + &quot; , &quot; + sal);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            flag1 = rs.next();</span></span><br><span class="line"><span class="comment">            if (flag1) &#123;</span></span><br><span class="line"><span class="comment">                //以下程序的1 2 3说的第几列。</span></span><br><span class="line"><span class="comment">                String empno = rs.getString(1);</span></span><br><span class="line"><span class="comment">                String ename = rs.getString(2);</span></span><br><span class="line"><span class="comment">                String sal = rs.getString(3);</span></span><br><span class="line"><span class="comment">                System.out.println(empno + &quot;, &quot; + ename + &quot;,&quot; + sal);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                String empno = rs.getString(1) ;</span></span><br><span class="line"><span class="comment">                String ename = rs.getString (2);</span></span><br><span class="line"><span class="comment">                String sal = rs.getString (3) ;</span></span><br><span class="line"><span class="comment">                System.out.println (empno + &quot;,&quot; + ename + &quot;,&quot; + sal);</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//这个不是以列的下标获取,以列的名字获取</span></span><br><span class="line">                <span class="comment">// String empno = rs.getString(&quot;empnd&quot;);</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                String empno = rs.getString(&quot;a&quot;); //重点注意:列名称不是表中的列名称，是查询结果集的列名称。</span></span><br><span class="line"><span class="comment">                String ename = rs.getString(&quot;ename&quot;);</span></span><br><span class="line"><span class="comment">                String sal = rs.getString(&quot;sal&quot;);</span></span><br><span class="line"><span class="comment">                System.out.println(empno + &quot; , &quot; + ename + &quot;, &quot; + sal);</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//除了可以以string类型取出之外，还可以以特定的类型取出。</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                int empno = rs.getInt(1);</span></span><br><span class="line"><span class="comment">                String ename = rs.getString (2);</span></span><br><span class="line"><span class="comment">                double sal = rs.getDouble (3) ;</span></span><br><span class="line"><span class="comment">                System.out.printin (empno + &quot; , &quot; + ename + &quot; , &quot; + (sal + 100)) ;</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//这个不是以列的下标获取,以列的名字获取</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">empno</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">ename</span> <span class="operator">=</span> rs.getString (<span class="string">&quot;ename&quot;</span>);</span><br><span class="line">                <span class="type">double</span> <span class="variable">sal</span> <span class="operator">=</span> rs.getDouble (<span class="string">&quot;sal&quot;</span>) ;</span><br><span class="line">                System.out.println (empno + <span class="string">&quot; , &quot;</span> + ename + <span class="string">&quot; , &quot;</span> + (sal + <span class="number">100</span>)); ;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rs != <span class="literal">null</span>) &#123;</span><br><span class="line">                    rs.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (stmt != <span class="literal">null</span>) &#123;</span><br><span class="line">                    stmt.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">                    conn.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8、使用idea开发JDBC代码配置驱动"><a href="#8、使用idea开发JDBC代码配置驱动" class="headerlink" title="8、使用idea开发JDBC代码配置驱动"></a>8、使用idea开发JDBC代码配置驱动</h2><p>注意</p><ul><li><p><strong>就像是该死的编辑器要设置classPath一样，idea有自己的设置</strong></p></li><li><p><strong>选择java</strong></p></li><li><p>选择模块</p></li><li><p>不设置的话就像不设置classPath一样，<strong>找不到该类</strong></p></li><li><p><strong>新增模块需要重新添加</strong></p></li></ul><p><img src="/2022/10/26/JDBC/2.png" alt="image-20221021132648838"></p><p><img src="/2022/10/26/JDBC/3.png" alt="image-20221021133221292"></p><h2 id="9、powerDesigner"><a href="#9、powerDesigner" class="headerlink" title="9、powerDesigner"></a>9、powerDesigner</h2><p><img src="/2022/10/26/JDBC/4.png" alt="image-20221021161542229"></p><p><img src="/2022/10/26/JDBC/5.png" alt="image-20221021161645756"></p><p><img src="/2022/10/26/JDBC/6.png" alt="image-20221021161806516"></p><h2 id="10、SQL注入案例"><a href="#10、SQL注入案例" class="headerlink" title="10、SQL注入案例"></a>10、SQL注入案例</h2><p>简单登录</p><p>sql语句的框子。其中一个2，表示一个占位符，一个?将来接收一个”值”，注意:占位符不能使用单引号括起来。<br>给占位符?传值(第1个问号下标是1，第2个问号下标是2     JDBC中所有下标从1开始。)</p><p>&#x2F;*<br>    1、需求<br>        模拟用户登录功能的实现。<br>    2、业务描述:<br>        程序运行的时候，提供一个输入的入口，可以让用户输入用户名和密码<br>        用户输入用户名和密码之后，提交信息，<br>        java程序收集到用户信息Java程序连接数据库验证用户名和密码是否合法<br>        合法:显示登录成功<br>        不合法:显示登录失败<br>    3、数据的准备:<br>        在实际开发中，表的设计会使用专业的建模工具，我们这里安装一个建模工具:PowerDesigner<br>        使用PD工具来进行数据库表的设计。（参见user-login.sql脚本)<br>    4、当前程序存在的问题:<br>        用户名:fdsa<br>        密码:fdsa’ or’ 1’&#x3D;’ 1登录成功<br>        这种现象被称为sQL注入(安全隐患)。（黑客经常使用)<br>    5、导致sQL注入的根本原因是什么?<br>    用户输入的信息中含有sql语句的关键字，并且这些关键字参与sql语句的编译过程，<br>    导致sql语句的原意被扭曲，进而达到sql注入。</p><p>*&#x2F;</p><p>1、解决sql注入间题?<br>只要用户提供的信息不参与SQL语句的编译过程，问题就解决了。<br>即使用户提供的信息中含有SQL语句的关键字，但是没有参与编译，不起作用。<br>要想用户信息不参与sgz语句的编译，那么必须使用java.sql. PreparedStatement，</p><p>Preparedstatement接口继承了java.sql.statement<br>Preparedstatement是属于预编译的数据库操作对象。<br>Preparedstatement的原理是:预先对sgz语句的框架进行编译，然后再给sgz语句传值”。</p><p>2、测试结果:<br>用户名:fdas<br>密码:fdsa’ or ‘1’&#x3D;’1登录失败</p><p>3、解决sr注入的关键是什么?<br>用户提供的信息中即使含有sql语句的关键字，但是这些关键字并没有参与编译。不起作用。</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCtest06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//初始化一个界面</span></span><br><span class="line">        Map&lt;String, String&gt; userLoginInfo = initUI();<span class="comment">//验证用户名和密码</span></span><br><span class="line">        <span class="comment">//验证用户名和密码</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">loginSuccess</span> <span class="operator">=</span> login(userLoginInfo);<span class="comment">//最后输出结果</span></span><br><span class="line">        System.out.println(loginSuccess ? <span class="string">&quot;登录成功&quot;</span> : <span class="string">&quot;登录失败&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户登录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userLoginInfo 用户登录信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> fales表示失败，true表示成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">login</span><span class="params">(Map&lt;String, String&gt; userLoginInfo)</span> &#123;</span><br><span class="line">        <span class="comment">//打标记的意识</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">loginSuccess</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//单独定义变量</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">loginName</span> <span class="operator">=</span> userLoginInfo.get (<span class="string">&quot;loginName&quot;</span>) ;</span><br><span class="line">        <span class="type">String</span> <span class="variable">loginPwd</span> <span class="operator">=</span> userLoginInfo.get ( <span class="string">&quot;loginPwd&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//JDBC代码</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        Statement stmt = null;</span></span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//这里使用PreparedStatement（预编译的数据库操作对象）</span></span><br><span class="line"></span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1、注册驱动</span></span><br><span class="line">            Class.forName(<span class="string">&quot; com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">            <span class="comment">// 2、获取连接</span></span><br><span class="line">            conn = DriverManager.getConnection(<span class="string">&quot; jdbc:mysql://localhost:3306/bjpowernode&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;n333 &quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3、获取数据库操作对象</span></span><br><span class="line"><span class="comment">//            stmt = conn.createStatement();</span></span><br><span class="line">            <span class="comment">//sql语句的框子。其中一个2，表示一个占位符，一个?将来接收一个&quot;值”，注意:占位符不能使用单引号括起来。</span></span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from t_user where loginName = ? and loginPwd = ?&quot;</span>;</span><br><span class="line">            ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//给占位符?传值(第1个问号下标是1，第2个问号下标是2     JDBC中所有下标从1开始。)</span></span><br><span class="line">            ps.setString(<span class="number">1</span>,loginName);</span><br><span class="line">            ps.setString(<span class="number">2</span>,loginPwd);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4、执行sql</span></span><br><span class="line">           <span class="comment">// rs=stmt.executeQuery();</span></span><br><span class="line">            rs = ps.executeQuery();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//改成上面</span></span><br><span class="line">            <span class="comment">//String sql = &quot;select * from t_user where loginName = &#x27;&quot;+loginName+&quot;&#x27; and loginPwd = &#x27;&quot;+loginPwd+&quot;&#x27;&quot;;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5、处理结果集</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(rs.next()) &#123;</span><br><span class="line">                <span class="comment">//登录成功</span></span><br><span class="line">                loginSuccess = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放资源</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rs != <span class="literal">null</span>) &#123;</span><br><span class="line">                    rs.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (stmt != <span class="literal">null</span>) &#123;</span><br><span class="line">                    stmt.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">                    conn.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> loginSuccess;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化用户界面</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 用户输入的用户名和密码等信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, String&gt; <span class="title function_">initUI</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;用户名:&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">loginName</span> <span class="operator">=</span> s.nextLine();</span><br><span class="line">        System.out.print(<span class="string">&quot;密码:&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">loginPwd</span> <span class="operator">=</span> s.nextLine();</span><br><span class="line">        Map&lt;String, String&gt; userLoginInfo = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        userLoginInfo.put(<span class="string">&quot;loginName&quot;</span>, loginName);</span><br><span class="line">        userLoginInfo.put(<span class="string">&quot;loginPwd&quot;</span>, loginPwd);</span><br><span class="line">        <span class="keyword">return</span> userLoginInfo;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11、JDBC事务自动提交"><a href="#11、JDBC事务自动提交" class="headerlink" title="11、JDBC事务自动提交"></a>11、JDBC事务自动提交</h2><p>JDBc事务机制:<br>1、UDBc中的事务是自动提交的,什么是自动提交?<br>只要执行任意一条DMrz语句，则自动提交一次。这是JDBc默认的事务行为。但是在实际的业务当中，通常都是N亲DINr语句共同联合才能完成的，必须保证他们这些DML语句在同一个事务中同时成功或者同时失败。<br>2、JDBC中只要执行任意一条DML语句，就提交一次。</p><h2 id="12、JDBC工具类的封装"><a href="#12、JDBC工具类的封装" class="headerlink" title="12、JDBC工具类的封装"></a>12、JDBC工具类的封装</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DBUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工具类中的构造方法都是私有的。</span></span><br><span class="line"><span class="comment">     * 因为工具类当中的方法都是静态的，不需要new对象，直接采用类名调用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">DBUtil</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态代码块在类加载时执行，并且只执行一次。</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot; com. mysql.jdbc. Driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取数据库连接对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>连接对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql ://localhost:3306/bjpowernode&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;333&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭资源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> conn  连接对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ps    数据库操作对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rs    结果集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(Connection conn, Statement ps, ResultSet rs)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (rs != <span class="literal">null</span>) &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ps != <span class="literal">null</span>) &#123;</span><br><span class="line">                ps.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13、行级锁"><a href="#13、行级锁" class="headerlink" title="13、行级锁"></a>13、行级锁</h2><p>select ename , job , sal from emp where job&#x3D; “<strong>MANAGER</strong>“ <strong>for update</strong>;</p>]]></content>
      
      
      
        <tags>
            
            <tag> JDBC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>juc(1)</title>
      <link href="/2022/10/26/juc-1/"/>
      <url>/2022/10/26/juc-1/</url>
      
        <content type="html"><![CDATA[<p>用户线程</p><p>守护线程</p><p><strong>用户线程相互独立</strong>，如：主线程结束后，其他用户线程还能继续执行</p><h2 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h2><p>异步任务</p><p>——–<strong>Future接口可以为主线程开一个分支任务，专门为主线程处理耗时和费力的复杂业务。</strong></p><p>比如，再烧水的同时，可以看电视，<strong>充分利用时间，</strong>一心二用，相当于开了一个分支任务；</p><p>目的：<strong>异步多线程任务执行且返回有结果</strong>，<strong>三个特点:多线程&#x2F;有返回&#x2F;异步任务</strong></p><p>(班长为老师去买水作为新启动的异步多线程任务且买到水有结果返回)</p><p>通过<strong>构造注入</strong>与callable和runable拉近关系</p><p><img src="/2022/10/26/juc-1/1.png" alt="image-20221015182652399"></p><p><strong>FutureTask</strong>实现Runnable，Future接口，即可以实现创建线程（Runnable），异步任务（Future），最后一个返回值，也通过构造注入callable接口实现，<strong>集Runnable，Future，callable三大势力与一身</strong></p><p>优点：</p><p><strong>future+线程池异步多线程任务配合，能显著提高程序的执行效率。</strong></p><p>缺点：</p><p>一旦调用get()方法求结果，如果<strong>计算没有完成容易导致程序阻塞,</strong></p><p>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException，InterruptedException，TimeoutException&#123;</span><br><span class="line">   FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;String&gt;( () -&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t -----come in&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">5</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;task over&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask,<span class="string">&quot;t1&quot;</span> );</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread( ).getName()+<span class="string">&quot;\t ----忙其它任务了&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// System.out.println(futureTask.get() );</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println(futureTask.get( 3,Timeunit.SECONDS));//不够优雅</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用轮询</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(futureTask.isDone()) &#123;</span><br><span class="line">                System.out.println(futureTask.get());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//暂停毫秒</span></span><br><span class="line">                <span class="keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep( <span class="number">500</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace();&#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;正在处理中，不要再催了，越催越慢，再催熄火&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解决：</p><p>1.使用System.out.println(futureTask.get( 3,Timeunit.SECONDS));,不管是否完成，都只等待3秒，抛出超时异常，可以用，但是</p><p><strong>不够优雅</strong></p><p>2.使用轮询解决；</p><p><strong>轮询的方式会耗费无谓的CPU资源，而且也不见得能及时地得到计算结果.如果想要异步获取结果,通常都会以轮询的方式去获取结果</strong><br><strong>尽量不要阻塞</strong></p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p><strong>Future对于结果的获取不是很友好，只能通过阻塞或轮询的方式得到任务的结果。</strong></p><h2 id="CompletableFuture接口"><a href="#CompletableFuture接口" class="headerlink" title="CompletableFuture接口"></a>CompletableFuture接口</h2><p>对于一些复杂的任务</p><ul><li>对于简单的业务场景使用Future完全OK，老铁，每毛病</li><li><strong>回调通知</strong></li><li>创建异步任务———–Future+线程池配合</li><li>多个任务前后依赖可以组合处理(水煮鱼)<ul><li>像是水煮鱼，得先买鱼，再买调料，才能煮鱼儿，煮鱼儿依赖前面的结果</li><li><strong>想将多个异步任务的计算结果组合起来，后一个异步任务的计算结果需要前一个异步任务的值</strong></li><li>将两个或多个异步计算合成一个异步计算，这几个异步计算互相独立，同时后面这个又依赖前一个处理的结果。</li></ul></li><li>对计算速度选最快—–当Future集合中某个任务最快结束时，返回结果，返回第一名处理结果。</li><li><strong>使用Future之前提供的那点API就囊中羞涩，处理起来不够优雅，</strong><br><strong>这时候还是让CompletableFuture以声明式的方式优雅的处理这些需求</strong></li><li>从i到i++，o(n_n)O哈哈~<br>Future能干的，CompletableFuture都能干</li></ul><p><img src="/2022/10/26/juc-1/2.png" alt="image-20221015190644004"></p><h4 id="CompletionStage"><a href="#CompletionStage" class="headerlink" title="CompletionStage"></a>CompletionStage</h4><p><strong>完成的步骤，分阶段的任务</strong></p><h4 id="核心的四个散态方法，来创建一个异步任务"><a href="#核心的四个散态方法，来创建一个异步任务" class="headerlink" title="核心的四个散态方法，来创建一个异步任务"></a>核心的四个散态方法，来创建一个异步任务</h4><p>—-两个构造方法来获得CompletableFuture对象:不推荐使用，</p><ul><li>completableruture ()</li><li>Creates a new incomplete CompletableFuture()</li></ul><p>—–核心的四个散态方法，来创建一个异步任务</p><ul><li>runAsync<strong>有返回值</strong><ul><li>public static CompletableFuture<Void> runAsync(Runnable runnable)<br>public static CompletableFuture<Void> runAsync(Runnable runnable,Executor executor)</Void></Void></li></ul></li><li>supplyAsync<strong>无返回值</strong><ul><li>public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier)<br>public static <U>CompletableFuture<U> supplyAsync(Supplier<U> supplierExecutor executor)</U></U></U></U></U></U></li></ul></li></ul><p>注意：</p><p>​没有指定Executor的方法，直接使用默认的**ForkJoinPool.commonPool()**作为它的线程池执行异步代码。</p><p>​<strong>如果指定线程池，则使用我们自定义的或者特别指定的线程池执行异步代码</strong></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span> <span class="keyword">throws</span> ExecutionException，InterruptedException&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool( <span class="number">3</span>); <span class="comment">//可以传入线程池</span></span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(() -&gt;&#123;</span><br><span class="line">            System.out.println( Thread.currentThread( ).getName( ));</span><br><span class="line">            <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(  <span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println( completableFuture.get()); <span class="comment">//输出为null</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; completableFuture2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println( Thread.currentThread( ).getName( ));</span><br><span class="line">            <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(  <span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;hello supplyAsync&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println( completableFuture2.get()); <span class="comment">//不在为nullhello supplyAsync</span></span><br><span class="line"></span><br><span class="line">        threadPool.shutdown( ) ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从Java8开始引入了CompletableFuture，它是Future的功能增强版，<strong>减少阻塞和轮询</strong><br><strong>可以传入回调对象</strong>，<strong>当异步任务完成或者发生异常时，自动调用回调对象的回调方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span> <span class="keyword">throws</span> ExecutionException，InterruptedException&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool( <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        </span><br><span class="line">        CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;----come in&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> ThreadLocalRandom.current( ).nextInt( <span class="number">10</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep( <span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printstackTrace();&#125;</span><br><span class="line">            System.out.println( <span class="string">&quot;-----1秒钟后出结果:&quot;</span> + result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">            <span class="keyword">if</span> (result &gt; <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>/<span class="number">0</span>; <span class="comment">//出异常</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,threadPool).whencomplete((v,e) -&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">                system.out.println(<span class="string">&quot;-----计算完成，更新系统updatevalue: &quot;</span>+v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).exceptionally(e -&gt; &#123;</span><br><span class="line">            e.printstackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;异常情况:&quot;</span>+ e.getcause()+ <span class="string">&quot; \t&quot;</span>+ e.getMessage());</span><br><span class="line">            <span class="keyword">return</span> nul1;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread( ) .getName() + <span class="string">&quot;线程先去忙其它任务&quot;</span>);</span><br><span class="line">        </span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    e.printstackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    threadPool.shutdown();<span class="comment">//使用完记得关闭线程池</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line">    <span class="comment">//主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:暂停3秒钟线程</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//try &#123; TimeUnit.SECONDS.sleep( 3); &#125; catch (InterruptedException e) &#123; e.printstackTrace();&#125;  //使用线程池</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="小案例"><a href="#小案例" class="headerlink" title="小案例"></a>小案例</h4><p>案例说明:电商比价需求，模拟如下情况:</p><p>1需求:<br>1.1同一款产品，同时搜索出同款产品在各大电商平台的售价;<br>1.2同一款产品，同时搜索出本产品在同一个电商平台下，各个入驻卖家售价是多少</p><p>2输出:出来结果希望是同款产品的在不同地方的价格清单列表，返回一个Llist<string></string></p><p>《mysql》in jd price is 88.05</p><p>《mysql》in dangdang price is 86.11</p><p>《mysql》in taobao price is 90.43</p><p>3技术要求<br>3.1西数式编程工3.2链式编程<br>3.3 Stream流式计算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">completableFutureMallDemo</span>&#123;</span><br><span class="line"><span class="keyword">static</span> List&lt;NetMall&gt; list = Arrays.asList(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NetMall</span>( <span class="string">&quot;jd&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NetMall</span>(  <span class="string">&quot;dangdang&quot;</span> ),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NetMall</span>(  <span class="string">&quot;taobao&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一家一家的搜索</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getPrice</span><span class="params">(List&lt;NetMall&gt; list,String productName)</span>&#123;</span><br><span class="line">        <span class="comment">//《mysqL》 in taobao price is 90.43</span></span><br><span class="line">        <span class="keyword">return</span> list</span><br><span class="line">                .stream()</span><br><span class="line">                .map( netMall -&gt;</span><br><span class="line">                        String.format(productName + <span class="string">&quot;in %s price is %.2f&quot;</span>,</span><br><span class="line">                                netMall.getNetMallName(),</span><br><span class="line">                                netMall.calcPrice(productName) ))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//你懂的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getPriceBycompletableFuture</span><span class="params">(List &lt;NetMall&gt; list,String productName)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> list.stream( ).</span><br><span class="line">                map( netMall -&gt; CompletableFuture</span><br><span class="line">                        .supplyAsync(() -&gt; String.format(productName + <span class="string">&quot;in %s price is %.2f&quot;</span>,                                                                         netMall.getNetMallName(),</span><br><span class="line">                                netMall.calcPrice(productName) )))</span><br><span class="line">                        .collect(Collectors.toList())</span><br><span class="line">                        .stream()</span><br><span class="line">                        .map(s -&gt;s.join())</span><br><span class="line">                        .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="comment">//一家一家搜//串行</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        List&lt;String&gt; list1 = getPrice(list,<span class="string">&quot;mysq1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String element : list1) &#123;</span><br><span class="line">            System.out.println(element);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;----costTime: &quot;</span>+(endTime - startTime)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//并行</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        List&lt;String&gt; list2 = getPriceBycompletableFuture(list,<span class="string">&quot;mysql1&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String element : list2) &#123;</span><br><span class="line">            System.out.println(element);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;----costTime: &quot;</span>+(endTime2 - startTime2)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//电商类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NetMall</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String netMallName;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">NetMall</span><span class="params">(String netMallName)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.netMallName = netMallName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getNetMallName</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> netMallName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calcPrice</span><span class="params">(String productName)</span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(  <span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            <span class="keyword">return</span> ThreadLocalRandom.current( ).nextDouble() * <span class="number">2</span> + productName. charAt(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><h5 id="1-获得结果和触发计算"><a href="#1-获得结果和触发计算" class="headerlink" title="1.获得结果和触发计算"></a>1.获得结果和触发计算</h5><ul><li>public T get()</li><li>public T get(long timeout,TimeUnit unit)</li><li>public T join() <ul><li><strong>与get()唯一区别是是否抛出异常</strong></li></ul></li><li>public T  getNow(T valuelfAbsent)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span>&#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep( <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> ( InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span> ;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//System.out.println( completableFuture.get());</span></span><br><span class="line">        <span class="comment">//System.out.println( completableFuture.get(2L, TimeUnit.SECONDS) );//</span></span><br><span class="line">        <span class="comment">//System.out.println( completableFuture.join( ) );</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//现在获得执行结果，若没有执行完则输出valuelfAbsent</span></span><br><span class="line">        System.out.println(completableFuture.getNow( <span class="string">&quot;xxx&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="2-对计算结果进行处理"><a href="#2-对计算结果进行处理" class="headerlink" title="2.对计算结果进行处理"></a>2.对计算结果进行处理</h5><ul><li>thenApply<ul><li>计算结果存在依赖关系，这两个线程串行化</li><li>异常：由于存在依赖关系(当前步错，不走下一步)，当前步骤有异常的话就叫停</li></ul></li><li>handle<ul><li>计算结果存在依赖关系，这两个线程串行化</li><li>异常：有异常也可以往下一步走，根据带的异常参数可以进一步处理</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    </span><br><span class="line">   <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        CompletableFuture.supplyAsync(() -&gt;&#123;</span><br><span class="line">            <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace();&#125;</span><br><span class="line">            System.out.println( <span class="string">&quot;111&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; ,threadPool).thenApply(f -&gt;&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//int i = 10/0; // 模拟异常</span></span><br><span class="line"></span><br><span class="line">            System.out.println( <span class="string">&quot;222&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> f + <span class="number">2</span>;</span><br><span class="line">        &#125;).thenApply(f -&gt;&#123;</span><br><span class="line">            System.out.println( <span class="string">&quot;333&quot;</span> );<span class="keyword">return</span> f + <span class="number">3</span>;</span><br><span class="line">        &#125;).whenComplete((v,e) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println( <span class="string">&quot;----计算结果:&quot;</span>+v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).exceptionally(e -&gt; &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread( ).getName( )+<span class="string">&quot;----主线程先去忙其它任务&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//主线程不要立刻结束，否则completableFuture默认使用的线程池会立刻关闭:</span></span><br><span class="line">        <span class="comment">//try &#123; TimeUnit.SECONDS.sleep( timeout 2); &#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">                   </span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="3-对计算结果进行消费"><a href="#3-对计算结果进行消费" class="headerlink" title="3.对计算结果进行消费"></a>3.对计算结果进行消费</h5><ul><li>接收任务的处理结果，<strong>并消费处理，无返回结果</strong></li><li>thenAccept(Consumer action)<ul><li>任务A执行完执行B，B需要A的结果，<strong>但是任务B无返回值</strong></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">                   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultA&quot;</span>).thenRun(() -&gt; &#123;&#125;).join()); <span class="comment">//null resultA</span></span><br><span class="line"></span><br><span class="line">System.out.println(CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultA&quot;</span>).thenAccept(r -&gt; System.out. println(r)).join());<span class="comment">// null</span></span><br><span class="line"></span><br><span class="line">System.out.println(CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultA&quot;</span>).thenApply(r -&gt; r + <span class="string">&quot; resultB&quot;</span>). join());<span class="comment">//resultAresultB</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="4-对计算速度进行选用"><a href="#4-对计算速度进行选用" class="headerlink" title="4.对计算速度进行选用"></a>4.对计算速度进行选用</h5><p>实际中很实用：<strong>谁快谁就是赢家</strong>，<strong>谁快用谁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        CompletableFuture&lt;String&gt; playA = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            System.out.println( <span class="string">&quot;A come in&quot;</span> );</span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep( <span class="number">2</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;playA&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        CompletableFuture&lt;String&gt; playB = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            System.out.println( <span class="string">&quot;B come in&quot;</span> );</span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep( <span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;playB&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; result = playA.applyToEither(playB, f -&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> f + <span class="string">&quot; is winer&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System. out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;-----: &quot;</span>+result.join());</span><br><span class="line">    &#125;                                                                         </span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="5-对计算结果进行合并"><a href="#5-对计算结果进行合并" class="headerlink" title="5.对计算结果进行合并"></a>5.对计算结果进行合并</h5><p>两个CompletionStage任务都完成后，<strong>最终能把两个任务的结果一起交给thenCombine来处理</strong></p><p><strong>先完成的先等着</strong>，<strong>等待其它分支任务</strong></p><p>then</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[ ] args)</span> &#123;</span><br><span class="line">        CompletableFuture&lt;Integer&gt; completableFuture1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread( ).getName() + <span class="string">&quot;It ---启动&quot;</span>);</span><br><span class="line">            <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep( <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> ( InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace( );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        CompletableFuture&lt;Integer&gt; completableFuture2 = CompletableFuture. supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println( Thread.currentThread( ).getName() + <span class="string">&quot;\t ---启动&quot;</span>);</span><br><span class="line">            <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(  <span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> ( InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Integer&gt; result = completableFuture1.thenCombine(completableFuture2,(x, y)-&gt; &#123;</span><br><span class="line">            System.out.println( <span class="string">&quot;-----开始两个结果合并&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println( result.join());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><ul><li>认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。</li><li>适合写操作多的场景，先加锁可以保证写操作时数据正确。显式的锁定之后再操作同步资源</li></ul><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><ul><li>认为自己在使用数据时不会有别的线程修改数据或资源， 以不会添加锁。</li><li><strong>版本号，防止ABA问题</strong></li><li><strong>最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。</strong></li><li>适合读操作多的场景，<strong>不加锁的特点能够使其读操作的性能大幅提升。</strong><br>乐观锁则直接去操作同步资源，是一种无锁算法，得之我幸不得我命，再努力就是</li></ul><h4 id="类锁，对象锁"><a href="#类锁，对象锁" class="headerlink" title="类锁，对象锁"></a>类锁，对象锁</h4><p>类锁只有一把，一个对象也只有一把锁</p><h2 id="简单字节码"><a href="#简单字节码" class="headerlink" title="简单字节码"></a>简单字节码</h2><p>javap -cxxx.class</p><p>反编译命令</p><p>javap -v xxx.class 输出附加信息（包括行号、本地变量表，返汇编等详细信息）</p><p>synchronized同步代码块实现使用的是monitorenter和monitorexit<strong>指令</strong></p><p><strong>一般情况下一个exit对应2exit</strong></p><p><img src="/2022/10/26/juc-1/3.png" alt="image-20221016173215509"></p><p><img src="/2022/10/26/juc-1/4.png" alt="image-20221016175654450"></p><p>调用指令将会检查方法的ACC SYNCHRONIZED访问标志是否被设置。如果设置了，执行线程会将先持有monitor锁．然后再按行方法.心最后在方法完成(无论是正常完成还是非正常完成)时释放monitor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    Object object = new Object();</span></span><br><span class="line"><span class="comment">//    public void m1()</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        synchronized (object)&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;----hello synchronized code block&quot;);</span></span><br><span class="line"><span class="comment">//            throw new RuntimeException(&quot;-----exp&quot;);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//javap -v test08.class</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;</span><br><span class="line">       System.out.println( <span class="string">&quot;----hello synchronized m2&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println( <span class="string">&quot;----hello synchronized m3&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="管程（moniter）"><a href="#管程（moniter）" class="headerlink" title="管程（moniter）"></a>管程（moniter）</h2><p>为什么每一个对象都可以成为锁</p><p>每一个对象就是一个moniter监视器</p><p>指针指向monitor对象（也称为管程或监视器锁）的起始地址。每个对象都存在着一个montor与之关联，当一个monitor被某个线程持有后，它便处于锁定状态。在Java虚拟机(HotSpot)中，monitor是由ObjectMonitor实现的，其主要数据结构如下（位于HotSpot虚拟机源码ObjectMonitor.hpp文件，C++实现的)</p><p><img src="/2022/10/26/juc-1/7.png" alt="image-20221017105144335"></p><p>管程(英语:Monitors，也称为监视器)是一种程序结构，结构内的多个子程序(对象或模块〉形成的多个工作线程互斥访问共享资源。<br>这些共享资源一般是硬件设备或一群变量。对共享变量能够进行的所有操作集中在一个模块中。(把信号量及其操作原语“封装”在一个对象内部)管程实现了在一个时间点，最多只有一个线程在执行管程的某个子程序。管程提供了一种机制，管程可以看做一个软件模块，它是将共享的变量和对于这些共享变量的操作封装起来，形成一个具有一定接口的功能模块，进程可以调用管程来实现进程级别的并发控制。</p><p><strong>Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程(Monitor，更常见的是直接将它称为“锁”）来实现的。</strong></p><p><img src="/2022/10/26/juc-1/5.png" alt="image-20221016195849833"></p><p>ObjectMonitor中有几个关键属性</p><table><thead><tr><th>_owner</th><th align="left">指向持有ObjectMonitor对象的线程</th></tr></thead><tbody><tr><td>_WaitSet</td><td align="left">存放处于wait状态的线程队列</td></tr><tr><td>_EntryList</td><td align="left">存放处于等待锁block状态的线程队列</td></tr><tr><td>_recursions</td><td align="left">锁的重入次数</td></tr><tr><td>_count</td><td align="left">用来记录该线程获取锁的次数</td></tr></tbody></table><h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(number &gt; <span class="number">0</span>)</span><br><span class="line">            System.out.println(Thread.currentThread( ). getName()+<span class="string">&quot;卖出第: \t&quot;</span>+(number--) +<span class="string">&quot;\t还剩下:&quot;</span>+number);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">saleTicketDemod</span> &#123;</span><br><span class="line">    <span class="comment">//一坊程序的入口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[ ] args)</span>&#123;</span><br><span class="line">    <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123; <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">55</span>; i++) ticket.sale(); &#125;, <span class="string">&quot;a&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123; <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">55</span>; i++) ticket.sale(); &#125;,  <span class="string">&quot;b&quot;</span>). start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123; <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i <span class="number">55</span>; i++) ticket.sale(); &#125;,  <span class="string">&quot;c&quot;</span> ).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1<br>恢复挂起的线程到真正锁的获取还是有时间差的，从开发人员来看这个时间微乎其微，但是从CPU的角度来看，这个时间差存在的还是很明显的。<strong>所以非公平锁能更充分的利用CPU的时间片，尽量减少CPU空闲状态时间。</strong></p><p>2<br>使用多线程很重要的考量点是线程切换的开销，当采用非公平锁时，<strong>当1个线程请求锁获取同步状态，然后释放同步状态，所以刚释放锁的线程在此刻再次获取同步状态的概率就变得非常大，所以就减少了线程的开销。</strong></p><h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>一个线程中的多个流程可以获取同一把锁，持有这把同步锁可以再次进入。。<strong>自己可以获取自己的内部锁</strong></p><p>指的是可<strong>重复可递归调用</strong>的锁，在外层使用锁之后，在内层仍然可以使用，<strong>并且不发生死锁</strong>，这样的锁就叫做可重入锁。<br>简单的来说就是:在一个synchronized修饰的方法或代码块的内部调用本类的其他synchronized修饰的方法或代码块时，<strong>是永远可以得到锁</strong>的</p><p><strong>在一个synchronized修饰的方法或代码块的内部调用本类的其他synchronized修饰的方法或代码块时，是永远可以得到锁的</strong></p><h4 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h4><p><strong>每个锁对象拥有一个锁计数器和一个指向持有该锁的线程的指针。</strong><br>当执行monitorenter时，如果目标锁对象的计数器为零，那么说明它没有被其他线程所持有，Java虚拟机会将该锁对象的持有线程设置为当前线程，并且将其计数器加1。<br>在目标锁对象的计数器不为零的情况下，如果锁对象的持有线程是当前线程，那么Java虚拟机可以将其计数器加1，否则需要等待，直至持有线程释放该锁。<br><strong>当执行monitorexit时，Java虚拟机则需将锁对象的计数器减1。计数器为零代表锁已被释放。</strong></p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p><strong>死锁是指两个或两个以上的线程在执行过程中,因争夺资源而造成的一种互相等待的现象</strong>,<strong>若无外力干涉那它们都将无法推进下去</strong>，如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。</p><p><strong>主要原因</strong></p><ul><li>系统资源不足</li><li>进程运行推进的顺序不合适</li><li>资源分配不当</li></ul><p>案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[ ] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">objectA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">objectB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectA) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t自己持有A锁，希望获得B锁&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (objectB) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 成功获得B锁&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectB) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t自己持有B锁，希望获得A锁&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (objectA) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;It成功获得A锁&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>证明</p><p>jps -l</p><p>找到改进程，然后jstack</p><p>jstack 进程号</p><h4 id="jconsole图形检测死锁"><a href="#jconsole图形检测死锁" class="headerlink" title="jconsole图形检测死锁"></a>jconsole图形检测死锁</h4><p>实际可能用</p><p><img src="/2022/10/26/juc-1/6.png" alt="image-20221017102531173"></p><h2 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h2><h4 id="经典"><a href="#经典" class="headerlink" title="经典"></a>经典</h4><p><img src="/2022/10/26/juc-1/8.png" alt="image-20221017112502547"></p><table><thead><tr><th>public void interrupt()</th><th>实例方法，Just to set the interrupt fLag<br>实例方法interrupt()仅仅是设置线程的中断状态为true，发起一个协商而不会立刻停止线程</th></tr></thead><tbody><tr><td>public static boolean interrupted()</td><td>静态方法，Thread.interrupted();<br>判断线程是否被中断并清除当前中断状态。<br>这个方法做了两件事<br>1返回当前线程的中断状态，测试当前线程是否已被中断<br>2将当前线程的中断状态清零并重新设为false，清除线程的中断状态<br>此方法有点不好理解，如果连续两次调用此方法，则第二次调用将返回false，因为连续调用两次的结果可能不一样</td></tr><tr><td>public boolean isinterruoted()</td><td>实例方法，<br>判断当前线程是否被中断(通过检查中断标志位)</td></tr></tbody></table><h5 id="如何中断一个运行中的线程"><a href="#如何中断一个运行中的线程" class="headerlink" title="如何中断一个运行中的线程??"></a>如何中断一个运行中的线程??</h5><h6 id="通过一个volatile变量实现"><a href="#通过一个volatile变量实现" class="headerlink" title="通过一个volatile变量实现"></a>通过一个volatile变量实现</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">isStop</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isStop) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t isstop被修改为true，程序停止&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;t1 -----hello volatile&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停毫秒</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(  <span class="number">20</span>); &#125; <span class="keyword">catch</span>  (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">                isStop = <span class="literal">true</span>;</span><br><span class="line">        &#125; ,<span class="string">&quot;t2&quot;</span> ).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="通过AtomicBoolean天生原子操作"><a href="#通过AtomicBoolean天生原子操作" class="headerlink" title="通过AtomicBoolean天生原子操作"></a>通过AtomicBoolean天生原子操作</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">AtomicBoolean</span> <span class="variable">atomicBoolean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(  <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (atomicBoolean.get()) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t atomicBoolean被修改为true，程序停止&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;t1 -----hello atomicBoolean&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//暂停毫秒</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">20</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            atomicBoolean.set(<span class="literal">true</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="通过Thread类自带的中断api实例方法实现"><a href="#通过Thread类自带的中断api实例方法实现" class="headerlink" title="通过Thread类自带的中断api实例方法实现"></a>通过Thread类自带的中断api实例方法实现</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t isInterrupted()被修改为true，程序停止&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;t1 -----hello interrupt api&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">//暂停毫秒</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">50</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//t2向t1发出协商，将t1的中断标志位设为true希望t1停下来</span></span><br><span class="line">        <span class="comment">/*new Thread(() -&gt; &#123;</span></span><br><span class="line"><span class="comment">            t1.interrupt();</span></span><br><span class="line"><span class="comment">        &#125;, &quot;t2&quot;).start();*/</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//也可以自己停下来</span></span><br><span class="line">    t1.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如何停止一个运行中的线程??</p><p>如何停止中断运行中的线程?</p><h4 id="当前线程的中断标识为true，是不是线程就立刻停止"><a href="#当前线程的中断标识为true，是不是线程就立刻停止" class="headerlink" title="当前线程的中断标识为true，是不是线程就立刻停止?"></a>当前线程的中断标识为true，是不是线程就立刻停止?</h4><p>静态方法Thread.interrupted()，谈谈你的理解</p><h4 id="什么是中断机制"><a href="#什么是中断机制" class="headerlink" title="什么是中断机制?"></a>什么是中断机制?</h4><p>首先<br><strong>一个线程不应该由其他线程来强制中断或停止，而是应该山线程自己自行停止，自己来决定自己的命运</strong>。所以，<strong>Thread.stop,Thread.suspend, Thread.resume都已经被废弃了。</strong><br>其次<br><strong>在Java中没有办法立即停止一条线程，然而停止线程却显得尤为重要</strong>，如取消一个耗时操作。因此，<strong>Java提供了一种用于停止线程的协商机制—中断，也即中断标识协商机制。</strong><br>中断只是一种协作协商机制，Java没有给中断增加任何语法，中断的过程完全需要程序员自己实现。<br>若要中断一个线程，你需要手动调用该线程的interrupt方法，<strong>该方法也仅仅是将线程对象的中断标识设成true</strong>;<strong>接着你需要自己写代码不断地检测当前线程的标识位，如果为true，表示别的线程请求这条线程中断，</strong><br>此时究竟该做什么需要你自己写代码实现。<br>每个线程对象中都有一个中断标识位，用于表示线程是否被中断;该标识位为true表示中断，为false表示未中断;通过调用线程对象的interrupt方法将该线程的标识位设为true;可以在别的线程中调用，也可以在自己的线程中调用。</p><p>例子，一家餐厅，顾客线程和服务员线程，顾客抽烟，服务员只能劝说顾客别抽烟，协商</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>注意</p><p>如果该统程日塞的调用wait() , wait(long) , 或wait(long，int)的方法Dbject类，的join()， join(1ong) ， join(long, int) ， slep(lng),islerp(1lng , int) 这个英的方法，那么它的中断状态将被清除，并且将收到InterruptedException 。</p><p>具体来说，当对一个线程，调用interrupt()时:<br>1、<strong>如果线程处于正常活动状态，那么会将该线程的中断标志设置为 true，仅此而已</strong>。<strong>被设置中断标志的线程将继续正常运行，不受影响。</strong><br>所以，interrupt()并不能真正的中断线程，需要被调用的线程自己进行配合才行。</p><p>2、<strong>如果线程处于被阻塞状态（例如处于sleep, wait,join等状态)，在别的线程中调用当前线程对象的interrupt方法，那么线程将立即退出被阻塞状态，并抛出一个InterruptedException异常。</strong></p><p>实例方法interrupt()仅仅是设置菲程的中断状态位设置为true，不会停止线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//实例方法interrupt()仅仅是设置菲程的中断状态位设置为true，不会停止线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">300</span>; i++)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;-----: &quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;t1线程调用interrupt()后的的中断标识02:&quot;</span> + Thread.currentThread().isInterrupted());</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span> );</span><br><span class="line">        t1.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;t1线程默认的中断标识:&quot;</span>+t1.isInterrupted());<span class="comment">//false</span></span><br><span class="line">        <span class="comment">//暂停毫秒</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(  <span class="number">2</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        t1.interrupt(); <span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;t1线程调用interrupt()后的的中断标识01:&quot;</span>+t1.isInterrupted());<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep( <span class="number">2000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace();&#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;t1线程调用interrupt()后的的中断标识03:&quot;</span>+t1.isInterrupted());<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="小小案例"><a href="#小小案例" class="headerlink" title="小小案例"></a>小小案例</h4><p>1中断标志位，默认false</p><p>2 t2 —-&gt; t1发出了中断协商，t2调用t1.interrupt( )，中断标志位true</p><p>3中断标志位true，正常情况，程序停止，八_A</p><p>4中断标志位true，异常情况，InterruptedException，将会把中断状态将被清除，并且将收到nterruptedEwception 。中断标志(ifolse<br>导致无限循环</p><p>5 在catch块中，需要再次给中断标志位设置为true，2次调用停止程序才ok</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                   System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;中断标志位:&quot;</span> + Thread.currentThread().isInterrupted() + <span class="string">&quot;程序停止&quot;</span>);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   Thread.sleep(<span class="number">200</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   Thread.currentThread().interrupt();<span class="comment">//没有它，程序不会停止，中断不打断，看看sleep方法的源码</span></span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               System.out.println(<span class="string">&quot;-----hello InterruptDemo3&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">       t1.start();</span><br><span class="line">       <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">       <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep( <span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; t1.interrupt(),  <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="小小案例（二）"><a href="#小小案例（二）" class="headerlink" title="小小案例（二）"></a>小小案例（二）</h4><p><img src="/2022/10/26/juc-1/9.png" alt="image-20221018214931283"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试当前线程是否被中断（检查中断标志），返回一个boolean并清除中断状态，</span></span><br><span class="line">        <span class="comment">//第二次再调用时中断状态已经被清除，将返回一个false。</span></span><br><span class="line"></span><br><span class="line">       System.out.println(Thread.currentThread( ).getName()+<span class="string">&quot;\t&quot;</span>+Thread.interrupted());</span><br><span class="line">       System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+Thread.interrupted());</span><br><span class="line">       System.out.println( <span class="string">&quot;----1&quot;</span> );</span><br><span class="line">        Thread.currentThread( ).interrupt( );<span class="comment">//中断标志位设置为truesystem.out.println(&quot;----2&quot; );</span></span><br><span class="line">        System.out.println(Thread.currentThread( ).getName()+<span class="string">&quot;\t&quot;</span>+Thread.interrupted());</span><br><span class="line">        System.out.println(Thread.currentThread() .getName()+<span class="string">&quot;\t&quot;</span>+Thread.interrupted());</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出结果</span></span><br><span class="line"><span class="comment">mainfalse</span></span><br><span class="line"><span class="comment">mainfalse</span></span><br><span class="line"><span class="comment">----1</span></span><br><span class="line"><span class="comment">maintrue</span></span><br><span class="line"><span class="comment">mainfalse</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>线程中断相关的方法:<br>public void interrupt() . interrupt()方法是一个实例方法<br>它通知目标线程中断，也仅是设置目标线程的中断标志位为true。<br>public boolean isInterrupted(). isInterrupted()方法也是一个实例方法它判断当前线程是否被中断（通过检查中断标志位）并获取中断标志<br>public static boolean interrupted().Thread类的静态方法interrupted()<br>返回当前线程的中断状态真实值(boolean类型)后会将当前线程的中断状态设为false，此方法调用之后会清除当前线程的中断标志位的状态（将中断标志置为false了)，返回当前值并清零置false</p><h2 id="lockInterrupt"><a href="#lockInterrupt" class="headerlink" title="lockInterrupt"></a>lockInterrupt</h2><p>锁的支撑类，解决了老技术什么问题？</p><p>Package java.util.concurrent.locks</p><p>用于创建锁和其他同步类的基本线程阻塞原语。</p><p>lockInterrupt线程等待唤醒机制的加强与提升</p><h4 id="三种让线程等待和唤醒的方法"><a href="#三种让线程等待和唤醒的方法" class="headerlink" title="三种让线程等待和唤醒的方法"></a>三种让线程等待和唤醒的方法</h4><ul><li>方式1:使用object中的wait()方法让线程等待，使用Object中的notify()方法唤醒线程</li><li>方式2:使用Juc包中Condition的e:ait()方法让线程等待，使用signal()方法唤醒线程方式</li><li>3:LockSupport类可以阻塞当前线程以及唤醒指定被阻塞的线程</li></ul><h4 id="先来看看wait和notify实现线程的等待和唤醒"><a href="#先来看看wait和notify实现线程的等待和唤醒" class="headerlink" title="先来看看wait和notify实现线程的等待和唤醒"></a>先来看看wait和notify实现线程的等待和唤醒</h4><ul><li><p>wait方法和notify方法，两个都去掉同步代码块                       —————–出现异常</p></li><li><p>将notify放在wait方法前面程序无法执行，无法唤醒                —————–无法被唤醒</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">objectLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t ----come in&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    objectLock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t ----被唤醒&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="comment">//暂停几秒钟线程</span></span><br><span class="line"><span class="comment">//        try &#123;</span></span><br><span class="line"><span class="comment">//            TimeUnit.SECONDS.sleep(1);</span></span><br><span class="line"><span class="comment">//        &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">                objectLock.notify();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t ----发出通知&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="condition接口中的await和signal方法实现线程的等待和唤醒"><a href="#condition接口中的await和signal方法实现线程的等待和唤醒" class="headerlink" title="condition接口中的await和signal方法实现线程的等待和唤醒"></a>condition接口中的await和signal方法实现线程的等待和唤醒</h4><p>同样</p><ul><li><p>wait方法和notify方法，两个都去掉同步代码块                       —————–出现异常</p></li><li><p>将notify放在wait方法前面程序无法执行，无法唤醒                —————–无法被唤醒</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(  <span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">            lock.lock( );</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread( ).getName()+<span class="string">&quot;\t ----come in&quot;</span>);condition.await();</span><br><span class="line">                System.out.println(Thread.currentThread( ).getName()+<span class="string">&quot;\t ----被唤醒&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;t1&quot;</span> ).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">        <span class="comment">//try &#123; TimeUnit.SECONDS.sleep(  1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                condition.signal();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t -----发出通知&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="小小总结"><a href="#小小总结" class="headerlink" title="小小总结"></a>小小总结</h4><p>线程先要获得并持有锁，必须在锁块(synchronized或lock)中必须要先等待后唤醒，线程才能够被唤醒</p><h4 id="lockInterrupt的改进"><a href="#lockInterrupt的改进" class="headerlink" title="lockInterrupt的改进"></a>lockInterrupt的改进</h4><p>对上面两种进行了改进</p><p><strong>sleep方法3秒后醒来，执行park无效，没有阻塞效果，</strong>解释如下先执行了unpark(t1)导致上面的park方法形同虚设无效，时间一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(  <span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        System.out.println(Thread.currentThread( ).getName() + <span class="string">&quot;\t ----come in&quot;</span>);</span><br><span class="line">        LockSupport.park();</span><br><span class="line"><span class="comment">//LockSupport.park();  //只有一个许可证</span></span><br><span class="line">        System.out.println( Thread.currentThread( ).getName() + <span class="string">&quot;\t ----被唤醒&quot;</span>);&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">    <span class="comment">//try &#123; TimeUnit.SECONDS.sleep(  1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">        LockSupport.unpark(t1);</span><br><span class="line">        System.out.println(Thread.currentThread( ).getName()+<span class="string">&quot;\t ----发出通知&quot;</span>);&#125;,  <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：只有一个许可证</strong></p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul><li>为什么可以突破wait&#x2F;notify的原有调用顺序?</li></ul><p>因为unpark获得了一个凭证，之后再调用park方法，就可以名正言顺的凭证消费，故不会阻塞。I先发放了凭证后续可以畅通无阻。</p><ul><li>为什么唤醒两次后阻塞两次，但最终结果还会阻塞线程?</li></ul><p>因为凭证的数量最多为1，连续调用两次unpark和调用一次unpark效果一样，只会增加一个凭证;而调用两次park却需要消费两个凭证，证不够，不能放行。</p><h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><h4 id="先问几个问题"><a href="#先问几个问题" class="headerlink" title="先问几个问题"></a>先问几个问题</h4><ul><li>你知道什么是Java内存模型JMM吗?</li><li>JMM与volatile它们两个之间的关系?</li><li>JMM有哪些特性or它的三大特性是什么?</li><li>为什么要有JMM，它为什么出现?作用和功能是什么?</li><li>happens-before先行发生原则你有了解过吗?</li></ul><h4 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h4><p>因为有这么多级的缓存(cpu和物理主内存的速度不一致的)，<br>    <strong>CPU的运行并不是直接操作内存而是先把内存里边的数据读到缓存</strong>，<strong>而内存的读和写操作的时候就会造成不一致的问题</strong></p><p><strong>数据库先把数据load到内存，CPU再从内存load到缓存</strong></p><img src="/2022/10/26/juc-1/10.png" alt="image-20221019142821802" style="zoom: 67%;"><p>JVM规范中试图定义一种Java内存模型(java Memory Model，简称JMM)来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。<strong>比如普通话，让粤语和四川话的人都能沟通</strong><br>所以，推导出我们需要知道JMM</p><h4 id="JMM简介"><a href="#JMM简介" class="headerlink" title="JMM简介"></a>JMM简介</h4><p>JMM(Java内存模型Java Memory Model，简称JMM)本身是一种抽象的概念并不真实存在它仅仅描述的是一组约定或规范，通过这组规范定义了程序中(尤其是多线程)各个变量的读写访问方式并决定一个线程对共享变量的写入何时以及如何变成对另一个线程可见，<strong>关键技术点都是围绕多线程的原子性、可见性和有序性展开的。</strong><br>原则:<br>JMM的关键技术点都是围绕多线程的原子性、可见性和有序性展开的</p><p>能干嘛?</p><p>1通过JMM来实现线程和主内存之间的抽象关系。</p><p>2<strong>屏蔽各个硬件平台和操作系统的内存访问差异以实现让Java程序在各种平台下都能达到一致的内存访问效果。</strong></p><h4 id="JMM下三大特性"><a href="#JMM下三大特性" class="headerlink" title="JMM下三大特性"></a>JMM下三大特性</h4><p>可见性</p><p>原子性</p><p>有序性</p><p>​指令重排</p><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>可见性<br><strong>是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道该变更，JMM规定了所有的变量都存储在主内种。</strong></p><p><img src="/2022/10/26/juc-1/11.png" alt="image-20221019144330146"></p><p>系统主内存共享变量数据修改被写入的时机是不确定的，多线程并发下很可能出现”脏读”.所以每个线程都有自己的工作内存、线程自己的工作内存中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取，赋值等）都必需在线程自己的工作内存中进行，而不能够直接读写主内存中的变量。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成</p><table><thead><tr><th>主内存中有变量x，初始值为0</th></tr></thead><tbody><tr><td>线程A要将x加1，先将x&#x3D;O拷贝到自己的私有内存中，然后更新x的值</td></tr><tr><td>线程A将更新后的×值回刷到主内存的时间是不固定的</td></tr><tr><td>刚好在线程A没有回刷x到主内存时，线程B同样从主内存中读取x，此时为0，和线程A一样的操作，最后期盼的x&#x3D;2就会变成x&#x3D;1</td></tr></tbody></table><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><h5 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h5><p>对于一个线程的执行代码而言，我们总是习惯性认为代码的执行总是从上到下，有序执行。但为了提升性能，<strong>编译器和处理器通常会对指令序列进行重新排序。Java规范规定JMM线程内部维持顺序化语义，即只要程序的最终结果与它顺序化执行的结果相等，那么指令的执行顺序可以与代码顺序不一致，此过程叫指令的重排序。</strong></p><h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><p>JVM能根据处理器特性〈CPU多级缓存系统、多核处理器等）适当的对机器指令进行重排序，使机器指令能更符合CPU的执行特性，最大限度的发挥机器性能。但是，<br><strong>指令重排可以保证串行语义一致，但没有义务保证多线程间的语义也一致</strong>(即可能产生”脏读”)，简单说，<br>两行以上不相干的代码在执行的时候有可能先执行的不是第一条，不见得是从上到下顺序执行，执行顺序会被优化。<br>从源码到最终执行示例图:</p><p><img src="/2022/10/26/juc-1/12.png" alt="image-20221019155719591"></p><p>单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致。处理器在进行重排序时必须要考虑指令之间的数据依赖性<br>多线程环境中线程交替执行,由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的,结果无法预测。</p><p>读取过程<br>有数据区域，而Java内存模型中规定所有变量都存储在主内存，<strong>主内存是共享内存区域，所有线程都可以访问</strong>，<strong>但线程对变量的操作(读取赋值等)必须在工作内存中进行</strong>，<strong>首先要将变量从主内存拷贝到的线程自己的工作内存空间，然后对变量进行操作</strong>，<strong>操作完成后再将变量写回主内存，不能直接操作主内存中的变量</strong>，各个线程中的工作内存中存储着主内存中的变量副本拷贝，<strong>因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成</strong>，其简要访问过程如下图:</p><p><img src="/2022/10/26/juc-1/13.png" alt="image-20221019162124515"></p><h4 id="小小小总结"><a href="#小小小总结" class="headerlink" title="小小小总结"></a>小小小总结</h4><p>我们定义的所有共享变量都储存在物理主内存中<br>每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本(主内存中该变量的一份拷贝)<br>线程对共享变量所有的操作都必须先在线程自己的工作内存中进行后写回主内存，不能直接从主内存中读写(不能越级)<br>不同线程之间也无法直接访问其她线程的工作内存中的变量，线程间变量值的传递需要通过主内存来进行(同级不能相互访问)</p><h4 id="Happens-Before"><a href="#Happens-Before" class="headerlink" title="Happens-Before"></a>Happens-Before</h4><p><strong>如果Java内存模型中所有的有序性都仅靠volatile和synchronized来完成，那么有很多操作都将会变得非常啰嗦，但是我们在编写Java并发代码的时候并没有察觉到这一点。</strong><br><strong>我们没有时时、处处、次次，添加volatile和synchronized来完成程序，这是因为Java语言中JMM原网下有一个“先行发生”(Happens-Before)的原则限制和规矩，给你立好了规矩!</strong>&lt;————————-<strong>Happens-Before</strong><br>这个原则非常重要:<br>它是判断数据是否存在竞争，线程是否安全的非常有用的手段。依赖这个原则，我们可以通过几条简单规则一揽子解决并发环境下两个操作之间是否可能存在冲突的所有问题，而不需要陷入Java内存模型苦涩难懂的底层编译原理之中。</p><h4 id><a href="#" class="headerlink" title></a></h4><p>多线程先行发生原则</p><p><strong>规定了多线程谁先谁后了之后，互相让其他线程获得感知</strong></p><p>在JMM中，<br><strong>如果一个操作执行的结果需要对另一个操作可见性</strong><br><strong>或者代码重排序，那么这两个操作之间必须存在happens-before(先行发生)原则</strong>。逻辑上的先后关系</p><h5 id="总原则"><a href="#总原则" class="headerlink" title="总原则"></a>总原则</h5><p><strong>把下面的happens-before直译为“在什么之前”，那么就很好理解了，你懂的</strong></p><p>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。<br>两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。</p><h5 id="8大原则"><a href="#8大原则" class="headerlink" title="8大原则"></a>8大原则</h5><ul><li><p>1.次序规则:</p></li><li><p>2.锁定规则:</p></li><li><p>3.volatile变量规则:</p><ul><li>对一个volatile变量的写操作先行发生于后面对这个变量的读操作，<strong>前面的写对后面的读是可见的</strong>，这里的“后面”同样是指时间上的先后。</li></ul></li><li><p>4.传递规则:</p></li><li><p>5.线程启动规则(Thread Start Rule):</p><ul><li>Thread对象的start()方法先行发生于此线程的每一个动作</li></ul></li><li><p>6.线程中断规则(Thread lnterruption Rule):</p><ul><li>对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生;</li><li>可以通过Thread.interrupted()检测到是否发生中断<br><strong>也就是说你要先调用interrupt()方法设置过中断标志位，我才能检测到中断发送</strong></li></ul></li><li><p>7.线程终止规则(Thread Termination Rule):</p><ul><li>线程中的所有操作都先行发生于对此线程的终止检<br>测，我们可以通过isAlive()等手段检测线程是否已经终止执行。</li></ul></li><li><p>8.对象终结规则(Finalizer Rule):</p><ul><li>一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始</li><li>人话：对象没有完成初始化之前，是不能调用finalized()方法的</li></ul></li></ul><h4 id="Happens-Before小小总结"><a href="#Happens-Before小小总结" class="headerlink" title="Happens-Before小小总结"></a>Happens-Before小小总结</h4><p>在Java语言里面，Happens-Before的语义本质上是一种可见性<br>A Happens-BeforeB意味着A发生过的事情对B来说是可见的，无论A事件和B事件是否发生在同一个线程里.<br>JMM的设计分为两部分:<br>一部分是面向我们程序员提供的，也就是happens-before规则，它通俗易懂的向我们程序员阐述了一个强内存模型，我们只要理解happens-before规则，就可以编写并发安全的程序了。<br>另一部分是针对JVM实现的，为了尽可能少的对编译器和处理器做约束从而提高性能，JMM在不影响程序执行结果的前提下对其不做要求，即允许优化重排序。我们只需要关注前者就好了，也就是理解happens-before规则即可，其它繁杂的内容有JMM规范结合操作系统给我们搞定，我们只写好代码即可。</p><h2 id="Volatile与JMM"><a href="#Volatile与JMM" class="headerlink" title="Volatile与JMM"></a>Volatile与JMM</h2><p>volatile两大特点</p><ul><li>可见性</li><li>和有序性<ul><li>禁止重排序</li><li><strong>从编译器的手动挡变成自动挡</strong></li></ul></li></ul><h4 id="volatile内存语义"><a href="#volatile内存语义" class="headerlink" title="volatile内存语义"></a>volatile内存语义</h4><p><strong>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共亳变量值立即刷新回主内存中。</strong><br><strong>当读一个volatile变量时，JMM会把该线程对应的本地内存设置为无效，重新回到主内存中读取最新共享变量</strong></p><p><strong>注意：</strong>本地内存和主内存，你懂的</p><p>所以volatile的<strong>写内存语义是直接刷新到主内存中，读的内存语义是直接从主内存中读取。</strong></p><p>为什么可以禁止重排序</p><p>——内存屏障</p><h4 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h4><p>是什么<br>内存屏障（也称内存栅栏，屏障指令等，是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一1个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作），避免代码重排序。<strong>内存屏障其实就是一种JVM指令</strong>，Java内存模型<br>的重排规则会<strong>要求Java编译器在生成JVM指令时插入特定的内存屏障指令</strong>，通过这些内存屏障指令，volatile实现了Java内存模型中的可见性和有序性(禁重排)，<strong>但volatile无法保证原子性。</strong><br><strong>内存屏障之前的所有写操作都要回写到主内存，</strong><br><strong>内存屏障之后的所有读操作都能获得内存屏障之前的所有写操作的最新结果(实现了可见性)。</strong></p><p>写屏障（Store Memory Barrier):告诉处理器在写屏障之前将所有存储在缓存(store bufferes)中的数据同步到主内存。也就是说当看到Store屏障指令，就必须把该指令之前所有写入指令执行完毕才能继续往下执行。</p><p>读屏障(Load Memory Barrier):处理器在读屏障之后的读操作，都在读屏障之后执行。也就是说在Load屏障指令之后就能够保证后面的读取数据指令一定能够读取到最新的数据。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVAWEB(2)</title>
      <link href="/2022/10/26/JAVAWEB-2/"/>
      <url>/2022/10/26/JAVAWEB-2/</url>
      
        <content type="html"><![CDATA[<h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><h3 id="Servlet对象的生命周期"><a href="#Servlet对象的生命周期" class="headerlink" title="Servlet对象的生命周期"></a>Servlet对象的生命周期</h3><ul><li><p>什么是Servlet对象生命周期?</p><ul><li>Servlet对象什么时候被创建。</li><li>Servlet对象什么时候被销毁。</li><li>Servlet对象创建了几个?</li><li>Servlet对象的生命周期表示:一个Servlet对象从出生在最后的死亡，整个过程是怎样的。</li></ul></li><li><p>Servlet对象是由谁来维护的?</p><ul><li>Servlet对象的创建，对象上方法的调用，对象最终的销毁，Javaweb程序员是无权干预的。</li><li>Servlet对象的生命周期是由Tomcat服务器(WEB Server）全权负责的。</li><li>Tomcat服务器通常我们又称为:WEB容器。(这个叫法你要知道【WEB Container】)</li><li>WEB容器来管理Servlet对象的死活。</li></ul></li><li><p>思考:我们自己new的Servlet对象受WEB容器的管理吗?</p><ul><li>我们自己new的Servlet对象是不受WEB容器管理的。</li><li>WEB容器创建的Servlet对象，这些Servlet对象都会被放到一个集合当中(HashMap)，只有放到这个HashMap集合中的Servlet才能够被WEB容器管理，自己new的Servlet对象不会被WEB容器管理。(自己new的Servlet对象不在容器当中)</li><li><strong>web容器底层应该有一个HashMap这样的集合，在这个集合当中存储了Servlet对象和请求路径之间的关系</strong></li><li><img src="/2022/10/26/JAVAWEB-2/10.png" alt="image-20221022204604844"></li></ul></li><li><p>研究:服务器在启动的Servlet对象有没有被创建出来(默认情况下)?</p><ul><li>在Servlet中<strong>提供一个无参数的构造方法</strong>，<strong>启动服务器的时候看看构造方法是否执行。</strong></li><li>经过测试得出结论:默认情况下，服务器在启动的时候Servlet对象并不会被实例化。</li><li>这个设计是合理的。用户没有发送请求之前，如果提前创建出来所有的Servlet对象，必然是耗费内存的，并且创建出来的Servlet如果一直没有用户访问，显然这个Servlet对象是一个废物，没必要先创建。</li></ul></li><li><p>怎么让服务器启动的时候创建Servlet对象呢?</p><ul><li><p>在servlet标签中添加<load-on-startup>子标签，在该子标签中填写整数，越小的整数优先级越高。</load-on-startup></p></li><li><p>&#96;&#96;&#96;xml<br><load-on-startup><load-on-startup></load-on-startup></load-on-startup></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- Servlet对象生命周期</span><br><span class="line"></span><br><span class="line">- 默认情况下服务器启动的时候AServlet对象并没有被实例化。</span><br><span class="line"></span><br><span class="line">- 用户发送第一次请求的时候，控制台输出了以下内容:</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>AServlet无参数构造方法执行了<br>Aservlet ‘s init method execute!<br>AServlet ‘s service method execute!</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 根据以上输出内容得出结论:</span><br><span class="line"></span><br><span class="line">  - 用户在发送第一次请求的时候Serlet对象被实例化(AServlet的构造方法被执行了。并且执行的是无参数构造方法。)</span><br><span class="line">  - AServlet对象被创建出来之后，Tomcat服务器马上调用了AServlet对象的init方法。(init方法在执行的时候，AServlet对象</span><br><span class="line">    已经存在了。已经被创建出来了。)</span><br><span class="line">  - 用户发送第一次请求的时候，init方法执行之后，Tomcat服务器马上调用ASerMlet对象的service方法。</span><br><span class="line"></span><br><span class="line">- 用户继续发送第二次请求，控制台输出了以下内容:</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>AServlet ‘s service method execute!</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 根据以上输出结果得知，用户在发送第二次，或者第三次，或者第四次请求的时候，Servlet对象并没有新建，还是使用之前创建好的Servlet对象，直接调用该Servlet对象的service方法，这说明:</span><br><span class="line"></span><br><span class="line">  - 第一:Serlet对象是单例的（(单实例的。但是要注意:Serdlet对象是单实例的，但是Servlet类并不符合单例模式。我们称之为假单例。之所以单例是因为Servlet对象的创建我们iavaweb程序员管不着，这个对象的创建只能是Tomcat来说了算，Tomcat只创建了一个，所以导致了单例，但是属于假单例。真单例模式，构造方法是私有化的。)</span><br><span class="line">  - 第二∶无参数构造方法、init方法只在第一次用户发送请求的时候执行。也就是说无参数构造方法只执行一次。init方法也只被Tomcat服务器调用一次。</span><br><span class="line">  - 第三∶只要用户发送一次请求: service方法必然会被Tomcat服务器调用一次。发送100次请求，service方法会被调用100次。</span><br><span class="line"></span><br><span class="line">- 关闭服务器的时候，控制台输出了以下内容:</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>AServlet ‘s service destroy method execute!</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 通过以上输出内容，可以得出以下结论:</span><br><span class="line"></span><br><span class="line">  - Servlet的destroy方法只被Tomcat服务器调用一次。</span><br><span class="line">  - destroy方法是在什么时候被调用的?</span><br><span class="line">    - 在服务器关闭的时候。</span><br><span class="line">    - 因为服务器关闭的时候要销毁AServlet对象的内存。</span><br><span class="line">    - 服务器在销毁AServlet对象内存之前，Tomcat服务器会自动调用ASerlet对象的destroy方法。</span><br><span class="line">  - 请问: destroy方法调用的时候，对象销毁了还是没有销毁呢?</span><br><span class="line">    - destroy方法执行的时候AServlet对象还在，没有被销毁。destroy方法执行结束之后，AServlet对象的内存才会被Tomcat释放。</span><br><span class="line"></span><br><span class="line">- Servlet对象更像一个人的一生:</span><br><span class="line"></span><br><span class="line">  - Servlet的无参数构造方法执行:标志着你出生了。</span><br><span class="line">  - Servlet对象的init方法的执行:标志着你正在接受教育。</span><br><span class="line">  - Servlet对象的service方法的执行:标志着你已经开始工作了，已经开始为人类提供服务了。</span><br><span class="line">  - Servlet对象的destroy方法的执行:标志着临终。有什么遗言，抓紧的。要不然，来不及了。</span><br><span class="line"></span><br><span class="line">- 关于Servlet类中方法的调用次数?</span><br><span class="line"></span><br><span class="line">  - 构造方法只执行一次。</span><br><span class="line">  - init方法只执行一次。</span><br><span class="line">  - service方法:用户发送一次请求则执行一次，发送N次请求则执行N次。- </span><br><span class="line">  - destroy方法只执行一次。</span><br><span class="line"></span><br><span class="line">- 当我们Servlet类中编写一个有参数的构造方法，如果没有手动编写无参数构造方法会出现什么问题?</span><br><span class="line"></span><br><span class="line">  - 报错了:500错误。</span><br><span class="line">  - 注意:500是一个HTTP协议的错误状态码。</span><br><span class="line">  - 500一般情况下是因为服务器端的Java程序出现了异常。(服务器端的错误都是500错误:服务器内部错误。)</span><br><span class="line">  - 如果没有无参数的构造方法，会导致出现500错误，无法实例化Servlet对象。</span><br><span class="line">  - 所以，一定要注意:在Servlet开发当中，不建议程序员来定义构造方法，因为定义不当，一不小心就会导致无法实例化Servlet对象。</span><br><span class="line"></span><br><span class="line">- 思考: Servlet的无参数构造方法是在对象第一次创建的时候执行，并且只执行一次。init方法也是在对象第一次创建的时候执行，并且只执行一次。那么这个无参数构造方法可以代替掉init方法吗?</span><br><span class="line"></span><br><span class="line">  - 不能。</span><br><span class="line">  - Servlet规范中有要求，作为jiavaweb程序员，编写Servlet类的时候，不建议手动编写构造方法，因为编写构造方法，很容易让无参数构造方法消失，这个操作可能会导致Servlet对象无法实例化。所以init方法是有存在的必要的。</span><br><span class="line"></span><br><span class="line">- init. service、destroy方法中使用最多的是哪个方法?</span><br><span class="line"></span><br><span class="line">  - 使用最多就是service方法，service方法是一定要实现的，因为service方法是处理用户请求的核心方法。</span><br><span class="line">  - 什么时候使用init方法呢?</span><br><span class="line">    - init方法很少用。</span><br><span class="line">    - 通常在init方法当中做初始化操作，并且这个初始化操作只需要执行一次。例如:初始化数据库连接池，初始化线程池....</span><br><span class="line"></span><br><span class="line">- 什么时候使用destroy方法呢?</span><br><span class="line"></span><br><span class="line">  - destroy方法也很少用。</span><br><span class="line">  - 通常在destroy方法当中，进行资源的关闭。马上对象要被销毁了，还有什么没有关闭的，抓紧时间关闭资源。还有什么资源没保存的.抓鉴时间保存一下。</span><br><span class="line"></span><br><span class="line">- 我们编写一个Servlet类直接实现Servlet接口有什么缺点?</span><br><span class="line"></span><br><span class="line">  - 我们只需要service方法，其他方法大部分情况下是不需要使用的。代码很丑陋。</span><br><span class="line"></span><br><span class="line">- 适配器设计模式Adapter</span><br><span class="line"></span><br><span class="line">  - 手机直接插到22OM的电压上，手机直接就报废了。怎么办?可以找一个充电器。这个充电器就是一个适配器。手机连接适配</span><br><span class="line">    器。适配器连接220V的电压。这样问题就解决了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### GenericServlet（重点）</span><br><span class="line"></span><br><span class="line">- 编写一个GenericServlet类，这个类是一个抽象类，其中有一个抽象方法service。</span><br><span class="line"></span><br><span class="line">  - GenericServlet实现Servlet接口。</span><br><span class="line">  - GenericServlet是一个适配器。</span><br><span class="line">  - 以后编写的所有Servlet类继承GenericServlet，重写service方法即可。</span><br><span class="line"></span><br><span class="line">- 思考: GenericServlet类是否需要改造一下?怎么改造?更利于子类程序的编写?</span><br><span class="line"></span><br><span class="line">  - 思考第一个问题:我提供了一个GenericServlet之后，init方法还会执行吗?</span><br><span class="line">  - 还会执行。会执行GenericServlet类中的init方法。</span><br><span class="line"></span><br><span class="line">- 思考第二个问题:init方法是谁调用的?</span><br><span class="line"></span><br><span class="line">  - Tomcat服务器调用的。</span><br><span class="line"></span><br><span class="line">- 思考第三个问题:init方法中的ServletConfig对象是谁创建的?是谁传过来的?</span><br><span class="line"></span><br><span class="line">  - 都是Tomcat千的。</span><br><span class="line">  - Tomcat服务器先创建了ServletConfig对象，然后调用init方法，将ServletConfig对象传给了init方法。</span><br><span class="line"></span><br><span class="line">- 思考—下Tomcat服务器伪代码:</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    public class Tomcat &#123;</span><br><span class="line">        public static void main(String[] args) &#123;</span><br><span class="line">            // .....</span><br><span class="line">            //Tomcat服务器伪代码</span><br><span class="line">            //创建LoginServlet对象〈通过反射机制，调用无参数构造方法来实例化LoginServlet对象)</span><br><span class="line">            Class clazz = Class.forName(&quot; com.bjpowernode.javaweb.servlet.Loginservlet&quot;);</span><br><span class="line">            Object obj = clazz.newInstance();</span><br><span class="line">    </span><br><span class="line">            //向下转型</span><br><span class="line">            Servlet servlet = (servlet) obj;</span><br><span class="line">    </span><br><span class="line">            //创建servletconfig对象</span><br><span class="line">            //Tomcat服务器负责将servletconfig对象实例化出来。</span><br><span class="line">            //多态(Tomcat服务器完全实现了servlet规范)</span><br><span class="line">            Servletconfig servletConfig = new org.apache.catalina.core.StandardwrapperFacade();</span><br><span class="line">    </span><br><span class="line">            //调用servlet的init方法</span><br><span class="line">            servlet.init(servletconfig);</span><br><span class="line">            </span><br><span class="line">            //调用servlet的service方法</span><br><span class="line">            // ....</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient//不参与序列化，序列化版本号</span><br></pre></td></tr></table></figure><h3 id="ServletConfig（重点）-局部"><a href="#ServletConfig（重点）-局部" class="headerlink" title="ServletConfig（重点）(局部)"></a>ServletConfig（重点）(局部)</h3><p>适配器</p><ul><li><p>什么是ServletConfig?</p><ul><li>Servlet对象的配置信息对象。</li><li>ServletConfig对象中封装了<servlet></servlet>标签中的配置信息。(web.xml文件中servlet的配置信息)</li></ul></li><li><p><strong>一个Servlet对应一个ServletConfig对象。</strong></p></li><li><p>Serlet对象是Tomcat服务器创建，并且ServletConfig对象也是Tomcat服务器创建。并且默认情况下，他们都是在用户发送第一次请求的时候创建。</p></li><li><p>Tomcat服务器调用Servlet对象的init方法的时候需要传一个ServletConfig对象的参数给init方法。</p></li><li><p>ServletConfig接口的实现类是Tomcat服务器给实现的。(Tomcat服务器说的就是WEB服务器。)</p></li><li><p>ServletConfig接口有哪些常用的方法?</p><ul><li><pre><code class="java">public String getInitParameter(String name);//通过初始化参数的name获取valuepublic Enumeration&lt;String&gt; getInitParameterNames();//获取所有的初始化参数的namepublic ServletContext getServletcontext();// 获取servletcontext对象public String getServ1etName();//获取servlet的name<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 以上方法在Servlet类当中，都可以使用this去调用。因为GenericServlet实现了ServletConfig接口。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### ServletContext（重点）（全局）</span><br><span class="line"></span><br><span class="line">- 一个Servlet对象对应一个ServletConfig。100个Servlet对象则对应100个ServletConfig对象。</span><br><span class="line"></span><br><span class="line">- 只要在同一个webapp当中，只要在同一个应用当中，所有的Serlet对象都是共享同一个ServletContext对象的。</span><br><span class="line"></span><br><span class="line">- ServletContext对象在服务器启动阶段创建，在服务器关闭的时候销毁。这就是ServletContext对象的生命周期。ServletContext对象是应用级对象。</span><br><span class="line"></span><br><span class="line">- Tomcat服务器中有一个webapps，这个webapps下可以存放webapp，可以存放多个webapp，假设有100个webapp，那么就有100个ServletContext对象。但是，总之，一个应用，一个webapp肯定是只有一个ServletContext对象。</span><br><span class="line"></span><br><span class="line">- ServletContext被称为Servlet上下文对象。(Serulet对象的四周环境对象。)</span><br><span class="line"></span><br><span class="line">- —个ServletContext对象通常对应的是一个web.xml文件。</span><br><span class="line"></span><br><span class="line">- ServletContext对应显示生活中的什么例子呢?</span><br><span class="line"></span><br><span class="line">  - 一个教室里有多个学生，那么每一个学生就是一个Serulet，这些学生都在同一个教室当中，那么我们可以把这个教室叫做ServletContext对象。那么也就是说放在这个ServletContext对象（环境）当中的数据，在同一个教室当中，物品都是共享的。比如:教室中有一个空调，所有的学生都可以操作。可见，空调是共享的。因为空调放在教室当中。教室就是ServletContext对象。</span><br><span class="line"></span><br><span class="line">- ServletContext是一个接口，Tomcat服务器对ServletContext接口进行了实现。</span><br><span class="line"></span><br><span class="line">  - ServletContext对象的创建也是Tomcat服务器来完成的。启动webapp的时候创建的。</span><br><span class="line"></span><br><span class="line">- ServletContext接口中有哪些常用的方法?</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    public String getInitparameter(String name);//通过初始化参数的name获取value</span><br><span class="line">    public Enumeration&lt;String getInitParamet erNames();//获取所有的初始化参数的name</span><br><span class="line">    </span><br><span class="line">    </span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code class="xml">&lt;!--以上两个方法是ServletContext对象的方法，这个方法获取的是什么信息?是以下的配置信息--&gt;&lt;context-param&gt;    &lt;param-name&gt;pagesize&lt;/param-name&gt;    &lt;param-value&gt;10&lt;/param-value&gt;&lt;/context-param&gt;&lt;context-param&gt;    &lt;param-name&gt;startIndex&lt;/param-name&gt;    &lt;param-value&gt;0&lt;/param-value&gt;&lt;/context-param&gt;&lt;!--注意:以上的配置信息属于应用级的配置信息，一般一个项目中共享的配置信息会放到以上的标签当中。--&gt;&lt;!--如果你的配置信息只是想给某一个servlet作为参考，那么你配置到servlet标签当中即可，使用servletconfig对象来获取。--&gt;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  //获取应用的根路径〈非常重要〉，因为在java源代码当中有一些地方可能会需要应用的相路径，这个方法可以动态获取应用的根路径</span><br><span class="line">  //在java源码当中，不要将应用的根路径写死，因为你永远都不知道这个应用在最终部署的时候，起一个什么名字。</span><br><span class="line">  public String getContextpath();</span><br><span class="line">  // String contextPath = application. getContextPath();</span><br><span class="line">  </span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code class="java">//获取文件的绝对路径(真实路径)public String getRealPath(String path);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  //通过servletcontext对象也是可以记录日志的public void log(string message);</span><br><span class="line">  public void log(String message，Throwable t);</span><br><span class="line">  //这些日志信息记录到哪里了?</span><br><span class="line">  //localhost.2021-11-05.1og</span><br><span class="line">  </span><br><span class="line">  //Tomcat服务器的1ogs目录下都有哪些日志文件?</span><br><span class="line">  //catalina.2021-11-05.1og服务器端的java程序运行的控制台信息。</span><br><span class="line">  //localhost.2021-11-05.log ServletContext对象的log方法记录的日志信息存储到这个文件中。 //localhost_access_log.2021-11-05.txt访问日志</span><br></pre></td></tr></table></figure></code></pre></li><li><p>&#96;&#96;&#96;java<br>&#x2F;&#x2F;servletcontext对象还有另一个名字:应用域（后面还有其他域，例如:请求域、会话域)</p><p>&#x2F;&#x2F;如果所有的用户共享一份数据，并且这个数据很少的被修改，并且这个数据量很少，可以将这些数据放到ServletContext这个应用域中</p><p>&#x2F;&#x2F;为什么是所有用戾共享的数据?不是共享的没有意义。因为ServletContext这个对象只有一个。只有共享的数据放进去才有意义。</p><p>&#x2F;&#x2F;为什么数据量要小?因为数据量比较大的话，太占用堆内存，并且这个对象的生命周期比较长，服务器关闭的时候，这个对象才会被销毁。大数据量会影响服务器的性能。占用内存较小的数据量可以考虑放进去。</p><p>&#x2F;&#x2F;为什么这些共享数据很少的修改,或者说几乎不修改?<br>&#x2F;&#x2F;所有用户共享的数据，如果涉及到修改操作，必然会存在线程并发所带来的安全问题。所以放在ServletContext对象中的数据一般都是只读的。</p><p>&#x2F;&#x2F;数据量小、所有用户共享、又不修改，这样的数据放到ServletContext这个应用域当中，会大大提升效率。因为应用域相当于一个缓存，放到缓存中的数据，下次在用的时候，不需要从数据库中再次获取，大大提升执行效率。</p><p>&#x2F;&#x2F;存(怎么向servletContext应用域中存数据)<br>public void setAttribute(String name，Object value);&#x2F;&#x2F;map.put(k, v)<br>&#x2F;&#x2F;取(怎么从servletContext应用域中取数据〉<br>public Object getAttribute(String name);&#x2F;&#x2F;map.get(k)<br>&#x2F;&#x2F;删(怎么删除servletContext应用域中的数据&gt;<br>public void removeAttribute(String name);&#x2F;&#x2F;map.remove(k)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 注意:以后我们编写Serlet类的时候，实际上是不会去直接继承(GenericServlet类的，因为我们是B/S结构的系统，这种系统是基于HTTP超文本传输协议的，在Servlet规范当中，提供了一个类叫做HttpServlet，它是专门为HTTP协议准备的一个Servlet类。我们编写的Servlet类要继承HttpServlet。(HttpServlet是HTTP协议专用的。)使用HttpServlet处理HTTP协议更便捷。但是你需要直到它的继承结构:</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    jakarta.servlet.servlet（接口〉【爷爷】</span><br><span class="line">    jakarta.servlet.Genericservlet implements servlet（抽象类）【儿子】</span><br><span class="line">    jakarta.servlet.http.HttpServlet extends Genericservlet（抽象类〉【孙子】</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    我们以后编写的servlet要继承Httpservlet类。</span><br></pre></td></tr></table></figure></li></ul></li><li><p>大家到目前为止都接触过哪些缓存机制了?</p><ul><li>堆内存当中的字符串常量池。<ul><li>“abc”先在字符串常星池中查找，如果有，直接拿来用。如果没有则新建，然后再放入字符串常量池。</li></ul></li><li>堆内存当中的整数型常量池。<ul><li>[-128~127]一共256个Integer类型的引用，放在整数型常量池中。没有超出这个范围的话，直接从常量池中取。</li></ul></li><li>连接池(Connection Cache)<ul><li>这里所说的连接池中的连接是java语言连接数据库的连接对象: java.sql.Connection对象。</li><li>JVM是一个进程。MySQL数据库是一个进程。进程和进程之间建立连接，打开通道是很费劲的。是很耗费资源的。怎么办?可以提前先创建好N个Connection连接对象，将连接对象放到一个集合当中，我们把这个放有Connection对象的集合称为连接池。每一次用户连接的时候不需要再新建连接对象，省去了新建的环节，直接从连接池中获取连接对象，大大提升访问效率。</li><li>连接池</li><li>最小连接数</li><li>最大连接数</li><li>连接池可以提高用户的访问效率。当然也可以保证数据库的安全性。|</li></ul></li><li>线程池<ul><li>Tomcat服务器本身就是支持多线程的。</li><li>Tomcat服务器是在用户发送一次请求，就新建一个Thread线程对象吗?<ul><li>当然不是，实际上是在Tomcat服务器启动的时候，会先创建好N多个线程Thread对象，然后将线程对象放到集合当中，称为线程池。用户发送请求过来之后，需要有一个对应的线程来处理这个请求，这个时候线程对象就会直接从线程池中拿，效率比较高。</li><li>所有的WEB服务器，或者应用服务器，都是支持多线程的，都有线程池机制。</li></ul></li></ul></li><li>redis<ul><li>NoSQL数据库。非关系型数据库。缓存数据库。</li></ul></li><li>向ServletContext应用域中存储数据，也等于是将数据存放到缓存cache当中了。</li></ul></li></ul><p>idea的小猫咪</p><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><ul><li><p>什么是协议?</p><ul><li>协议实际上是某些人，或者某些组织提前制定好的一套规范，大家都按照这个规范来，这样可以做到沟通无障碍。</li><li>协议就是一套规范，就是—套标准。由其他人或其他组织来负责制定的。</li><li>我说的话你能听懂，你说的话，我也能听懂，这说明我们之间是有一套规范的，一套协议的，这套协议就是:中国普通话协议。我们都遵守这套协议，我们之间就可以沟通无障碍。</li></ul></li><li><p>什么是HTTP协议?</p><ul><li>HTTP协议:是W3C制定的—种超文本传输协议。</li><li>W3C:<ul><li>万维网联盟组织</li><li>负责制定标准的: HTTP HTML4.0 HTML5 XML DOM等规范都是W3C制定的。</li><li>万维网之父:蒂姆·伯纳斯·李</li></ul></li><li>什么是超文本?<ul><li>超文本说的就是:不是普通文本，比如流媒体:声音、视频、图片等。</li><li>HTTP协议支持:不但可以传送普通字符串，同样支持传递声音、视频、图片等流媒体信息。</li></ul></li><li>这种协议游走在B和S之间。B向S发数据要遵循HTTP协议。S向B发数据同样需要遵循HTTP协议。这样B和S才能解耦合。</li><li>什么是解耦合?<ul><li>B不依赖S。</li><li>S也不依赖B。</li></ul></li><li>B&#x2F;S表示:B&#x2F;S结构的系统（浏览器访问WEB服务器的系统)</li><li>浏览器向WEB服务器发送数据，叫做:请求(request)</li><li>WEB服务器向浏览器发送数据，叫做:响应(response)</li><li>HTTP协议包括:<ul><li>请求协议<br>浏览器向WEB服务器发送数据的时候，这个发送的数据需要遵循—套标准，这套标准中规定了发送的数据具体格式。</li><li>响应协议<br>WEB服务器向浏览器发送数据的时候，这个发送的数据需要遵循—套标准，这套标准中规定了发送的数据具体格式.</li></ul></li><li>HTTP协议就是提前制定好的一种消息模板。<ul><li>不管你是哪个品牌的浏览器，都是这么发。</li><li>不管你是哪个品牌的WEB服务器，都是这么发。</li><li>FF浏览器可以向Tomcat发送请求，也可以向Jetty服务器发送请求。浏览器不依赖具体的服务器品牌。</li><li>WEB服务器也不依赖具体的浏览器品牌。可以是FF浏览器，也可以是Chrome浏览器，可以是IE，都行。</li></ul></li></ul></li><li><p>HTTP的请求协议(B–&gt; S)</p><ul><li><p>HTTP的请求协议包括:4部分</p><ul><li>请求行</li><li>请求头</li><li>空白行</li><li>请求体</li></ul></li><li><p>HTTP的<strong>请求</strong>协议的具体报文：GET请求</p><ul><li>&#96;&#96;&#96;<br>GET &#x2F;servlet05&#x2F;getServlet?username&#x3D;lucy&amp;userpwd&#x3D;1111 HTTP&#x2F;1.1请求行<br>Host: localhost : 8080请求头<br>connection: keep-alive<br>sec-ch-ua: “Google chrome”;v&#x3D;”95”,”chromium “ ; v&#x3D;”95”,”;Not A Brand”;v&#x3D;”99”<br>sec-ch-ua-mobile: ?0<br>sec-ch-ua-platform: “windows”<br>upgrade-Insecure-Requests: 1<br>User-Agent: Mozi11a&#x2F;5.0 (windows NT 10.0; win64; x64) ApplewebKit&#x2F;537.36(KHTML,like Gecko)<br>Chrome&#x2F;95.0.4638.54 safari &#x2F; 537.36<br>Accept:<br>text &#x2F;htm1 ,application&#x2F;xhtm1+xm1, application&#x2F;xm1; q&#x3D;0.9 , image&#x2F;avif , image&#x2F;webp , image&#x2F;apng ,<em>&#x2F;</em>; q&#x3D;0.8,application&#x2F;signed-exchange; v&#x3D;b3; q&#x3D;0.9<br>Sec-Fetch-site: same-origin<br>sec-Fet ch-Mode: navigatesec-Fet ch-User : ?1<br>sec-Fet ch-Dest : document<br>Referer : http: &#x2F; &#x2F;localhost:8080&#x2F;servlet05 &#x2F;index.htm1<br>Accept-Encoding: gzip，deflate，br<br>Accept-Language: zh-CN,zh; q&#x3D;0.9<br>                                                                            空白行<br>                                                                            请求体<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- HTTP的**请求**协议的具体报文：POST请求</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    POST /servlet05/postServlet HTTP/1.1请求行</span><br><span class="line">    Host : localhost :8080请求头</span><br><span class="line">    connection: keep-alivecontent-Length: 25</span><br><span class="line">    cache-control: max-age=O</span><br><span class="line">    sec-ch-ua: &quot;Google chrome&quot; ; v=&quot;95&quot;，&quot;chromium &quot; ; v=&quot;95&quot;，&quot;;Not A Brand&quot;;v=&quot;99&quot;</span><br><span class="line">    sec-ch-ua-mobile: ?o</span><br><span class="line">    sec-ch-ua-platform: &quot;windows&quot;</span><br><span class="line">    upgrade-Insecure-Requests : 1</span><br><span class="line">    Origin: http://localhost : 8080</span><br><span class="line">    content-Type: application/x-www-form-urlencoded</span><br><span class="line">    User-Agent: Mozilla/5.0 (windows NT 10.0; win64; x64) ApplewebKit/537.36(KHTML，7ike Gecko)</span><br><span class="line">    chrome/95.0.4638.54 safari/537.36</span><br><span class="line">    Accept:</span><br><span class="line">    text /htm1, application /xhtm马+xm1,app1ication/xm1;q=0.9,image/avif ,image/webp , image/apng,*/*;q=0.8 , application/signed-exchange;v=b3 ; q=0.9</span><br><span class="line">    sec-Fetch-site: same-origin</span><br><span class="line">    Sec-Fetch-Mode: navigatesec-Fetch-User: ?1</span><br><span class="line">    sec-Fetch-Dest: document</span><br><span class="line">    Referer : http://localhost:8080/servlet05 /index.html</span><br><span class="line">    Accept-Encoding: gzip,deflate，br</span><br><span class="line">    Accept-Language: zh-CN ,zh; q=0.9</span><br><span class="line">    空白行</span><br><span class="line">    username=lisi&amp;userpwd=123请求体</span><br><span class="line">    </span><br><span class="line">    </span><br></pre></td></tr></table></figure></li></ul></li><li><p>请求行</p><ul><li>第一部分:请求方式((7种)<ul><li>get(常用的)</li><li>post(常用的)</li><li>delete</li><li>put </li><li>head</li><li>options</li><li>trace</li></ul></li><li>第二部分：URl<ul><li>什么是URI?统一资源标识符。代表网络中某个资源的名字。但是通过URI是无法定位资源的。</li><li>什么是URL?统一资源定位符。代表网络中某个资源，同时，通过URL是可以定位到该资源的。</li><li>URI和URL什么关系，有什么区别?<ul><li>URL包括URI</li><li><a href="http://localhost:8080/servletO5/index.html%E8%BF%99%E6%98%AFURL%E3%80%82">http://localhost:8080/servletO5/index.html这是URL。</a></li><li>&#x2F;servletO5&#x2F;index.html这是URI。</li></ul></li></ul></li><li>第三部分：HTTP协议版本号</li></ul></li><li><p>请求头</p><ul><li>请求的主机</li><li>主机的端口</li><li>浏览器信息</li><li>平台信息</li><li>cookie等信息</li><li>……</li></ul></li><li><p>空白行</p><ul><li>空白行是用来区分”请求头”和“请求体”</li></ul></li><li><p>请求体</p><ul><li>向服务器发送的具体数据。</li></ul></li></ul></li><li><p>HTTP的响应协议(S–&gt;B)</p><ul><li><p>HTTP的响应协议包括:4部分</p><ul><li>状态行</li><li>响应头</li><li>空白行</li><li>响应体</li></ul></li><li><p>HTTP的<strong>响应</strong>协议的具体报文</p><ul><li>&#96;&#96;&#96;<br>HTTP&#x2F;1.1 200 ok状态行<br>Content-Type: text&#x2F;html; charset&#x3D;UTF-8响应头<br>Content-Length: 160<br>Date: Mon，08 Nov 2021 13:19:32 GMT<br>Keep-Alive: timeout&#x3D;20<br>connection: keep-alive<br>                                                    空白行<!doctype htm1>响应体<html>    <head>        <title>from get servlet</title></head>    <body>        <h1>from get servlet</h1>    </body></html><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 状态行</span><br><span class="line"></span><br><span class="line">    - 三部分组成</span><br><span class="line">      - 第─部分:协议版本号(HTTP/1.1)</span><br><span class="line">      - 第二部分:状态码(HTTP协议中规定的响应状态号。不同的响应结果对应不同的号码。)</span><br><span class="line">        - 200表示请求响应成功，正常结束。</span><br><span class="line">        - 404表示访问的资源不存在，通常是因为要么是你路径写错了，要么是路径写对了，但是服务器中对应的资源并没有启动成功。总之404错误是前端错误。</span><br><span class="line">        - 405表示前端发送的请求方式与后端请求的处理方式不一致时发生:</span><br><span class="line">          - 比如:前端是POST请求，后端的处理方式按照get方式进行处理时，发生405.</span><br><span class="line">          - 比如:前端是GET请求，后端的处理方式按照post方式进行处理时，发生405</span><br><span class="line">          - 500表示服务器端的程序出现了异常。一般会认为是服务器端的错误导致的。</span><br><span class="line">          - 以4开始的，一般是浏览器端的错误导致的。</span><br><span class="line">          - 以5开始的，一般是服务器端的错误导致的。</span><br><span class="line">      - 第三部分:状态的描述信息</span><br><span class="line">        - ok表示正常成功结束。.</span><br><span class="line">        - not found表示资源找不到。</span><br><span class="line"></span><br><span class="line">  - 响应头:</span><br><span class="line"></span><br><span class="line">    - 响应的内容类型</span><br><span class="line">    - 响应的内容长度</span><br><span class="line">    - 响应的时间</span><br><span class="line">    - ....</span><br><span class="line"></span><br><span class="line">  - 空白行:</span><br><span class="line"></span><br><span class="line">    - 用来分隔“响应头&quot;和“响应体&quot;的。</span><br><span class="line"></span><br><span class="line">  - 响应体:</span><br><span class="line"></span><br><span class="line">    - 响应体就是响应的正文，这些内容是一个长的字符串，这个字符串被浏览器渲染，解释并执行，最终展示出效果。</span><br><span class="line"></span><br><span class="line">- 怎么查看的协议内容?</span><br><span class="line"></span><br><span class="line">  - 使用chrome浏览器:E12。然后找到network，通过这个面板可以查看协议的具体内容。</span><br><span class="line"></span><br><span class="line">- ·怎么向服务器发送GET请求，怎么向服务器发送POST请求?</span><br><span class="line"></span><br><span class="line">  - 到目前为止，只有一种情况可以发送POST请求:使用form表单，并且form标签中的method属性值为: method=&quot;post &quot;。</span><br><span class="line">  - 其他所有情况一律都是get请求:</span><br><span class="line">    - 在浏览器地址栏上直接输入URL，敲回车，属于get请求。</span><br><span class="line">    - 在浏览器上直接点击超链接，属于get请求。</span><br><span class="line">    - 使用form表单提交数据时，form标签中没有写method属性，默认就是get</span><br><span class="line">    - 或者使用form的时候，form标签中method属性值为: method=&quot;get&quot;</span><br><span class="line">    - ....</span><br><span class="line"></span><br><span class="line">- GET请求和POST请求有什么区别?</span><br><span class="line"></span><br><span class="line">  -  get请求发送数据的时候，数据会挂在URI的后面，并且在URI后面添加一个?&quot;，&quot;?&quot;后面是数据。这样会导致发送的数据回显在浏览器的地址栏上。(get请求在“请求行&quot;上发送数据)</span><br><span class="line">     - http://localhost:8080/servlet05/getServlet?username=zhangsan&amp;userpwd=1111</span><br><span class="line">  -  post请求发送数据的时候，在请求体当中发送。不会回显到浏览器的地址栏上。也就是说post发送的数据，在浏览器地址栏上看不到。(post在“请求体&quot;当中发送数据)</span><br><span class="line">  -  get请求只能发送普通的字符串。并且发送的字符串长度有限制，不同的浏览器限制不同。这个没有明确的规范。</span><br><span class="line">  -  get请求无法发送大数据量。</span><br><span class="line">  -  post请求可以发送任何类型的数据，包括普通字符串，流媒体等信息:视频、声音、图片。</span><br><span class="line">  -  post请求可以发送大数据量，理论上没有长度限制。</span><br><span class="line">  -  get请求在W3C中是这样说的:get请求比较适合从服务器端获取数据。</span><br><span class="line">  -  post请求在W3C中是这样说的: post请求比较适合向服务器端传送数据。</span><br><span class="line">  -  get请求是安全的。get请求是绝对安全的。为什么?因为get请求只是为了从服务器上获取数据。不会对服务器造成威胁。</span><br><span class="line">  -  post请求是危险的。为什么?因为post请求是向服务器提交数据，如果这些数据通过后门的方式进入到服务器当中，服务器是很危险的。另外post是为了提交数据，所以一般情况下拦截请求的时候，太部分会选择拦截（监听) post请求。</span><br><span class="line">  -  **get请求支持缓存。**</span><br><span class="line">     - https://n.sinaimg.cn/finance/590/w240h350/20211101/b40c-b425eb67cabc342ff5b9dc018b4b00cc.jpg</span><br><span class="line">     - 任何一个get请求最终的“响应结果&quot;都会被浏览器缓存起来。在浏览器缓存当中:</span><br><span class="line">       - 一个get请求的路径a对应一个资源。</span><br><span class="line">       - 一个get请求的路径b   对应   一个资源。</span><br><span class="line">       - 一个get请求的路径c    对应    一个资源。</span><br><span class="line">       - ....</span><br><span class="line">     - 实际上，你只要发送get请求，浏览器做的第一件事都是先从本地浏览器缓存中找，找不到的时候才会去服务器上获取。这种</span><br><span class="line">       缓存机制目的是为了提高用户的体验。</span><br><span class="line">     - 有没有这样一个需求:我们不希望get请求走缓存，怎么办?怎么避免走缓存?我希望每一次这个get请求都去服务器上找资源，我不想从本地浏览器的缓存中取。</span><br><span class="line">       - 只要每一次get请求的请求路径不同即可。</span><br><span class="line">       - https:/n.sinaimg.cn/finance/590/w240h350/20211101/7cabc342ff5b9dc018b4b00cc.jpgt=789789787897898</span><br><span class="line">       - https:/n.sinaimg.cn/finance/590/w240h350/20211101/7cabc342ff5b9dc018b4b00cc.jpgt=789789787897899</span><br><span class="line">       - https:I/n.sinaimg.cn/finance/590/w240h350/20211101/7cabc342ffS5b9dc018b4b00cc.jpg?t=系统毫秒数</span><br><span class="line">       - 怎么解决?可以在路径的后面添加一个每时每刻都在变化的&quot;&#x27;时间戳”，这样，每一次的请求路径都不一样，浏览器就不走缓存了。</span><br><span class="line">  -  **post请求不支持缓存。**(POST是用来修改服务器端的资源的。)</span><br><span class="line">     - post请求之后，服务器′响应的结果&quot;不会被浏览器缓存起来。因为这个缓存没有意义。</span><br><span class="line"></span><br><span class="line">- GET请求和POST请求如何选择，什么时候使用GET请求，什么时候使用POST请求?</span><br><span class="line"></span><br><span class="line">  - 怎么选择GET请求和POST请求呢?衡量标准是什么呢?你这个请求是想获取服务器端的数据，还是想向服务器发送数据。如果你是想从服务器上获取资源，建议使用GET请求，如果你这个请求是为了向服务器提交数据，建议使用POST请求。</span><br><span class="line">  - 大部分的form表单提交，都是post方式，因为form表单中要填写大量的数据，这些数据是收集用户的信息，一般是需要传给服务器，服务器将这些数据保存/修改等。</span><br><span class="line">  - 如果表单中有敏感信息，还是建议适用post请求，因为get请求会回显敏感信息到浏览器地址栏上。(例如:密码信息)。做文件上传，一定是post请求。要传的数据不是普通文本。</span><br><span class="line">  - 其他情况都可以使用get请求。</span><br><span class="line"></span><br><span class="line">- 不管你是get请求还是post请求，发送的请求数据格式是完全相同的，只不过位置不同，格式都是统一的:</span><br><span class="line"></span><br><span class="line">  -  name=value&amp;name=value&amp;name=value&amp;name=value</span><br><span class="line">  -  String s = &quot;name=value&amp;name=value&amp;name=value&amp;name=value&quot;;</span><br><span class="line">  -  s.split(&amp;&quot;)  (只有格式一样小猫咪才能帮我们办事)</span><br><span class="line">  -  name=value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 模板方法设计模式</span><br><span class="line"></span><br><span class="line">- 什么是设计模式?</span><br><span class="line">  - 某个问题的固定的解决方案。(可以被重复使用。)·你知道哪些设计模式?</span><br><span class="line">  - GoF设计模式:</span><br><span class="line">    - 通常我们所说的23种设计模式。(Gang of Eo.ur:……4人组提出的设计模式)单例模式</span><br><span class="line">    - 工厂模式</span><br><span class="line">    - 代理模式</span><br><span class="line">    - 门面模式</span><br><span class="line">    - 责任链设计模式</span><br><span class="line">    - 观察者模式</span><br><span class="line">    - 模板方法设计模式</span><br><span class="line">  - JavaEE设计模式:</span><br><span class="line">    - DAO</span><br><span class="line">    - DIO</span><br><span class="line">    - vo</span><br><span class="line">    - PO</span><br><span class="line">    - pojo</span><br><span class="line">    - ……</span><br><span class="line">  - .....</span><br><span class="line"></span><br><span class="line">- 什么是模板方法设计模式?</span><br><span class="line">  - 在模板类的模板方法当中定义核心算法骨架，具体的实现步骤可以延迟到子类当中完成。</span><br><span class="line">- 模板类通常是一个抽象类，模板类当中的模板方法定义核心算法，这个方法通常是final的(但也可以不是final的)</span><br><span class="line">- 模板类当中的抽象方法就是不确定实现的方法，这个不确定怎么实现的事儿交给子类去做。</span><br><span class="line"></span><br><span class="line">### HttpServlet源码分析</span><br><span class="line"></span><br><span class="line">- HttpServlet类是专门为HTTP协议准备的。比GenericServlet更加适合HTTP协议下的开发。</span><br><span class="line"></span><br><span class="line">- HttpServlet在哪个包下?</span><br><span class="line"></span><br><span class="line">  -  jakarta.servlet.http.HttpServlet</span><br><span class="line"></span><br><span class="line">- 到目前为止我们接触了servlet规范中哪些接口?</span><br><span class="line"></span><br><span class="line">  -  jakarta.servlet.Servlet核心接口(接口)</span><br><span class="line">  -  jakarta.servlet.ServletConfig Servlet配置信息接口(接口)</span><br><span class="line">  -  jakarta.servlet.ServletContext Servlet上下文接口(接口)</span><br><span class="line">  -  jakarta.servlet.ServletRequest Serlet请求接口(接口)</span><br><span class="line">  -  jakarta.servlet.ServletResponse Sevlet响应接口(接口)</span><br><span class="line">  -  jakarta.servlet.ServletException Secvlet异常(类)</span><br><span class="line">  -  jiakarta.s.ervlet.GenericServlet标准通用的Serxlet类(抽象类).</span><br><span class="line"></span><br><span class="line">- http包下都有哪些类和接口呢? jakarta.serlet.http.*;</span><br><span class="line"></span><br><span class="line">  -  jakarta.servlet.http.HttpSerlet(HTTP协议专用的Servlet类，抽象类)</span><br><span class="line">  -  iakarta.servlet.http.HttpServletRequest (HTTP协议专用的请求对象)</span><br><span class="line">  -  iakarta.servlet.http.HttpServletResponse (HTTP协议专用的响应对象)</span><br><span class="line"></span><br><span class="line">- HttpServletReguest对象中封装了什么信息?</span><br><span class="line"></span><br><span class="line">  - HttpServletRequest，简称request对象。</span><br><span class="line">  - HttpServletRequest中封装了请求协议的全部内容。</span><br><span class="line">  - Tomcat服务器(WEB服务器）将“请求协议&quot;中的数据全部解析出来，然后将这些数据全部封装到request对象当中了。</span><br><span class="line">  - 也就是说，我们只要面向HttpServletRequest，就可以获取请求协议中的数据。</span><br><span class="line"></span><br><span class="line">- HttpServletResponse对象是专门用来响应HTTP协议到浏览器的。</span><br><span class="line"></span><br><span class="line">- 回忆Servlet生命周期?</span><br><span class="line"></span><br><span class="line">  - 用户第一次请求</span><br><span class="line">    - Tomcat服务器通过反射机制，调用无参数构造方法。创建Servlet对象。(web.xm/文件中配置的Servlet类对应的对象。)</span><br><span class="line">    - Tomcat服务器调用Servlet对象的init方法完成初始化。</span><br><span class="line">    - Tomcat服务器调用Servlet对象的service方法处理请求。</span><br><span class="line">  - 用户第二次请求</span><br><span class="line">    - Tomcat服务器调用Servlet对象的service方法处理请求。</span><br><span class="line">  - 用户第三次请求</span><br><span class="line">    - Tomcat服务器调用Servlet对象的service方法处理请求。</span><br><span class="line">  - ..........</span><br><span class="line">    - Tomcat服务器调用Servlet对象的service方法处理请求。</span><br><span class="line">  - 服务器关闭</span><br><span class="line">    - Tomcat服务器调用Servlet对象的destroy方法，做销毁之前的准备工作。Tomcat服务器销Servlet对象。</span><br><span class="line"></span><br><span class="line">- HttpServlet源码分析:</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    /*</span><br><span class="line">    通过以上源代码分析:</span><br><span class="line">    假设前端发送的请求是get请求,后端程序员重写的方法是doPost</span><br><span class="line">    假设前端发送的请求是post请求，后端程序员重写的方法是doGet</span><br><span class="line">    会发生什么呢?</span><br><span class="line">    发生405这样的一个错误。</span><br><span class="line">    405表示前端的错误，发送的请求方式不对。和服务器不一致。不是服务器需要的请求方式。</span><br><span class="line">    </span><br><span class="line">    通过以上源代码可以知道:只要HttpServlet类中的doGet方法或doPost方法执行了，必然405.</span><br><span class="line">    </span><br><span class="line">    怎么避免405的错误呢?</span><br><span class="line">    后端重写了doGet方法，前端一定要发get请求。</span><br><span class="line">    后端重写了doPost方法，前端一定要发post请求。</span><br><span class="line">    这样可以避免405错误。</span><br><span class="line">    </span><br><span class="line">    这种前端到底需要发什么样的请求，其实应该后端说了算。后端让发什么方式，前端就得发什么方式。</span><br><span class="line">    </span><br><span class="line">    有的人，你会看到为了避免405错误，在servlet类当中，将doGet和doPost方法都进行了重写。</span><br><span class="line">    这样，确实可以避免405的发生，但是不建议，405错误还是有用的。该报错的时候就应该让他报错。如果你要是同时重写了doGet和doPost，那还不如你直接重写service方法好了。这样代码还能少写一点。</span><br><span class="line">    */</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>我们编写的HelloServlet直接继承HttpServlet，直接重写HttpServlet类中的service()方法行吗?</p><ul><li>可以，只不过你享受不到405错误。享受不到HTTP协议专属的东西。</li></ul></li><li><p>到今天我们终于得到了最终的一个Servlet类的开发步骤:</p><ul><li>第一步:编写一个Servlet类，直接继承HttpSerulet</li><li>第二步:重写doGet方法或者重写doPost方法，到底重写谁，javaweb程序员说了算。</li><li>第三步:将Servlet类配置到web.xml文件当中。</li><li>第四步:准备前端的而面(form表单). form表单中指定请求路径即可.</li></ul></li></ul><h3 id="关于一个web站点的欢迎页面"><a href="#关于一个web站点的欢迎页面" class="headerlink" title="关于一个web站点的欢迎页面"></a>关于一个web站点的欢迎页面</h3><ul><li><p>什么是一个web站点的欢迎页面?</p><ul><li>对于一个webapp来说，我们是可以设置它的欢迎页面的。</li><li>设置了欢迎页面之后，当你访问这个webapp的时候，或者访问这个web站点的时候，没有指定任何′资源路径”，这个时候会默认访问你的欢迎页面。</li><li>我们一般的访问方式是:<ul><li>http:&#x2F;localhost:8080&#x2F;servlet06&#x2F;login.html这种方式是指定了要访问的就是login.html资源。</li></ul></li><li>如果我们访问的方式是:<ul><li>http:&#x2F;localhost:8080&#x2F;servlet06如果我们访问的就是这个站点，没有指定具体的资源路径。它默认会访问谁呢?</li><li>默认会访问你设置的欢迎页面。</li></ul></li></ul></li><li><p>怎么设置欢迎页面呢?</p><ul><li><p>第一步:我在IDEA工具的web目录下新建了一个文件login.html</p></li><li><p>第二步:在web.xml文件中进行了以下的配置</p><ul><li><pre><code class="xml">&lt;we1come-file-list&gt;    &lt;welcome-file&gt;login.html&lt;/welcome-file&gt;&lt;/welcome-file-list&gt;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    - 注意:设置欢迎页面的时候，这个路径不需要以&quot;/&quot;开始。并且这个路径默认是从webapp的根下开始查找。</span><br><span class="line"></span><br><span class="line">  - 第三步:启动服务器，浏览器地址栏输入地址</span><br><span class="line"></span><br><span class="line">    - http://localhost:8080/servletO7</span><br><span class="line"></span><br><span class="line">- 如果在webapp的根下新建一个目录，目录中再给一个文件，那么这个欢迎页该如何设置呢?</span><br><span class="line"></span><br><span class="line">  - 在webapp根下新建page1</span><br><span class="line"></span><br><span class="line">  - 在page1下新建page2目录</span><br><span class="line"></span><br><span class="line">  - 在page2目录下新建page.html页面</span><br><span class="line"></span><br><span class="line">  - 在web.xml文件中应该这样配置</span><br><span class="line"></span><br><span class="line">    - ```xml</span><br><span class="line">      &lt;weTeome-file-list&gt;</span><br><span class="line">      &lt;we1come-file&gt;page1/page2/page. html&lt;/we1come-file&gt;</span><br><span class="line">      &lt;/welcome-file-list&gt;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>注意:路径不需要以”””开始，并且路径默认从webapp的根下开始找。</p></li></ul></li></ul></li><li><p>一个webapp是可以设置多个欢迎页面的</p><ul><li>&#96;&#96;&#96;xml<welcome-file-list>    <welcome-file>page1/page2/page.html    <welcome-file>login.html</welcome-file></welcome-file></welcome-file-list><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 注意:越靠上的优先级越高。找不到的继续向下找。</span><br><span class="line"></span><br><span class="line">- 你有没有注意一件事:当我的文件名设置为index.html的时候，不需要在web.xml文件中进行配置欢迎页面。这是为什么?</span><br><span class="line"></span><br><span class="line">  - 这是因为小猫咪Tomcat服务器已经提前配置好了。</span><br><span class="line"></span><br><span class="line">  - 实际上配置欢迎页面有两个地方可以配置:</span><br><span class="line"></span><br><span class="line">    - 一个是在webapp内部的web.xml文件中。(在这个地方配置的属于局部配置)</span><br><span class="line"></span><br><span class="line">    - 一个是在CATALINA_HOME/conf/web.xml文件中进行配置。(在这个地方配置的属于全局配置)</span><br><span class="line"></span><br><span class="line">      - ```xml</span><br><span class="line">        &lt;welcome-file-list&gt;</span><br><span class="line">                &lt;welcome-file&gt;index.html&lt;/welcome-file&gt;</span><br><span class="line">                &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt;</span><br><span class="line">                &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;</span><br><span class="line">            &lt;/welcome-file-list&gt;</span><br></pre></td></tr></table></figure><ul><li><p>Tomcat服务器的全局欢迎页面是: index.html index.htm index.isp。如果你一个web站点没有设置局部的欢迎页面，Tomcat服务器就会以index.html index.htm index.isp作为一个web站点的欢迎页面。</p></li><li><p>注意原则:局部优先原则。(就近原则)</p></li></ul></li></ul></li><li><p>欢迎页可以是一个S.ervlet吗?</p><ul><li><p>当然可以。</p></li><li><p>你不要多想，欢迎页就是一个资源，既然是一个资源，那么可以是静态资源，也可以是动态资源。。静态资源: index.html welcome.html …..</p></li><li><p>动态资源:Servlet类。</p></li><li><p>步骤:</p><ul><li><p>第一步:写一个Serulet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">we1comeServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request，HttpServletResponse response)</span>throwsServletException,IOException &#123;</span><br><span class="line">        response.setContentType( <span class="string">&quot;text/ htm1&quot;</span>);</span><br><span class="line">        <span class="type">Printwriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        out.print( <span class="string">&quot;&lt;h1&gt;we1come to bjpowernode!&lt;/h1&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>第二步，在web.xml文件中配置servlet</p><ul><li>&#96;&#96;&#96;xml<servlet>    <servlet-name>welcomeservlet</servlet-name>    <servlet-class>com.bjpowernode.javaweb.servlet.welcomeServlet</servlet-class></servlet><servlet-mapping>    <servlet-name>welcomeservlet</servlet-name>    <url-pattern>/fdsa/fds/a/fds /af/ds/af/dsafdsafdsa</url-pattern></servlet-mapping><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 第三步:在web.xml文件中配置欢迎页</span><br><span class="line"></span><br><span class="line">  - ```xml</span><br><span class="line">    &lt;welcome-file-list&gt;</span><br><span class="line">    &lt;welcome-file&gt;fdfa/fds/a/fds/af/ds/af/dsafdsafdsa&lt;/welcome-file&gt;</span><br><span class="line">    &lt;/welcome-file-list&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li></ul><h3 id="关于WEB-INF目录"><a href="#关于WEB-INF目录" class="headerlink" title="关于WEB-INF目录"></a>关于WEB-INF目录</h3><p>在WEB-INF目录下新建了一个文件: welcome.html</p><p>打开浏览器访问: <a href="http://localhost:8080/servlet07/WEB-INF/welcome.html%E5%87%BA%E7%8E%B0%E4%BA%86404%E9%94%99%E8%AF%AF%E3%80%82">http://localhost:8080/servlet07/WEB-INF/welcome.html出现了404错误。</a></p><p>注意:放在WEB-INF目录下的资源是受保护的。在浏览器上不能够通过路径直接访问。所以像HTML、CSS、Simage等静态资源-定要放到WEB-INF目录之外。</p><h3 id="HttpServletRequest接口详解"><a href="#HttpServletRequest接口详解" class="headerlink" title="HttpServletRequest接口详解"></a>HttpServletRequest接口详解</h3><ul><li><p>HttpServletRequest是一个接口，全限定名称: jakarta.serxlet.http.HttpServletRequest. </p></li><li><p>HttpSerletRequest接口是Servlet规范中的一员。</p></li><li><p>HttpServletRequest接口的父接口: ServletRequest</p><ul><li><pre><code class="java">public interface HttpServletRequest extends ServletRequest &#123;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- HttpServletRequest接口的实现类谁写的? HttpServletRequest对象是谁给创建的?</span><br><span class="line"></span><br><span class="line">  - 通过测试: org.apache.catalina.connector.RequestFacade实现了HttpSerletReguest接口</span><br><span class="line"></span><br><span class="line">    - ```java</span><br><span class="line">      public class RequestFacade implements HttpServletRequest &#123;&#125;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>测试结果说明:Tomcat服务器(WEB服务器、WEB容器)实现了HttpoServletRequest接口，还是说明了Tomcat服务器实现了<br>Servlet规范。而对于我们javaweb程序员来说，实际上不需要关心这个，我们只需要面向接口编程即可。我们关心的是<br>HttpServletReguest接口中有哪些方法，这些方法可以完成什么功能! ! ! !</p></li></ul></li><li><p>HttpServletRequest对象中都有什么信息?都包装了什么信息?</p><ul><li>HittpServletRequest对象是Tomcat服务器负责创建的。这个对象中封装了什么信息?封装了HTTP的请求协议。</li><li>实际上是用户发送请求的时候，遵循了HTTP协议，发送的是HTTP的请求协议，<strong>Tomcat服务器将HTTP协议中的信息以及数据全部解析出来，然后Tomcat服务器把这些信息封装到HttpServletReguest对象当中，传给了我们javaweb程序员。</strong></li><li>javaweb程序员面向HttpServletRequest接口编程，调用方法就可以获取到请求的信息了。</li></ul></li><li><p>request和response对象的生命周期?</p><ul><li>request对象和response对象，一个是请求对象，一个是响应对象。这两个对象只在当前请求中有效。</li><li>一次请求对应一个request。</li><li>两次请求则对应两个request。</li><li>…..</li></ul></li><li><p>HttpServletRequest接口中有哪些常用的方法?</p><ul><li><p>怎么获取前端浏览器用户提交的数据?</p><ul><li>&#96;&#96;&#96;java<br>String getParameter (String name)这个是获取Map<br>Map&lt;String , String[]&gt; getParameterMap()这个是获取Map集合中所有的key<br>Enumeration<String> getParameterNames()根据key获取Map集合的value<br>string[] getParametervalues(java.lang.String name)获取value这个一维数组当中的第一个元素。这个方法最常用。<br>&#x2F;&#x2F;以上的4个方法，和获取用户提交的数据有关系。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 思考:如果是你，前端的form表单提交了数据之后，你准备怎么存储这些数据，你准备采用什么样的数据结构去存储这些数据呢?</span><br><span class="line"></span><br><span class="line">  - 前端提交的数据格式: username=abc&amp;userpwd=111&amp;aihao=s&amp;aihao=d &amp;aihao-tt</span><br><span class="line"></span><br><span class="line">  - 我会采用Map集合来存储:</span><br><span class="line"></span><br><span class="line">    - ```</span><br><span class="line">      Map&lt;String , String&gt;</span><br><span class="line">      key存储string</span><br><span class="line">      value存储string</span><br><span class="line">      这种想法对吗?不对。</span><br><span class="line">      如果采用以上的数据结构存储会发现key重复的时候value覆盖。</span><br><span class="line">      keyvalue</span><br><span class="line">      -----------------------------------------</span><br><span class="line">      usernameabc</span><br><span class="line">      userpwd111</span><br><span class="line">      aihao5</span><br><span class="line">      aihaod</span><br><span class="line">      aihaott</span><br><span class="line">      这样是不行的，因为map的key不能重复。</span><br><span class="line">      Map&lt;String,String[]&gt;</span><br><span class="line">      key存储String</span><br><span class="line">      value存储String[]</span><br><span class="line">      keyvalue</span><br><span class="line">      ------------------------------------------</span><br><span class="line">      username&#123; &quot;abc&quot;&#125;</span><br><span class="line">      userpwd&#123; &quot;111&quot;&#125;</span><br><span class="line">      aihao&#123; &quot;s&quot; ,&quot;d&quot;, &quot;tt&quot;&#125;</span><br></pre></td></tr></table></figure><ul><li>注意:前端表单提交数据的时候，假设提交了120这样的“数字”，其实是以字符串”120”的方式提交的，所以服务器端获取到的一定是一个字符串的”120”，而不是一个数字。(前端永远提交的是字符串，后端获取的也永远是字符串。)</li></ul></String></li></ul></li><li><p>request对象实际上又称为”请求域”对象。</p><ul><li><p>应用域对象是什么?</p></li><li><p>ServletContext (Servlet上下文对象。)</p></li><li><p>什么情况下余考虑向ServletContext这个应用域当中绑定数据呢?</p><ul><li>第一:所有用户共享的数据。</li><li>第二:这个共享的数据量很小。</li><li>第三:这个共享的数据很少的修改操作。</li><li>在以上三个条件都满足的情况下，使用这个应用域对象，可以大大提高我们程序执行效率。</li><li><strong>实际上向应用域当中绑定数据，就相当于把数据放到了缓存(Cache)当中，然后用户访问的时候直接从缓存中取，减少IO的操作，大大提升系统的性能，所以缓存技术是提高系统性能的重要手段。</strong></li></ul></li><li><p>你见过哪些缓存技术呢?</p><ul><li>字符串常量池</li><li>整数型常量池[-128~127]，但凡是在这个范围当中的Integer对象不再创建新对象，直接从这个整数型常量池中<br>获取。大大提升系统性能。</li><li>数据库连接池(提前创建好N个连接对象，将连接对象放到集合当中，使用连接对象的时候，直接从缓存中拿。省去了连接对象的创建过程。效率提升。)</li><li>线程池(Tomcat服务器就是支持多线程的。所谓的线程池就是提前先创建好N个线程对象，将线程对象存储到集合中，然后用户请求过来之后，直接从线程池中获取线程对象，直接拿来用。提升系统性能)</li></ul></li><li><p>后期你还会学习更多的缓存技术，例如: redis、mongoDB.……</p></li><li><p>ServletContext当中有三个操作域的方法</p><ul><li><p>&#96;&#96;&#96;java<br>void setAttribute(String name，Object obj);&#x2F;&#x2F;向域当中绑定数据。<br>Object getAttribute(String name);&#x2F;&#x2F;从域当中根据name获取数据。<br>void removeAttribute(String name);&#x2F;&#x2F;将域当中绑定的数据移除</p><p>&#x2F;&#x2F;以上的操作类似于Map集合的操作。<br>Map&lt;String，Object&gt; map;<br>map. put ( “name “, obj);&#x2F;&#x2F; 向map集合中放key和value<br>Object obj &#x3D; map.get(“name “); &#x2F;&#x2F; 通过map集合的key获取value<br>map.remove(“name “);&#x2F;&#x2F;通过Map集合的key删除key和value这个键值对。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- “请求域&quot;对象</span><br><span class="line"></span><br><span class="line">  - “请求域&quot;对象要比&quot;应用域&quot;对象范围小很多。生命周期短很多。请求域只在一次请求内有效。</span><br><span class="line"></span><br><span class="line">  - 一个请求对象request对应一个请求域对象。一次请求结束之后，这个请求域就销毁了。</span><br><span class="line"></span><br><span class="line">  - 请求域对象也有这三个方法:</span><br><span class="line"></span><br><span class="line">    - ```java</span><br><span class="line">      void setAttribute(String name，Object obj);//向域当中绑定数据。</span><br><span class="line">      Object getAttribute(String name);//从域当中根据name获取数据。</span><br><span class="line">      void removeAttribute(String name); //将域当中绑定的数据移除</span><br></pre></td></tr></table></figure></li></ul></li><li><p>请求域和应用域的选用原则?</p><ul><li>尽量使用小的域对象，因为小的域对象占用的资源较少。</li></ul></li><li><p>跳转</p><ul><li><p>转发(一次请求)</p><ul><li><p>&#96;&#96;&#96;java<br>&#x2F;&#x2F;第一步:获取请求转发器对象<br>RequestDispatcher dispatcher &#x3D; request. getRequestDispatcher(“&#x2F;b”);<br>&#x2F;&#x2F;第二步:调用转发器的forward方法完成跳转&#x2F;转发<br>dispatcher .forward(request ,response) ;</p><p>&#x2F;&#x2F;第一步和第二步代码可以联合在一起。<br>request.getRequestDispatcher(“&#x2F;b”).forward(request,response);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 两个Servlet怎么共享数据?</span><br><span class="line"></span><br><span class="line">  - 将数据放到ServletContext应用域当中，当然是可以的，但是应用域范围太大，占用资源太多。不建议使用。</span><br><span class="line">  - 可以将数据放到request域当中，然后AServlet转发到BServlet，保证AServlet和BServlet在同一次请求当中，这样就可以做到两个Servlet，或者多个Servlet共享同一份数据。</span><br><span class="line"></span><br><span class="line">- 转发的下一个资源必须是一个Servlet吗?</span><br><span class="line"></span><br><span class="line">  - 不一定，只要是Tomcat服务器当中的合法资源，都是可以转发的。例如:html....</span><br><span class="line">  - 注意:转发的时候，路径的写法要注意，转发的路径以&quot;&quot;开始，不加项目名。关于</span><br><span class="line"></span><br><span class="line">- request对象中两个非常容易混淆的方法:</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    // uri?username=zhangsan&amp;userpwd=123&amp;sex=1</span><br><span class="line">    String username = request.getParameter (&quot;username&quot;);</span><br><span class="line">    //之前一定是执行过:request.setAttribute( &quot;name&quot;, new objectO)</span><br><span class="line">    Object obj = request.getAttribute( &quot;name &quot; );</span><br><span class="line">    </span><br><span class="line">    //以上两个方法的区别是什么?</span><br><span class="line">    //第一个方法:获取的是用户在浏览器上提交的数据。</span><br><span class="line">    //第二个方法:获取的是请求域当中绑定的数据。</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>HttpServletRequest接口的其他常用方法</p><ul><li><p>&#96;&#96;&#96;java<br>&#x2F;&#x2F;获取客户端的IP地址<br>String remoteAddr &#x3D; request.getRemoteAddr() ;</p><p>&#x2F;&#x2F;get请求在请求行上提交数据。<br>&#x2F;&#x2F;post请求在请求体中提交数据。<br>&#x2F;&#x2F;设置请求体的字符集。(显然这个方法是处理POST请求的乱码问题。这种方式并不能解决get请求的乱码问题。)<br>&#x2F;&#x2F; Tomcat10之后，request请求体当中的字符集黑认就是UTF-8，不需要设置字符集，不会出现乱码问题。<br>&#x2F;&#x2F;Tomcat9前〈包括9在内)，如果前端请求体提交的休中文，后端获取之后出现乱码，怎么解决这个乱码?执行以下代码。<br>request.setCharacterEncoding(“UTF-8”);</p><p>&#x2F;&#x2F;在Tomcat9之前（包括9）,响应中文也是有乱码的，怎么解决这个响应的乱码?<br>response.setContentType(“text &#x2F;html ; charset&#x3D;UTF-8”);<br>&#x2F;&#x2F;在Tomcat10之后，包括10在内，响应中文的时候就不在出现乱码问题了。以上代码就不需要设置UTF-8了。</p><p>&#x2F;&#x2F;注意一个细节<br>&#x2F;&#x2F;在Tomcat10包括10在内之后的版本，中文将不再出现乱码。(这也体现了中文地位的提升。)</p><p>&#x2F;&#x2F;get请求乱码问题怎么解决?<br>&#x2F;&#x2F;get请求发送的时候,数据是在请求行上提交的,不是在请求体当中提交的。<br>&#x2F;&#x2F;get请求乱码怎么解决<br>&#x2F;&#x2F;方案:修改CATALINA_HOME&#x2F;conf&#x2F;server.xml配置文件</p><Connector uriencoding="UTF-8">//注意:从Tomcat8之后，URIEncoding的黑f认值就是UTF-8，所以GET请求也没有乱码问题了。    <p>&#x2F;&#x2F;获取应用的根路径<br>String contextPath &#x3D; request.getcontextPath(;</p><p>&#x2F;&#x2F;获取请求方式<br>String method &#x3D; request.getMethod(;</p><p>&#x2F;&#x2F;获取请求的URI<br>String uri &#x3D; request.getRequestURI(); &#x2F;&#x2F; &#x2F;aaa&#x2F;testRequest</p><p>&#x2F;&#x2F;获取servlet path<br>String servletPath &#x3D; request. getServletPath(;&#x2F;&#x2F;&#x2F;testRequest</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 在一个web应用中应该如何完成资源的跳转</span><br><span class="line"></span><br><span class="line">- 在一个web应用中通过两种方式，可以完成资源的跳转:</span><br><span class="line"></span><br><span class="line">  - 第一种方式:转发</span><br><span class="line">  - 第二种方式:重定向</span><br><span class="line"></span><br><span class="line">- 转发和重定向有什么区别?</span><br><span class="line"></span><br><span class="line">  - 代码上有什么区别?</span><br><span class="line"></span><br><span class="line">    - 转发</span><br><span class="line"></span><br><span class="line">      - ```java</span><br><span class="line">        //获取请求转发器对象</span><br><span class="line">        RequestDispatcher dispatcher = request.getRequestDispatcher (&quot; /dept/list&quot;);</span><br><span class="line">        //调用请求转发器对象的forward方法完成转发</span><br><span class="line">        dispatcher .forward(request, response);</span><br><span class="line">        //合并一行代码</span><br><span class="line">        request.getRequestDispatcher(&quot;/dept/1ist&quot;).forward(request，response);</span><br><span class="line">        //转发的时候是一次请求,不管你转发了多少次。都是一次请求。</span><br><span class="line">        //AServlet转发到BServlet，再转发到cservlet，再转发到DServlet，不管转发了多少次，都在同一个request当中。</span><br><span class="line">        //这是因为调用forwar d方法的时候，会将当前的request和r esponse对象传递给下一个servlet。</span><br></pre></td></tr></table></figure></Connector></li></ul></li><li><p>重定向</p><ul><li>&#96;&#96;&#96;java<br>&#x2F;&#x2F;注意:路径上要加一个项目名。为什么?<br>&#x2F;&#x2F;浏览器发送请求，请求路径上是需要添加项目名的。<br>&#x2F;&#x2F;以下这一行代码会将请求路径”&#x2F;oa&#x2F;dept&#x2F;list”发送给浏览器<br>&#x2F;&#x2F;浏览器会自发的向服务器发送一次全新的请求:&#x2F;oa&#x2F;dept&#x2F;listresponse.sendRedirect(“ &#x2F; oa&#x2F;dept&#x2F;list”);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 形式上有什么区别?</span><br><span class="line"></span><br><span class="line">    - 转发(一次请求)</span><br><span class="line">      - 在浏览器地址栏上发送的请求是: http://localhost:8080/servlet10/a，最终请求结束之后，浏览器地址栏上的地址还是这个。没变。</span><br><span class="line">    - 重定向(两次请求)</span><br><span class="line">      - 在浏览器地址栏上发送的请求是: http:/localhost:8080/servlet10/a，最终在浏览器地址栏上显示的地址是: http;:/localhost:8080/servlet10/b</span><br><span class="line"></span><br><span class="line">  - 转发和重定向的本质区别?</span><br><span class="line"></span><br><span class="line">    - **转发:是由WEB服务器来控制的。A资源跳转到B资源，这个跳转动作是Tomcat服务器内部完成的。**</span><br><span class="line">    - **重定向:是浏览器完成的。具体跳转到哪个资源，是浏览器说了算。（浏览器发送请求需要加资源名【/XMM】）**</span><br><span class="line"></span><br><span class="line">  - 使用一个例子去描述这个转发和重定向</span><br><span class="line"></span><br><span class="line">    - 借钱（转发)</span><br><span class="line">      - 杜老师没钱了，找张三借钱，其实张三没有钱，但是张三够义气，张三自己找李四借了钱，然后张三把这个钱给了杜老师，杜老师不知道这个钱是李四的，杜老师只求了一个人。杜老师以为这个钱就是张三的。</span><br><span class="line">    - 借钱（重定向)</span><br><span class="line">      - 杜老师没钱了，找张三借钱，张三没有钱，张三有一个好哥们，叫李四，李四是个富二代，于是张三将李四的家庭住址告诉了杜老师，杜老师按照这个地址去找到李四，然后从李四那里借了钱。显然杜老师在这个过程中，求了两个人。并且杜老师知道最终这个钱是李四借给俺的。</span><br><span class="line"></span><br><span class="line">- 转发和重定向应该如何选择?什么时候使用转发，什么时候使用重定向?</span><br><span class="line"></span><br><span class="line">  - 如果在上一个Serlet当中向request域当中绑定了数据，希望从下一个Serulet当中把request域里面的数据取出来，使用转发机制。</span><br><span class="line">  - 剩下所有的请求均使用重定向。(重定向使用较多。)</span><br><span class="line"></span><br><span class="line">- 跳转的下一个资源有没有要求呢?必须是一个Servlet吗?</span><br><span class="line"></span><br><span class="line">  - 不一定，跳转的资源只要是服务器内部合法的资源即可。包括: Servlet、lSP、HTML...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 将oa项目中的资源跳转修改为合适的跳转方式</span><br><span class="line"></span><br><span class="line">- 删除之后，重定向</span><br><span class="line">- 修改之后，重定向</span><br><span class="line">- 保存之后，重定向 (保存后会刷新页面，会重新发送相同的请求，导致多条记录，所以必须使用重定向)</span><br><span class="line">- 重定向:</span><br><span class="line">  - 成功</span><br><span class="line">  - 失败</span><br><span class="line"></span><br><span class="line">### Servlet注解，简化配置</span><br><span class="line"></span><br><span class="line">- 分析oa项目中的web.xml文件</span><br><span class="line"></span><br><span class="line">  - 现在只是一个单标的CRUD，没有复杂的业务逻辑，很简单的一丢丢功能。web.xml文件中就有如此多的配置信息。如果采用这种方式，对于一个大的项目来说，这样的话web.xml文件会非常庞大，有可能最终会达到几十兆。</span><br><span class="line">  - 在web.xml文件中进行servlet信息的配置，显然开发效率比较低，每一个都需要配置一下。</span><br><span class="line">  - 而且在web.xml文件中的配置是很少被修改的，所以这种配置信息能不能直接写到java类当中呢?可以的。</span><br><span class="line"></span><br><span class="line">- Servlet3.0版本之后，推出了各种Servlet基于注解式开发。优点是什么?</span><br><span class="line"></span><br><span class="line">  - 开发效率高，不需要编写大量的配置信息。直接在java类上使用注解进行标注。</span><br><span class="line">  - web.xml文件体积变小了。</span><br><span class="line"></span><br><span class="line">- 并不是说注解有了之后，web.xml文件就不需要了:</span><br><span class="line"></span><br><span class="line">  - 有一些需要变化的信息，还是要配置到web.xml文件中。一般都是注解+配置文件的开发模式</span><br><span class="line">  - —些不会经常变化修改的配置建议使用注解。一些可能会被修改的建议写到配置文件中。</span><br><span class="line"></span><br><span class="line">- 我们的第一个注解:</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    jakarta.servlet.annotation.webserv1et</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>在Servlet类上使用:@WebServlet，WebServlet注解中有哪些属性呢?</p><ul><li>name属性:用来指定Servlet的名字。等同于:<servlet-name></servlet-name></li><li>urlPatterns属性:用来指定Servlet的映射路径。可以指定多个字符串。<url-pattern></url-pattern></li><li>loadOnStartUJp属性:用来指定在服务器启动阶段是否加载该Servlet。等同于:<load-on-startup></load-on-startup></li><li>value属性:当注解的属性名是value的时候，使用注解的时候，value属性名是可以省略的。</li><li>注意:不是必须将所有属性都写上，只需要提供需要的。(需要什么用什么。)</li></ul></li><li><p>注解对象的使用格式:</p><ul><li>@注解名称(属性名&#x3D;属性值,属性名&#x3D;属性值,属性名&#x3D;属性值….)</li></ul></li></ul></li></ul><h3 id="使用模板方法设计模式优化oa项目"><a href="#使用模板方法设计模式优化oa项目" class="headerlink" title="使用模板方法设计模式优化oa项目"></a>使用模板方法设计模式优化oa项目</h3><ul><li>上面的注解解决了配置文件的问题。但是现在的oa项目仍然存在一个比较臃肿的问题。<ul><li>一个单标的CRUD，就写了6个Serylet。如果一个复杂的业务系统，这种开发方式，显然会导致类爆炸。(类的数量太大。)。</li><li>怎么解决这个类爆炸问题?可以使用模板方法设计模式。</li></ul></li><li>怎么解决类爆炸问题?<ul><li>以前的设计是一个请求一个Servlet类。1000个请求对应1000个Servlet类。导致类爆炸。</li><li>可以这样做:一个请求对应一个方法。一个业务对应一个Serulet类。</li><li>处理部门相关业务的对应一个DeptServlet。处理用户相关业务的对应一个UserServlet。处理银行卡卡片业务对应一个CardServlet.</li></ul></li></ul><h3 id="分析使用纯粹Servlet开发web应用的缺陷"><a href="#分析使用纯粹Servlet开发web应用的缺陷" class="headerlink" title="分析使用纯粹Servlet开发web应用的缺陷"></a>分析使用纯粹Servlet开发web应用的缺陷</h3><ul><li>在Servlet当中编写HTML&#x2F;CSS&#x2F;JavaScript等前端代码。存在什么问题?<ul><li>java程序中编写前端代码，编写难度大。麻烦。</li><li>java程序中编写前端代码，显然程序的耦合度非常高。</li><li>java程序中编写前端代码，代码非常不美观。</li><li>java程序中编写前端代码，维护成本太高。(非常难于维护)<ul><li>修改小小的一个前端代码，只要有改动，就需要重新编译java代码，生成新的class文件，打一个新的war包,重新发布</li></ul></li></ul></li><li>思考一下，如果是你的话，你准备怎么解决这个问题?<ul><li>思路很重要。使用什么样的思路去做、去解决这个问题<ul><li>上面的那个Servlet (Java程序)能不能不写了，让机器自动生成。我们程序员只需要写这个Serlet程序中的′前端的那段代码”，然后让机器将我们写的”前端代码”自动翻译生成”Serulet这种java程序”。然后机器再自动将”iava”程序编译生成”class”文件。然后再使用JMM调用这个class中的方法。</li></ul></li></ul></li></ul><h3 id="关于B-x2F-S结构系统的会话机制（session）"><a href="#关于B-x2F-S结构系统的会话机制（session）" class="headerlink" title="关于B&#x2F;S结构系统的会话机制（session）"></a>关于B&#x2F;S结构系统的会话机制（session）</h3><ul><li>什么是会话?<ul><li>会话对应的英语单词: session</li><li>用户打开浏览器，进行一系列操作，然后最终将浏览器关闭，这个整个过程叫做:一次会话。会话在服务器端也有一个对应的java对象，这个java对象叫做:session。</li><li>回顾：什么是一次请求:用户在浏览器上点击了一下，然后到页面停下来，可以粗略认为是一次请求。请求对应的服务器端的java对象是: request。</li><li><strong>一个会话当中包含多次请求。(一次会话对应N次请求。</strong>)</li></ul></li><li>在java的servlet规范当中，session对应的类名: HttpSession (jarkata.servlet.http.HttpSession)</li><li>session机制属于B&#x2F;S结构的一部分。如果使用php语言开发WEB项目，同样也是有session这种机制的。session机制实际上是一个规范。然后不同的语言对这种会话机制都有实现。</li><li>session对象最主要的作用是:保存会话状态。(用户登录成功了，这是一种登录成功的状态，你怎么把登录成功的状态一直保存下来呢?使用session对象可以保留会话状态。)</li><li>为什么需要session对象来保存会话状态呢?<ul><li>因为HTTP协议是一种无状态协议。</li><li>什么是无状态:请求的时候，B和S是连接的，但是请求结束之后，连接就断了。为什么要这么做?HTTP协议为什么要设计成这样?因为这样的无状态协议，可以降低服务器的压力。请求的瞬间是连接的，请求结束之后，连接断开，这样服务器压力小,</li><li>只要B和S断开了，那么关闭浏览器这个动作，服务器知道吗?<ul><li>不知道。服务器是不知道浏览器关闭的。</li></ul></li></ul></li><li>张三打开一个浏览器A，李四打开一个浏览器B，访问服务器之后，在服务器端会生成:<ul><li>张三专属的session对象</li><li>李四专属的session对象</li></ul></li><li>为什么不使用request对象保存会话状态?为什么不使用ServletContext对象保存会话状态?<ul><li>request.setAttribute()存，request.getAttribute()取，ServletContext也有这个方法。request是请求域。ServletContext是应用域。</li><li>request是一次请求一个对象。</li><li>ServletContext对象是服务器启动的时候创建，服务器关闭的时候销毁，这个ServletContext对象只有一个。</li><li>ServletContext对象的域太大。</li><li>ServletContext对象是服务器启动的时候创建，服务器关闭的时候销毁，这个SeruletContext对象只有一个。</li><li>ServletContext对象的域太大。</li><li>request请求域(HttpServletReguest) . session会话域(HlttpSession)、 application域.(SeruletContext)</li><li>request &lt; session &lt; application</li></ul></li><li>思考一下: session对象的实现原理。<ul><li>HttpSession session &#x3D; request.getSession();</li><li>这行代码很神奇。张三访问的时候获取的session对象就是张三的。李四访问的时候获取的session对象就是李四的。</li></ul></li><li>session的实现原理:<ul><li>ISESSIONID&#x3D;xXXXXX这个是以Cookie的形式保存在浏览器的内存中的。浏览器只要关闭。这个cookie就没有了。</li><li>session列表是一个Map,map的key是sessionid,map的value是session对象。</li><li>用户第一次请求，服务器生成session对象，同时生成id，将id发送给浏览器。</li><li>用户第二次请求，自动将浏览器内存中的id发送给服务器，服务器根据id查找session对象。</li><li>关闭浏览器，内存消失，cookie消失,s.essionid消失，会话等同于结束。</li></ul></li><li>Cookie禁用了，session还能找到吗?<ul><li>cookie禁用是什么意思?服务器正常发送cookie给浏览器，但是浏览器不要了。拒收了。并不是服务器不发了。。找不到了。每一次请求都会获取到新的session对象。</li><li>cookie禁用了, session机制还能实现吗?<ul><li>可以。需要使用URL重写机制。</li><li>http:&#x2F;localhost:8080&#x2F;servlet12&#x2F;test&#x2F;session;jsessionid&#x3D;19D1C99560DCBF84839FA43D58F56E16</li><li>URL重写机制会提高开发者的成本。开发人员在编写任何请求路径的时候，后面都要添加一个sessionid，给开发带来了很大的难度，很大的成本。所以大部分的网站都是这样设计的:你要是禁用cookie，你就别用了。</li></ul></li></ul></li><li>总结—下到目前位置我们所了解的域对象:<ul><li>request (对应的类名:HttpServletRequest)<ul><li>请求域（请求级别）</li></ul></li><li>session (对应的类名:Httpsession)<ul><li>会话域（用户级别）</li></ul></li><li>application(对应的类名:ServletContext)<ul><li>应用域（项目级别的，所以用户共享的）</li></ul></li><li>这三个域对象的大小关系<ul><li>request &lt; session &lt; application</li></ul></li><li>他们三个域对象都有以下三个公共的方法:<ul><li>setAttribute(向域当中绑定数据)</li><li>getAttribute (从域当中获取数据)</li><li>removeAttribute (删除域当中的数据)</li></ul></li><li>使用原则：尽量使用小的域</li></ul></li><li>session掌握之后，我们怎么解决oa项目中的登录问题，怎么能让登录起作用。<ul><li>登录成功之后，可以将用户的登录信息存储到session当中。也就是说session中如果有用户的信息就代表用户登录成功了。session中没有用户信息，用户没有登录过。则跳转到登录页面。</li></ul></li><li>销毁session对象:<ul><li><strong>session.invalidate();</strong></li></ul></li><li><h2 id><a href="#" class="headerlink" title="- "></a>- </h2>- </li><li><strong>浏览器关闭的时候，服务器无法检测到浏览器关闭了，所以session的销毁要依靠session超时机制，但也有一种可能“系统提供了“安全退出”，用户可以点击这个按钮，这样浏览器就知道你退出了，然后服务器会自动销毁session对象</strong><ul><li><img src="/2022/10/26/JAVAWEB-2/2.png" alt="2"></li></ul></li></ul><p><img src="/2022/10/26/JAVAWEB-2/1.png" alt="image-20221024134724850"></p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><ul><li><p>session的实现原理中，每一个session对象都会关联一个sessionid，例如:</p><ul><li>JSESSIONID&#x3D;41C481F0224664BDB28E95081D23D5B8</li><li>以上的这个键值对数据其实就是cookie对象。</li><li>对于session关联的cookie来说，这个cookie是被保存在浏览器的“运行内存”当中。</li><li>只要浏览器不关闭，用户再次发送请求的时候，会自动将运行内存中的cookie发送给服务器。</li><li>例如，这个Cookie: JSESSIONID&#x3D;41C481F0224664BDB28E95081D23D5B8就会再次发送给服务器。</li><li>服务器就是根据41C481F0224664BDB28E95081D23D5B8这个值来找到对应的session对象的。</li></ul></li><li><p>cookie怎么生成? cookie保存在什么地方? cookie有啥用?浏览器什么时候会发送cookie，发送哪些cookie给服务器? ?? ? ? ? ?.</p></li><li><p>cookie最终是保存在浏览器客户端上的。</p><ul><li>可以保存在运行内存中。(浏览器只要关闭cookie就消失了。)</li><li>也可以保存在硬盘文件中。(永久保存。)</li></ul></li><li><p>cookie有啥用呢?</p><ul><li>cookie和session机制其实都是为了保存会话的状态。</li><li>cookie是将会话的状态保存在浏览器客户端上。(cookie数据存储在浏览器客户端上的。)</li><li>session是将会话的状态保存在服务器端上。(session对象是存储在服务器上。)</li><li>为什么要有cookie和session机制呢?因为HTTP协议是无状态无连接协议。</li></ul></li><li><p>cookie的经典案例</p><ul><li>京东商城，在未登录的情况下，向购物车中放几件商品。然后关闭商城，再次打开浏览器，访问京东商城的时候，购物车中的商品还在，这是怎么做的我没有登录，为什么购物车中还有商品呢?<ul><li>将购物车中的商品编号放到cookie当中,cookie保存在硬盘文件当中。这样即使关闭浏览器。硬盘上的cookie还在。下一次再打开京东商城的时候查看购物车的时候，会自动读取本地硬盘中存储的cookie，拿到商品编号，动态展示购物车中的商品。<ul><li>京东存储购物车中商品的cookie可能是这样的: productlds&#x3D;xXxxx,Y,zzz,kkkk</li><li>注意:cookie如果清除掉，购物车中的商品就消失了。</li></ul></li></ul></li><li>126邮箱中有—个功能:十天内免登录<ul><li>这个功能也是需要cookie来实现的。</li><li>怎么实现的呢?<ul><li>用户输入正确的用户名和密码，并且同时选择十天内兔登录。登录成功后。浏览器客户端会保存一个cookie，这个cookie中保存了用户名和密码等信息，这个cookie是保存在硬盘文件当中的，十天有效。在十天内用户再次访问126的时候，浏览器自动提交126的关联的cookie给服务器,服务器接收到cookie之后，获取用户名和密码，验证，通过之后，自动登录成功。</li><li>怎么让cookie失效?<ul><li>十天过后自动失效。</li><li>或者改密码。</li><li>或者在客户端浏览器上清除cookie。</li></ul></li></ul></li></ul></li></ul></li><li><p>cookie机制和session机制其实都不属于java中的机制，实际上cookie机制和session机制都是HTTP协议的一部分。php开发中也有cookie和session机制，只要是你是做web开发，不管是什么编程语言，cookie和session机制都是需要的。</p></li><li><p>HTTP协议中规定:任何一个cookie都是由name和value组成的。name和value都是字符串类型的。</p></li><li><p>在java的servlet中，对cookie提供了哪些支持呢?</p><ul><li>提供了一个Cookie类来专门表示cookie数据。jakarta.servlet.http.Cookie;</li><li>java程序怎么把cookie数据发送给浏览器呢?  <strong>response.addCookie(cookie);</strong></li></ul></li><li><p><strong>在HTTP协议中是这样规定的:当浏览器发送请求的时候，会自动携带该path下的cookie数据给服务器。</strong>(URL)</p></li><li><p>关于cookie的有效时间</p><ul><li>怎么用java设置cookie的有效时间<ul><li>cookie.setMaxAge(60 * 60);设置cookie在—小时之后失效。</li></ul></li><li>没有设置有效时间:默认保存在浏览器的运行内存中，浏览器关闭则cookie消失</li><li>只要设置cookie的有效时间&gt;0，这个cookie一定会存储到硬盘文件当中。</li><li>设置cookie的有效时间&#x3D;0呢?<ul><li>cookie被删除，同名cookie被删除。</li></ul></li><li>设置cookie的有效时间&lt;0呢?<ul><li>保存在运行内存中。和不设置一样。</li></ul></li></ul></li><li><p>关于cookie的path,cookie关联的路径:</p><ul><li>假设现在发送的请求路径是”http:llocalhost8080&#x2F;servlet13&#x2F;cookielgenerate”生成的cookie，如果cooke没有设置path，默认的path是什么?<ul><li><strong>默认的path是:<a href="http://localhost:8080/servlet13/cookie%E4%BB%A5%E5%8F%8A%E5%AE%83%E7%9A%84%E5%AD%90%E8%B7%AF%E5%BE%84%E3%80%82">http://localhost:8080/servlet13/cookie以及它的子路径。</a></strong></li><li>也就是说，以后只要浏览器的请求路径是http:&#x2F;localhost.8080&#x2F;servlet13&#x2F;cookie这个路径以及这个路径下的子路径，cookie都会被发送到服务器。</li></ul></li><li>手动设置cookie的path<ul><li>cookie.setPath(“&#x2F;servlet13”);表示只要是这个servlet13项目的请求路径，都会提交这个cookie给服务器。</li></ul></li></ul></li><li><p><strong>浏览器发送cookie给服务器了，服务器中的java程序怎么接收?</strong></p><ul><li>&#96;&#96;&#96;java<br>Cookie[] cookies &#x3D; request.getCookies();&#x2F;&#x2F;这个方法可能返回nu1l<br>if(cookies !&#x3D; nu11){<br>    for (Cookie cookie : cookies){<br>        &#x2F;&#x2F;获取cookie的name<br>        String name &#x3D; cookie.getName();<br>        &#x2F;&#x2F;获取cookie的value<br>        String value &#x3D; cookie.getvalue(;<br>}<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 使用cookie实现一下十天内免登录功能。</span><br><span class="line"></span><br><span class="line">## JSP</span><br><span class="line"></span><br><span class="line">我的第一个ISP程序:</span><br><span class="line"></span><br><span class="line">- 在WEB-INF目录之外创建一个index.isp文件，然后这个文件中没有任何内容。</span><br><span class="line"></span><br><span class="line">将上面的项目部署之后，启动服务器，打开浏览器，访问以下地址:</span><br><span class="line"></span><br><span class="line">-  http://localhost:8080ljsp/index.jsp展现在大家面前的是一个空白。</span><br><span class="line">-  实际上访问以上的这个: index.isp，底层执行的是: index_jsp.class这个java程序。</span><br><span class="line">-  这个index.isp会被tomcat翻译生成index_jsp.iaxa文件，然后tomcat服务器又会将index_jsp.iava编译生成index_sp.class文件</span><br><span class="line">-  访问index.isp，实际上执行的是index_jsp.class中的方法。</span><br><span class="line"></span><br><span class="line">JSP实际上就是一个Serxlet。</span><br><span class="line"></span><br><span class="line">- index.jsp访问的时候，会自动翻译生成index jsp.iaxa，会自动编译生成index_jsp.class，那么index_jsp.这就是一个类。</span><br><span class="line">- index_jsp,类继承HttplIspBase，而HttplspBase类继承的是HttpServlet。所以index_jsp类就是一个Servlet类。</span><br><span class="line">- jsp的生命周期和Servlet的生命周期完全相同。完全就是一个东西。没有任何区别。</span><br><span class="line">- jsp和serxlet一样，都是单例的。(假单例。)</span><br><span class="line"></span><br><span class="line">jsp文件第一次访问的时候是比较慢的，为什么?</span><br><span class="line"></span><br><span class="line">- 为什么大部分的运维人员在给客户演示项目的时候，为什么提前先把所有的isp文件先访问一遍。</span><br><span class="line">- 第一次比较麻烦:</span><br><span class="line">  - 要把jsp文件翻译生成java源文件</span><br><span class="line">  - java源文件要编译生成class字节码文件</span><br><span class="line">  - 然后通过class去创建servlet对象</span><br><span class="line">  - 然后调用servlet对象的init方法</span><br><span class="line">  - 最后调用servlet对象的service方法。</span><br><span class="line">- 第二次就比较快了，为什么?</span><br><span class="line">  - 因为第二次直接调用单例servlet对象的service方法即可</span><br><span class="line"></span><br><span class="line">JSP是什么?</span><br><span class="line"></span><br><span class="line">- JSP是java程序。(JSP本质还是一个Servlet)</span><br><span class="line">- JSP是: JavaServer Pages的缩写。(基于Java语言实现的服务器端的页面。)</span><br><span class="line">- Servlet是JavaEE的13个子规范之一，那么ISP也是JavaEE的13个子规范之一。</span><br><span class="line">- JSP是一套规范。所有的web容器/web服务器都是遵循这套规范的，都是按照这套规范进行的“翻译”。</span><br><span class="line">- 每一个web容器/web服务器都会内置一个ISP翻译引擎。</span><br><span class="line"></span><br><span class="line">对JSP进行错误调试的时候，还是要直接打开ISP文件对应的java文件，检查java代码。</span><br><span class="line"></span><br><span class="line">开发JSP的最高境界:</span><br><span class="line"></span><br><span class="line">- 眼前是SP代码，但是脑袋中呈现的是java代码。</span><br><span class="line"></span><br><span class="line"> JSP既然本质上是一个Servlet，那么JSP和Servlet到底有什么区别呢?</span><br><span class="line"></span><br><span class="line">- 职责不同:</span><br><span class="line">  - Serxlet的职责是什么:收集数据。(Serlet的强项是逻辑处理，业务处理，然后链接数据库，获取/收集数据。)</span><br><span class="line">  - JSP的职责是什么:展示数据。(JSP的强项是做数据的展示)</span><br><span class="line"></span><br><span class="line">JSP的基础语法</span><br><span class="line"></span><br><span class="line">- 在jsp文件中直接编写文字，都会自动被翻译到哪里?</span><br><span class="line">  - 翻译到servlet类的service方法的out.write(&quot;翻译到这里&quot;)，直接翻译到双引号里，被java程序当做普通字符串打印输出到流览器。</span><br><span class="line">  - 在jSP中编写的HTML CSS JS代码，这些代码对于ISP来说只是一个普通的字符串。但是jSP把这个普通的字符串一旦输出到流览器，浏览器就会对HTML CSS S进行解释执行。展现一个效果。</span><br><span class="line"></span><br><span class="line">- JSP的page指令(这个指令后面再详细说，这里先解决一下中文乱码问题)，解决响应时的中文乱码问题:</span><br><span class="line">  - 通过page指令来设置响应的内容类型，在内容类型的最后面添加: charset=UTF-8</span><br><span class="line">    - &lt;%@page contentType=&quot;text/ntml;charset=UTF-8&quot;%&gt;，表示响应的内容类型是text/html，采用的字符集UTF-8</span><br><span class="line">- 登录功能实现了，目前存在的最大的问题:</span><br><span class="line">- 这个登录功能目前只是一个摆设，没有任何作用。只要用户知道后端的请求路径，照样可以在不登录的情况下访问。。这个登录没有真正起到拦截的作用。怎么解决?</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- ####  JSP的指令</span><br><span class="line"></span><br><span class="line">  - 指令的作用:</span><br><span class="line"></span><br><span class="line">    - 指导ISP的翻译引擎如何工作(指导当前的lSP翻译引擎如何翻译ISP文件。)</span><br><span class="line"></span><br><span class="line">  - 指令包括哪些呢?</span><br><span class="line"></span><br><span class="line">    - include指令:包含指令，在ISP中完成静态包含，很少用了。(这里不讲)</span><br><span class="line">    - taglib指令:引入标签库的指令。这个到SIL标签库的时候再学习。现在先不管。</span><br><span class="line">    - page指令:目前重点学习一个page指令。</span><br><span class="line"></span><br><span class="line">  - 指令的使用语法是什么?</span><br><span class="line"></span><br><span class="line">    - &lt;%@指令名属性名=属性值属性名=属性值属性名=属性值....%&gt;。</span><br><span class="line"></span><br><span class="line">  - 关于page指令当中都有哪些常用的属性呢?</span><br><span class="line"></span><br><span class="line">    - ```jsp</span><br><span class="line">      &lt;@page session=&quot;true |false&quot;%&gt;</span><br><span class="line">      true表示启用3SP的内置对象session,表示一定启动session对象。没有session对象会创建。</span><br><span class="line">      如果没有设置，黑认值就是session=&quot;true&quot;</span><br><span class="line">      session=&quot;false&quot;表示不启动内置对象session。当前&quot;SP页面中无法使用内置对象session。</span><br><span class="line">      </span><br><span class="line">      &lt;%@page contentType=&quot;text/json&quot;%&gt;</span><br><span class="line">      contentType属性用来设置响应的内容类型</span><br><span class="line">      但同时也可以设置字符集。</span><br><span class="line">      &lt;%@page contentType=&quot;text/json ; charset=UTF-8&quot;%&gt;</span><br><span class="line">      </span><br><span class="line">      &lt;%@page pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line">      pageEncoding=&quot;UTF-8”表示设置响应时采用的字符集。</span><br><span class="line">      </span><br><span class="line">      &lt;%@page import=&quot;java.uti7.List，java.uti1.Date，java.uti7.ArrayList&quot;%&gt;</span><br><span class="line">      &lt;%@page import=&quot;java.util.☆&quot;%&gt;</span><br><span class="line">      import语句，导包。</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      &lt;%@page errorPage=&quot; / error .jsp”%&gt;</span><br><span class="line">          </span><br><span class="line">      </span><br><span class="line">      &lt;%@page isErrorPage=&quot;true&quot;%&gt;表示启用JSP九大内置对象之一:exception默认值是false。</span><br><span class="line">      </span><br></pre></td></tr></table></figure></li></ul></li><li><p>JSP的九大内置对象</p><ul><li>jakarta.servlet.jsp.PageContext pageContext页面作用域</li><li>jakarta.servlet.http.HttpServletRequest request请求作用域</li><li>jakarta.servlet.http.HttpSession session会话作用域</li><li>jakarta.servlet.ServletContext application应用作用域<ul><li>pageContext &lt; request &lt; session &lt; application</li><li>以上四个作用域都有: setAttribute、getAttribute、removeAttribute方法。</li><li>以上作用域的使用原则:尽可能使用小的域。</li></ul></li><li>java.lang.Throwable excegtion</li><li>iakarta.servlet.ServletConfig config</li><li>java.lang.Object page(其实是this，当前的servlet对象)</li><li>jakarta.servlet.jsp.JspWriter out(负责输出)</li><li>jakarta.servlet.http.HttpServletResponse response(负责响应)</li></ul></li></ul><h3 id="同学问-包名bean是什么意思"><a href="#同学问-包名bean是什么意思" class="headerlink" title="同学问:包名bean是什么意思?"></a>同学问:包名bean是什么意思?</h3><ul><li>javabean (java的logo是一杯冒着热气的咖啡。javabean被翻译为:咖啡豆)</li><li>java是一杯咖啡，咖啡又是由一粒一粒的咖啡豆研磨而成。</li><li>整个java程序中有很多bean的存在。由很多bean组成。</li><li>什么是iavabean?实际上javabean你可以理解为符合某种规范的java类，比如:<ul><li>有无参数构造方法</li><li>属性私有化</li><li>对外提供公开的set和get方法</li><li>实现java.io.Serializable接口</li><li>重写toString</li><li>重写hashCode+equals</li><li>………..</li></ul></li><li>javabean其实就是java中的实体类。负责数据的封装。</li><li>由于iavabean符合javabean规范，具有更强的通用性。</li></ul><h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><ul><li><p>EL表达式是干什么用的?</p><ul><li>Expression Language(表达式语言)</li><li>EL表达式可以代替lSP中的iava代码，让ISP文件中的程序看起来更加整洁，美观。</li><li>JSP中夹杂着各种java代码，例如 &lt;% java代码%&gt;、&lt;%&#x3D;%&gt;等，导致JSP文件很混乱，不好看，不好维护。所以才有了后期的EL表达式。</li><li>EL表达式可以算是JSP语法的一部分。EL表达式归属于JSP。</li></ul></li><li><p>EL表达式出现在ISP中主要是:</p><ul><li>从某个作用域中取数据，然后将其转换成字符串，然后将其输出到浏览器。这就是EL表达式的功效。三大功效:<ul><li>第一功效:从某个域中取数据。<ul><li>四个域:<ul><li>pageContext</li><li>request</li><li>session</li><li>application</li></ul></li></ul></li><li>第二功效:将取出的数据转成字符串。<ul><li>如果是一个java对象，也会自动调用java对象的toString方法将其转换成字符串。</li></ul></li><li>第三功效:将字符串输出到浏览器。<ul><li>和这个—样:&lt;%&#x3D; %&gt;，将其输出到浏览器。</li></ul></li></ul></li></ul></li><li><p>EL表达式很好用，基本的语法格式:</p><ul><li><p>${表达式}</p></li><li><pre><code class="jsp">&lt;%@page contentType=&quot;text/html; charset=UTF-8&quot;%&gt;&lt;%    //向request作用域当中存储username为Zhangsan.    request.setAttribute(&quot;username &quot;, &quot;zhangsan&quot;);%&gt;&lt;%--将request域当中的数据取出来，并且还要输出到浏览器，使用java代码怎么办?--%&gt;&lt;%=request.getAttribute(&quot;username &quot;)%&gt;&lt;%--使用EL表达式呢?--%&gt;$&#123;username&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```jsp</span><br><span class="line">  &lt;%</span><br><span class="line">      //创建User对象</span><br><span class="line">      User user = new User();</span><br><span class="line">      user.setUsername (&quot;jackson&quot;);</span><br><span class="line">      user.setPasswor d(&quot;1234&quot;);</span><br><span class="line">      user.setAge(50);</span><br><span class="line">      //将User对象存储到某个域当中。一定要存，因为EL表达式只能从某个范围中取数据。</span><br><span class="line">      //数据是必须存储到四大范围之一的。</span><br><span class="line">      request.setAttribute( &quot;userobj&quot;, user);</span><br><span class="line">  %&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;%--使用EL表达式取--%&gt;</span><br><span class="line">  $&#123;这个位置写什么????这里写的一定是存储到域对象当中时的name&#125;</span><br><span class="line">  要这样写:</span><br><span class="line">  $&#123;userobj&#125;</span><br><span class="line">  等同于java代码:&lt;%=request.getAttribute(&quot;userobj&quot;)%&gt;</span><br><span class="line">  你不要这样写: $&#123;&quot;userobj&quot;&#125;</span><br><span class="line">  </span><br><span class="line">  面试题:</span><br><span class="line">  $&#123;abc&#125;和$&#123; &quot;abc&quot;&#125;的区别是什么?</span><br><span class="line">  $&#123;abc]&#125;表示从某个域中取出数据，并且被取的这个数据的name是&quot; abc&quot;，之前一定有这样的代码:域.setAttribute(&quot;abc&quot;，对象);</span><br><span class="line">  $&#123; &quot;abc&quot;&#125;表示直接将&quot;abc&quot;当做普通字符串输出到浏览器。不会从某个域中取数据了。</span><br><span class="line">  </span><br><span class="line">  $&#123;userobj]底层是怎么做的?从域中取数据，取出user对象，然后调用user对象的toString方法，转换成字符串，输出到浏览器。</span><br><span class="line">  </span><br><span class="line">  &lt;%--如果想输出对象的属性值，怎么办?--%&gt;</span><br><span class="line">  $&#123;userobj.username&#125;使用这个语法的前提是:user对象有getusername()方法。</span><br><span class="line">  $&#123;userobj.password&#125;使用这个语法的前提是:user对象有getPassword()方法。</span><br><span class="line">  $&#123;userobj.age&#125;使用这个语法的前提是:user对象有getAge()方法。</span><br><span class="line">  $&#123;userobj.email&#125;使用这个语法的前提是:user对象有getEmai1()方法。</span><br><span class="line">  EL表达式中的．这个语法，实际上调用了底层的getxxx()方法。</span><br><span class="line">  注意:如果没有对应的get方法，则出现异常。报500错误。</span><br><span class="line">  $&#123;userobj .addr222.zipcode&#125;</span><br><span class="line">  以上EL表达式对应的java代码:</span><br><span class="line">  user. getAddr222O.getzipcode(</span><br></pre></td></tr></table></figure></code></pre></li><li><p>EL表达式优先从小范围中读取数据。</p><ul><li>pageContext &lt; request &lt; session &lt; application。</li></ul></li><li><p>EL表达式中有四个隐含的隐式的范围:</p><ul><li>pageScope 对应的是pageContext范围。</li><li>requestScope 对应的是request范围。</li><li>sessionScope 对应的是session范围。</li><li>applicationScope对应的是application范围。</li></ul></li><li><p>EL表达式对null进行了预处理。如果是null，则向浏览器输出一个空字符串。</p></li><li><p>EL表达式取数据的时候有两种形式:</p><ul><li>第一种:﹒(大部分使用这种方式)</li><li>第二种:<a href="%E5%A6%82%E6%9E%9C%E5%AD%98%E5%82%A8%E5%88%B0%E5%9F%9F%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E8%BF%99%E4%B8%AAname%E4%B8%AD%E5%90%AB%E6%9C%89%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%5B%5D"></a><ul><li>request.setAttribute(“abc.def” , “zhangsan”);</li><li>${requestScope.abc.def}这样是无法取值的。</li><li>应该这样: ${requestScope[“abc.def”]）</li></ul></li></ul></li><li><p>掌握使用L表达式，怎么从Map集合中取数据:</p><ul><li>${map.key}</li></ul></li><li><p>掌握使用EL表达式，怎么从数组中取数据:</p><ul><li>${数组[0]}</li><li>${数组[1]}</li><li>${数组[2]}</li><li>${list[0]}</li></ul></li><li><p>page指令当中，有一个属性，可以忽略E印L表达式</p><ul><li><p>&#96;&#96;&#96;jsp<br>&lt;%@page contentType&#x3D;”text&#x2F;htm1;charset&#x3D;UTF-8” isELIgnored&#x3D;”true”%&gt;<br>isELIgnored&#x3D;”true”表示忽略EL表达式<br>isELIgnored&#x3D;”false”表示不忽略EL表达式。(这是默认值)</p><p>isELIgnored&#x3D;”true”这个是全局的控制。</p><p>可以使用反斜杠进行局部控制:${username}这样也可以忽略EL表达式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 通过EL表达式获取应用的根:</span><br><span class="line"></span><br><span class="line">    - $&#123;pageContext.request.contextPath&#125;</span><br><span class="line"></span><br><span class="line">  - EL表达式中其他的隐式对象:</span><br><span class="line"></span><br><span class="line">    - pageContext</span><br><span class="line">    - param</span><br><span class="line">    - paramalues</span><br><span class="line">    - initParam</span><br><span class="line"></span><br><span class="line">  - EL表达式的运算符</span><br><span class="line"></span><br><span class="line">    - empty运算符</span><br><span class="line">      - empty运算符的结果是boolean类型</span><br><span class="line">      - $&#123;empty param.username&#125;</span><br><span class="line">      - $&#123;not empty param.username&#125;</span><br><span class="line">      - $&#123;(lempty param.password&#125;</span><br><span class="line"></span><br><span class="line">## JSTL标签库</span><br><span class="line"></span><br><span class="line">- 什么是ISTL标签库?</span><br><span class="line"></span><br><span class="line">  -  Java Standard Tag Lib (Java标准的标签库)</span><br><span class="line">  -  JSTL标签库通常结合EL表达式一起使用。目的是让ISP中的java代码消失。</span><br><span class="line">  -  标签是写在[SP当中的，但实际上最终还是要执行对应的java程序。(java程序在jar包当中。)</span><br><span class="line"></span><br><span class="line">- 使用ISTL标签库的步骤:</span><br><span class="line"></span><br><span class="line">  - 第一步:引入ISIL标签库对应的jar包。</span><br><span class="line"></span><br><span class="line">    - tomcat10之后引入的jar包是:</span><br><span class="line">      - jakarta.servlet.jsp.jstl-2.0.0.jar</span><br><span class="line">      - taglibs-standard-impl-1.2.5.jar</span><br><span class="line">      - taglibs-standard-spec-1.2.5.jar</span><br><span class="line">    - 在IDEA当中怎么引入?</span><br><span class="line">      - 在WEB-INF下新建lib目录，然后将jar包拷贝到lib当中。然后将其&quot;Add Lib...&quot;</span><br><span class="line">      - 一定是要和mysqI的数据库驱动一样，都是放在WEB-INF/lib目录下的。</span><br><span class="line">      - 什么时候需要将jar包放到WEB-INF/lib目录下?如果这个jar是tomcat服务器没有的。</span><br><span class="line"></span><br><span class="line">  - 第二步:在ISP中引入要使用标签库。(使用taglib指令引入标签库。)</span><br><span class="line"></span><br><span class="line">    - JSIL提供了很多种标签，你要引入哪个标签????重点掌握核心标签库。</span><br><span class="line"></span><br><span class="line">    - ```jsp</span><br><span class="line">      &lt;%@t aglib prefix=&quot;c &quot; uri=&quot;http://java.sun.com/jsp/jst1/core&quot; %&gt;</span><br><span class="line">      这个就是核心标签库。</span><br><span class="line">      prefix=&quot;这里随便起一个名字就行了，核心标签库，大家默认的叫做c，你随意。&quot;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>第三步:在需要使用标签的位置使用即可。表面使用的是标签，底层实际上还是java程序。</strong>.</p></li><li><p>JSTL标签的原理</p><ul><li>&#96;&#96;&#96;jsp<br>&lt;%@taglib prefix&#x3D;”c “ uri&#x3D;”<a href="http://java.sun.com/jsp/jst1/core&quot;">http://java.sun.com/jsp/jst1/core&quot;</a> %&gt;<br>以上uri后面的路径实际上指向了一个xxx.t1d文件。<br>tld文件实际上是一个xml配置文件。<br>在tld文件中描述了“标签”和”java类”之间的关系。<br>以上核心标签库对应的tld文件是:c.tld文件。它在哪里。<br>在jakarta.servlet.jsp.jst1-2.0.0.jar里面META-INF目录下，有一个c.tld文件。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 源码解析:配置文件tld解析</span><br><span class="line"></span><br><span class="line">  - ```tld</span><br><span class="line">    &lt;tag&gt;</span><br><span class="line">    &lt;description&gt;</span><br><span class="line">        catches any Throwable that occurs in its body and optionallyexposes it.</span><br><span class="line">        &lt;/description&gt;</span><br><span class="line">        &lt;name&gt;catch&lt;/name&gt;</span><br><span class="line">        &lt;tag-class&gt;org.apache.taglibs.standard.tag.common.core.CatchTag&lt;/tag-class&gt;</span><br><span class="line">        &lt;body-content&gt;]SP&lt;/body-content&gt;</span><br><span class="line">        &lt;attribute&gt;</span><br><span class="line">        &lt;description&gt;</span><br><span class="line">        Name of the exported scoped variable for the</span><br><span class="line">        exception thrown from a nested action. The type of thescoped variable is the type of the exception thrown.</span><br><span class="line">        &lt;/description&gt;</span><br><span class="line">        &lt;name&gt;var&lt;/name&gt;</span><br><span class="line">        &lt;required&gt;false&lt;/required&gt;</span><br><span class="line">        &lt;rtexprvalue&gt;false&lt;/rtexprvalue&gt;&lt;/ attribute&gt;</span><br><span class="line">    &lt;/tag&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>o jstl中的核心标签库core当中有哪些常用的标签呢?</p><ul><li><p>c:if</p><ul><li><p><cif test="boolean类型，支持EL表达式">&lt;&#x2F;c: if&gt;</cif></p></li><li><p>c:forEach</p></li><li><p>&lt;c:forEach items&#x3D;”集合，支持EL表达式” var&#x3D;”集合中的元素” varStatus&#x3D;”元素状态对象”&gt;${元素状态对象.count}&lt;&#x2F;c: forEach&gt;</p></li><li><p>&lt;c:forEach var&#x3D;”i” begin&#x3D;”1” end&#x3D;”10” step&#x3D;”2”&gt;${i}&lt;&#x2F;c: forEach&gt;</p></li><li><p>c:choose c:when cotherwise</p></li><li><p>&#96;&#96;&#96;jsp<br>&lt;c:choose&gt;<br>&lt;c:when test&#x3D;”$iparam. age &lt; 18} “&gt;<br>    青少年<br><br>&lt;c:when test&#x3D;”${param.age &lt; 35}”&gt;<br>    青年<br><br>&lt;c:when test&#x3D;”${param. age &lt; 55}”&gt;<br>    中年<br><br>&lt;c:otherwise&gt;<br>    老年<br><br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 改造OA</span><br><span class="line"></span><br><span class="line">- 使用什么技术改造呢?</span><br><span class="line">  - Servlet+ SP+EL表达式＋JSIL标签。进行改造。</span><br><span class="line">- 在前端HTML代码中，有一个标签，叫做base标签，这个标签可以设置整个网页的基础路径。</span><br><span class="line">  - 这不是Java的语法，也不是JSP的语法。是HTML中的一个语法。HTML中的一个标签。通常出现在head标签中。</span><br><span class="line">  - 在当前页面中，凡是路径没有以&quot;&quot;&quot;开始的，都会自动将base中的路径添加到这些路径之前。</span><br><span class="line">    - &lt;a href=&quot;ab/def&quot;&gt;&lt;l a&gt;</span><br><span class="line">    - 等同于: &lt;a href=&quot;http://localhost:8080/oa/ab/def&quot;&gt;&lt;/ a&gt;</span><br><span class="line">  - 需要注意:在IS代码中的路径，保险起见，最好不要依赖base标签。JS代码中的路径最好写上全路径。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## Filter过滤器</span><br><span class="line"></span><br><span class="line">- 当前的OA项目存在什么缺陷?</span><br><span class="line">  - DeptSenilet. EmgSernwlet Orderserwlet。每一个Sernlet都是处理自己相关的业务。在这些Senwlet执行之前都是需要判断用户是否登录了。如果用户登录了，可以继续操作，如果没有登录，需要用户登录。这段判断用户是否登录的代码是固定的，并且在每一个Servlet类当中都需要编写，显然代码没有得到重复利用。包括每一个Serdlet都要解决中文乱码问题，也有公共的代码。这些代码目前都是重复编写，并没有达到复用。怎么解决这个问题?</span><br><span class="line">    - 可以使用Servlet规范中的Filter过滤器来解决这个问题。</span><br><span class="line">- Filter是什么，有什么用，执行原理是什么?</span><br><span class="line">  - Filter是过滤器。</span><br><span class="line">  - Filter可以在Servlet这个目标程序执行之前添加代码。也可以在目标Serlet执行之后添加代码。之前之后都可以添加过滤规则</span><br><span class="line">  - 一般情况下，都是在过滤器当中编写公共代码。</span><br><span class="line">- 一个过滤器怎么写呢?</span><br><span class="line">  - 第一步:编写一个ava类实现一个接口: jarkata.servlet.Filter。并且实现这个接口当中所有的方法。</span><br><span class="line">    - init方法:在Filter对象第一次被创建之后调用，并且只调用一次。</span><br><span class="line">    - doFilter方法:只要用户发送一次请求，则执行一次。发送N次请求，则执行N次。在这个方法中编写过滤规则。</span><br><span class="line">    - destroy方法:在Filter对象被释放/销毁之前调用，并且只调用一次。</span><br><span class="line">  - 第二步:在web.xml文件中对Filter进行配置。这个配置和Servlet很像。</span><br><span class="line">    - 注意:</span><br><span class="line">      -  Servlet对象默认情况下，在服务器启动的时候是不会新建对象的。o Filter对象默认情况下，在服务器启动的时候会新建对象。</span><br><span class="line">      -  Servlet是单例的。Filter也是单例的。(单实例。)</span><br><span class="line">- 目标Servlet是否执行，取决于两个条件:</span><br><span class="line">  - 第一:在过滤器当中是否编写了: chain.doFilter(request, response);代码。</span><br><span class="line">  - 第二:用户发送的请求路径是否和Servlet的请求路径一致。</span><br><span class="line">- chain.doFilter(request, response);这行代码的作用:</span><br><span class="line">  - 执行下一个过滤器，如果下面没有过滤器了，执行最终的Servlet。</span><br><span class="line">- 注意:Filter的优先级，天生的就比Servlet优先级高。</span><br><span class="line">  - **/a.do对应一个Filter，也对应一个Servlet。那么一定是先执行Filter，然后再执行Serulet.** </span><br><span class="line">- 关于Filter的配置路径:</span><br><span class="line">  - /a.do、/b.do、/dept/save。这些配置方式都是精确匹配。</span><br><span class="line">  - */产匹配所有路径。</span><br><span class="line">  - *.do后缀匹配。不要以/开始</span><br><span class="line">  - /dept/*前缀匹配。</span><br><span class="line">- 在web.xml文件中进行配置的时候，Filter的执行顺序是什么?</span><br><span class="line">  - 依靠filter-mapping标签的配置位置，越靠上优先级越高。</span><br><span class="line">- 过滤器的调用顺序，遵循栈数据结构。</span><br><span class="line">- 使用@WebFilter的时候，Filter的执行顺序是怎样的呢?</span><br><span class="line">  - 执行顺序是:比较Filter这个类名。</span><br><span class="line">  - 比如: FilterA和FilterB，则先执行FilterA。</span><br><span class="line">  - o 比如: Filter1和Eilter2，则先执行Filter.1</span><br><span class="line">- Filter的生命周期?</span><br><span class="line">- 和Servlet对象生命周期一致。</span><br><span class="line">  - 唯一的区别: Filter默认情况下，在服务器启动阶段就实例化。Serulet不会。· Filter过滤器这里有一个设计模式:</span><br><span class="line">- 责任链设计模式。</span><br><span class="line">- Filter过滤器这里有一个设计模式:</span><br><span class="line">  - 责任链设计模式。</span><br><span class="line">  - 过滤器最大的优点:</span><br><span class="line">    - 在程序编译阶段不会确定调用顺序。因为Flter的调用顺序是配置到web.xml文件中的，只要修改web.xml配置文件中flter-mapping的顺序就可以调整Filter的执行顺序。显然Filter的执行顺序是在程序运行阶段动态组合的。那么这种设计模式被称为责任链设计模式。</span><br><span class="line">  - 责任链设计模式最大的核心思想:</span><br><span class="line">    - **在程序运行阶段，动态的组合程序的调用顺序。**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20221024200417153](./JAVAWEB-2/3.png)</span><br><span class="line"></span><br><span class="line">## Listener监听器</span><br><span class="line"></span><br><span class="line">- 什么是监听器?</span><br><span class="line"></span><br><span class="line">  - 监听器是Servlet规范中的一员。就像Filter一样。Filter也是Servlet规范中的一员。</span><br><span class="line">  - 在Servlet中，所有的监听器接口都是以&quot;”Listener&quot;结尾。</span><br><span class="line"></span><br><span class="line">- 监听器有什么用?</span><br><span class="line"></span><br><span class="line">  - 监听器实际上是Servlet规范留给我们javaweb程序员的特殊时机。</span><br><span class="line">  - 特殊的时刻如果想执行这段代码，你需要想到使用对应的监听器。.</span><br><span class="line"></span><br><span class="line">- Servlet规范中提供了哪些监听器?</span><br><span class="line"></span><br><span class="line">  -  jakarta.servlet包下:</span><br><span class="line">     - ServletContextListener</span><br><span class="line">     - servletContextAttributeListener</span><br><span class="line">     - ServletRequestListener</span><br><span class="line">     - ServletRequestAttributeListener</span><br><span class="line">  -  jakarta.servlet.http包下:</span><br><span class="line">     - HttpSessionListener</span><br><span class="line">     - HttpSessionAttributeListener</span><br><span class="line">       - 该监听器需要使用@WebListener注解进行标注。</span><br><span class="line">       - 该监听器监听的是什么?是session域中数据的变化。只要数据变化，则执行相应的方法。主要监测点在session域对象上。</span><br><span class="line">     - HttpSessionBindingListener</span><br><span class="line">     - HttpSessionldListener</span><br><span class="line">       - 该监听器不需要使用@WebListener进行标注。</span><br><span class="line">       - 假设User类实现了该监听器，那么User对象在被放入session的时候触发bind事件，User对象从session中删除的时候，触发unbind事件</span><br><span class="line">       - 假设Customer类没有实现该监听器，那么Customer对象放入session或者从session删除的时候，不会触发bind和unbind事件。</span><br><span class="line">     - HttpSessionActivationListener</span><br><span class="line"></span><br><span class="line">- 实现一个监听器的步骤</span><br><span class="line"></span><br><span class="line">- 实现一个监听器的步骤:以ServletContextListener为例。</span><br><span class="line"></span><br><span class="line">  - 第一步:编写一个类实现ServletContextListener接口。并且实现里面的方法。</span><br><span class="line"></span><br><span class="line">    - ```java</span><br><span class="line">      void contextInitialized(servletContextEvent event)</span><br><span class="line">      void contextDestroyed(servletContextEvent event)</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>第二步:在web.xml文件中对ServletContextListener进行配置，如下:</p><ul><li><pre><code class="xml">&lt;listener&gt;&lt;listener-class&gt;com.bjpowernode.javaweb.listener .MyServletContextListener&lt;/listener-class&gt;&lt;/ listener&gt;</code></pre></li><li><p>当然，第二步也可以不使用配置文件，也可以用注解，例如:@WebListener</p></li></ul></li><li><p>注意:所有监听器中的方法都是不需要javaweb程序员调用的，由服务器来负责调用?什么时候被调用呢?</p><ul><li>当某个特殊的事件发生（特殊的事件发生其实就是某个时机到了。）之后，被web服务器自动调用。</li></ul></li></ul></li><li><p>思考一个业务场景:</p><ul><li>请编写一个功能，记录该网站实时的在线用户的个数。</li><li>我们可以通过服务器端有没有分配session对象，因为一个session代表了一个用户。有一个session就代表有一个用户。如果你采用这种逻辑去实现的话,session有多少个，在线用户就有多少个。这种方式的话: HittgSessionListener够用了。session对象只要新建，则count++，然后将count存储到ServletContext域当中，在页面展示在线人数即可。</li><li>业务发生改变了，只统计登录的用户的在线数量，这个该怎么办?<ul><li>session.setAttribute(“user” , userObj);</li><li>用户登录的标志是什么?session中曾经存储过User类型的对象。那么这个时候可以让User类型的对象实现比ittgSessionBindingListener监听器，只要User类型对象存储到session域中，则count++，然后将count++存储到SerletContext对象中。页面展示在线人数即可。</li></ul></li></ul></li><li><p>实现oa项目中当前登录在线的人数。</p><ul><li>什么代表着用户登录了?<ul><li>session.setAttribute(“user”, userObj); User类型的对象只要往session中存储过，表示有新用户登录。</li></ul></li><li>什么代表着用户退出了?<ul><li>session.removeAttribute(“user”); User类型的对象从session域中移除了</li><li>或者有可能是session销毁了。(session超时)</li></ul></li></ul></li></ul><h2 id="MVC简介"><a href="#MVC简介" class="headerlink" title="MVC简介"></a>MVC简介</h2><p><img src="/2022/10/26/JAVAWEB-2/4.png" alt="image-20221025093319944"></p><p><img src="/2022/10/26/JAVAWEB-2/9.png" alt="image-20221025112210463"></p><p><img src="/2022/10/26/JAVAWEB-2/6.png" alt="image-20221025111909544"></p><p><img src="/2022/10/26/JAVAWEB-2/7.png" alt="image-20221025112001448"></p><p><img src="/2022/10/26/JAVAWEB-2/8.png" alt="image-20221025112109652"></p><p>&#x2F;&#x2F;思考一下:为什么conn关闭之后，这里要从大Map中移除呢?<br>&#x2F;&#x2F;根本原因是:Tomcat服务器是支持线程池的。也就是说一个人用过了t1线程，t1线程还有可能被其他用户使用。</p><p><img src="/2022/10/26/JAVAWEB-2/5.png" alt="image-20221025111803174"></p><p>目前项目仍然存在缺陷:<br>1&gt; 在service层控制了事务，service方法中的事务控制代码看着有点别扭，以后能不能不写?? ? ?<br>可以使用动态代理机制解决这个问题。这个自己研究就行了。<br>2&gt;目前虽然面向接口编程了，但是并没有完全解决对象和对象之间的依赖关系。怎么办?可以使用spring的IoC容器来解诀这个间题。<br>对象的创建我不用管了。<br>对象和对象之间关系的管理我也不想管了。都交给spring容器来负责这件事。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JAVAWEB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVAWEB(1)</title>
      <link href="/2022/10/26/JAVAWEB-1/"/>
      <url>/2022/10/26/JAVAWEB-1/</url>
      
        <content type="html"><![CDATA[<h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><h3 id="关于系统架构"><a href="#关于系统架构" class="headerlink" title="关于系统架构"></a>关于系统架构</h3><h4 id="1-系统架构包括什么形式"><a href="#1-系统架构包括什么形式" class="headerlink" title="1.系统架构包括什么形式?"></a>1.系统架构包括什么形式?</h4><ul><li>C&#x2F;S架构。</li><li>B&#x2F;S架构</li></ul><h4 id="2-C-x2F-S架构"><a href="#2-C-x2F-S架构" class="headerlink" title="2.C&#x2F;S架构?"></a>2.C&#x2F;S架构?</h4><ul><li>Client &#x2F; Server (客户端&#x2F;服务器)。 </li><li>C&#x2F;S架构的软件或者说系统有哪些呢?</li><li>QQ（先去腾讯官网下载一个QQ软件，几十MB，然后把这个客户端软件安装上去，然后输入QQ号以及密码，登录之后，就<br>可以和你的朋友聊天了，就可以使用这个软件了。)</li><li>C&#x2F;S架构的特点:需要安装特定的客户端软件。</li><li>C&#x2F;S架构的系统优点和缺点分别是什么?<ul><li>优点:<ul><li>速度快（软件中的数据大部分都是集成到客户端软件当中的，很少量的数据从服务器端传送过来，所以C&#x2F;S结构的系统速度快)</li><li>体验好(速度又快,界面又酷炫，当然体验好了。)</li><li>界面酷炫（(专门的语言去实现界面的，更加灵活。)<br>服务器压力小(<strong>因为大量的数据都是集成在客户端软件当中，所以服务器只需要传送很少的数据量，当然服务器压力小</strong>。)</li><li>安全(因为大星的数据是集成在客户端软件当中的，并且客户端有很多个，服务器虽然只有一个，就算服务器那边地震了，火灾了，服务器受损了，问题也不大，因为大量的数据在多个客户端上有缓存，有存储，所以从这个方面来说，C&#x2F;S结构的系统比较安全。)</li></ul></li><li>缺点:<ul><li>升级维护比较差劲。(升级维护比较麻烦。成本比较高。每一个客户端软件都需要升级。有一些软件不是那么容易安装的。)比如银行</li></ul></li></ul></li></ul><h4 id="3-B-x2F-S架构"><a href="#3-B-x2F-S架构" class="headerlink" title="3.B&#x2F;S架构?"></a>3.B&#x2F;S架构?</h4><ul><li>B&#x2F;S (Browser &#x2F; Server，浏览器&#x2F;服务器)</li><li><a href="http://www.baidu.com/">http://www.baidu.com</a></li><li><a href="http://www.jd.como/">http://www.jd.como</a> </li><li><a href="http://www.126.com/">http://www.126.com</a></li><li>B&#x2F;S结构的系统是不是一个特殊的C&#x2F;S系统?<ul><li>实际上B&#x2F;S结构的系统还是一个CIS，只不过这个C比较特殊，<strong>这个Client是一个固定不变浏览器软件。</strong></li></ul></li><li>B&#x2F;S结构的系统优点和缺点是:<ul><li>优点:<ul><li>升级维护方便，成本比较低。(只需要升级服务器端即可。)</li><li>不需要安装特定的客户端软件，用户操作极其方便。只需要打开浏览器，输入网址即可。</li></ul></li><li>缺点:<ul><li>速度慢〈不是因为带宽低的问题，是因为所有的数据都是在服务器上，用户发送的每一个请求都是需要服务器全身心的响应数据，所以B&#x2F;S结构的系统在网络中传送的数据量比较大。)</li><li>体验差（界面不是那么酷炫，因为浏览器只支持三个语言HTML CSSJavaScript。在加上速度慢。)</li><li>不安全(所有的数据都在服务器上，只要服务器发生火灾，地震等不可抗力，最终数据全部丢失。)</li><li>….</li></ul></li></ul></li></ul><h4 id="4-C-x2F-S和B-x2F-S结构的系统-哪个好，哪个不好"><a href="#4-C-x2F-S和B-x2F-S结构的系统-哪个好，哪个不好" class="headerlink" title="4.C&#x2F;S和B&#x2F;S结构的系统,哪个好，哪个不好?"></a>4.C&#x2F;S和B&#x2F;S结构的系统,哪个好，哪个不好?</h4><ul><li>这个问题问的没有水平。并不是哪个好，哪个不好。不同结构的系统在不同的业务场景下有不同的适用场景。</li><li>娱乐性软件建议使用?<ul><li>C&#x2F;S结构</li></ul></li><li>公司内部使用的—些业务软件建议使用?<ul><li>公司内部使用的系统，需要维护成本低。</li><li>公司内部使用的系统，不需要很酷炫。</li><li>公司内部使用的企业级系统主要是能够进行数据的维护即可。B&#x2F;S结构。</li></ul></li></ul><h4 id="5-注意了-开发B-x2F-S结构的系统，其实就是开发网站，其实就是开发一个WEB系统。"><a href="#5-注意了-开发B-x2F-S结构的系统，其实就是开发网站，其实就是开发一个WEB系统。" class="headerlink" title="5.注意了:开发B&#x2F;S结构的系统，其实就是开发网站，其实就是开发一个WEB系统。"></a>5.注意了:开发B&#x2F;S结构的系统，其实就是开发网站，其实就是开发一个WEB系统。</h4><ul><li><p>开发一个WEB系统你需要会哪些技术?</p><ul><li>WEB前端（运行在浏览器上的程序。)</li><li>HTML</li><li>CSS</li><li>JavaScript</li></ul></li><li><p>WEB后端(WEB服务器端的程序。)</p><ul><li><p>java可以(Java做WEB开发我们称为JavaWEB开发。JavaWEB开发最核心的规范: Servlet.【<strong>Server Applet服务器端的Java小程序。</strong>】)</p></li><li><p>C语言也可以</p></li><li><p>C++也可以</p></li><li><p>Python也行</p></li><li><p>PHP也可以</p></li><li><p>…..</p></li></ul></li></ul><h4 id="6-JavaEE是什么"><a href="#6-JavaEE是什么" class="headerlink" title="6.JavaEE是什么?"></a>6.JavaEE是什么?</h4><ul><li><p>Java包括三大块:</p><ul><li><p>lavaSE</p><ul><li>Java标准版（一套类库:别人写好的一套类库，只不过这个类库是标准类库，走E，或者走ME，这个SE一定是基础，先学。)</li></ul></li><li><p>JavaEE (WEB方向，WEB系统。)</p><ul><li><p>Java企业版(也是一套类库:也是别人写好的一套类库，只不过这套类库可以帮助我们完成企业级项目的开发，专门为企业内部提供解决方案的一套(多套)类库。)</p></li><li><p>别人写好的，你用就行了，用它可以开发企业级项目。</p></li><li><p>可以开发web系统。</p></li><li><p>Java比较火爆的就是这个lavaEE方向。</p></li></ul></li><li><p>JavaME</p><ul><li><p>Java微型版（还是一套类库，只不过这套类库帮助我们进行电子微型设备内核程序的开发)</p></li><li><p>机顶盒内核程序，吸尘器内核程序，电冰箱内核程序，电饭煲内核程序。。。 。 。</p></li></ul></li></ul></li><li><p>JavaEE实际上包括很多种规范，13种规范，其中Servlet就是JavaEE规范之一。学Servlet还是Java语言。</p></li></ul><h3 id="B-x2F-S架构的系统通信原理"><a href="#B-x2F-S架构的系统通信原理" class="headerlink" title="B&#x2F;S架构的系统通信原理"></a>B&#x2F;S架构的系统通信原理</h3><h4 id="WEB系统的访问过程"><a href="#WEB系统的访问过程" class="headerlink" title="WEB系统的访问过程"></a>WEB系统的访问过程</h4><ul><li><p>第一步:打开浏览器。 </p></li><li><p>第二步:找到地址</p></li><li><p>第三步:输入一个合法的网址。</p></li><li><p>第四步:回车</p></li><li><p>第五步:在浏览器上会展示响应的结果。</p></li><li><p>关于域名:</p><ul><li><a href="https://www.baidu.com/(%E7%BD%91%E5%9D%80)">https://www.baidu.com/(网址)</a></li><li><a href="http://www.baidu.com是—个域名/">www.baidu.com是—个域名</a></li><li>在浏览器地址栏上输入域名，回车之后，域名解析器会将域名解析出来一个具体的IP地址和端口号等。</li><li>解析结果也许是: http:<strong>&#x2F;&#x2F;110.242.68.3:80</strong>&#x2F;index.html</li></ul></li></ul><h4 id="IP地址是啥"><a href="#IP地址是啥" class="headerlink" title="IP地址是啥?"></a>IP地址是啥?</h4><ul><li>计算机在网络当中的一个身份证号。在同一个网络当中，IP地址是唯一的。</li><li>A计算机要想和B计算机通信，首先你需要知道B计算机的IP地址，有了IP地址才能建立连接。</li></ul><h4 id="端口号是啥"><a href="#端口号是啥" class="headerlink" title="端口号是啥?"></a>端口号是啥?</h4><ul><li>一个端口代表一个软件（一个端口代表一个应用，一个端口仅代表一个服务)。</li><li>一个计算机当中有很多软件，每一个软件启动之后都有一个端口号。</li><li>在同一个计算机上，端口号具有唯一性。</li></ul><h4 id="一个WEB系统的通信原理-通信步骤"><a href="#一个WEB系统的通信原理-通信步骤" class="headerlink" title="一个WEB系统的通信原理?通信步骤:"></a>一个WEB系统的通信原理?通信步骤:</h4><ul><li><strong>第一步:用户输入网址(URL)</strong></li><li><strong>第二步:域名解析器进行域名解析:<a href="http://110.242.68.3/index.html">http://110.242.68.3:80/index.html</a></strong></li><li><strong>第三步:浏览器软件在网络中搜索110.242.68.3这一台主机，直到找到这台主机。</strong></li><li><strong>第四步:定位110.242.68.3这台主机上的服务器软件，因为是80端口，可以很轻松的定位到80端口对应的服务器软件。</strong></li><li><strong>第五步:80端口对应的服务器软件得知浏览器想要的资源名是:index.html</strong></li><li><strong>第六步∶服务器软件找到index.html文件，并且将index.html文件中的内容直接输出响应到浏览器上。</strong></li><li><strong>第七步:浏览器接收到来自服务器的代码(HTML CSS JS)</strong></li><li><strong>第八步:浏览器渲染，执行HTML CSS JS代码，展示效果。</strong></li><li>如下图：你懂的</li></ul><p><img src="/2022/10/26/JAVAWEB-1/1.png" alt="image-20221022113622936"></p><h3 id="关于WEB服务器软件"><a href="#关于WEB服务器软件" class="headerlink" title="关于WEB服务器软件"></a>关于WEB服务器软件</h3><h4 id="WEB服务器软件都有哪些呢-这些软件都是提前开发好的。"><a href="#WEB服务器软件都有哪些呢-这些软件都是提前开发好的。" class="headerlink" title="WEB服务器软件都有哪些呢?(这些软件都是提前开发好的。)"></a>WEB服务器软件都有哪些呢?(这些软件都是提前开发好的。)</h4><ul><li>Tomcat (WEB服务器)</li><li>jetty (WEB服务器)</li><li>JBOSS(应用服务器)</li><li>WebLogic(应用服务器)</li><li>WebSphere(应用服务器)</li></ul><h4 id="应用服务器和WEB服务器的关系"><a href="#应用服务器和WEB服务器的关系" class="headerlink" title="应用服务器和WEB服务器的关系?"></a>应用服务器和WEB服务器的关系?</h4><ul><li><strong>应用服务器实现了JavaEE的所有规范。(JavaEE有13个不同的规范。</strong>)</li><li>WEB服务器只实现了JavaEE中的Servlet +JSP两个核心的规范。</li><li>通过这个讲解说明了∶应用服务器是包含WEB服务器的。</li><li>用过JBOSS服务器的同学应该很清楚，JBOSS中内嵌了一个Tomcat服务器。</li></ul><h4 id="Tomcat下载"><a href="#Tomcat下载" class="headerlink" title="Tomcat下载"></a>Tomcat下载</h4><ul><li><p>apache官网地址: <a href="https://www.apache.org/">https://www.apache.org/</a></p></li><li><p>tomcat官网地址: <a href="https://tomcat.apache.org/">https://tomcat.apache.org</a></p></li><li><p>tomcat开源免费的轻量级WEB服务器。</p></li><li><p>tomcat还有另外一个名字: catalina (catalina是美国的一个岛屿，风景秀丽，据说作者是在这个风景秀丽的小岛上开发了一个轻量级的WEB服务器，体积小，运行速度快，因此tomcat又被称为catalina)</p></li><li><p>tomcat的logo是一只公猫（寓意表示Tomcat服务器是轻巧的，小巧的，果然，体积小，运行速度快，只实现了Servlet+JSP规范)</p></li><li><p>tomcat是java语言写的。 </p></li><li><p>tomcat服务器要想运行，必须先又jre (Java的运行时环境)</p><ul><li><p>自己配</p></li><li><p>JAVA_HOME&#x3D;C:lProgram Filesyavayjdk-17.0.1</p></li><li><p>PATH&#x3D;%JAVA_HOME%1bin</p></li><li><p>目前JAVA_HOME没有配置，思考一个问题，这样行不行呢?目前只运行java程序是没问题的。真的没问题吗?.</p></li></ul></li></ul><p>Tomcat服务器的安装:</p><ul><li>绿色版本的安装很简单，直接zip包解压即可。解压就是安装。</li><li>我有一个好习惯，在C盘的根目录下新建一个dev目录，java开发所有相关的工具都安装到dev目录下，这样比较方便管理。(你随意)</li></ul><h3 id="启动Tomcat-必看"><a href="#启动Tomcat-必看" class="headerlink" title="启动Tomcat(必看)"></a>启动Tomcat(必看)</h3><ul><li><strong>bin目录下有一个文件: startup.bat,通过它可以启动Tomcat服务器。</strong></li><li><strong>xxx.bat文件是个什么文件? bat文件是windows操作系统专用的, bat文件是批处理文件，这种文件中可以编写大星的windows的dos命令，然后执行bat文件就相当于批量的执行dos命令。</strong></li><li><strong>startup.sh，这个文件在windows当中无法执行，在Linux环境当中可以使用。在Linux环境下能够执行的是shell命令，大量的shell命令编写在shell文件当中，然后执行这个shell文件可以批量的执行shell命令。</strong></li><li><strong>tomcat服务器提供了bat和sh文件，说明了这个tomcat服务器的通用性。</strong></li><li><strong>分析startup.bat文件得出，执行这个命令，实际上最后是执行: catalina.bat文件。</strong></li><li><strong>catalina.bat文件中有这样一行配置:MAINCLASS&#x3D;org.apache.catalina.startup.Bootstrap(这个类就是main方法所在的类。)</strong></li><li><strong>tomcat服务器就是Java语言写的，既然是java语言写的，那么启动Tomcat服务器就是执行main方法。</strong></li><li><strong>我们尝试打开dos命令窗口，在dos命令窗口中输入startup.bat来启动tomcat服务器。</strong></li><li><strong>启动Tomcat服务器只配置path对应的bin目录是不行的。有两个环境变量需要配置:</strong><br><strong>JAVA_HOME&#x3D;IDK的根</strong><br><strong>CATALINA_HOME&#x3D;Tomcat服务器的根</strong></li></ul><p>关于Tomcat服务器的目录</p><ul><li>bin:这个目录是Tomcat服务器的命令文件存放的目录，比如:启动Tomcat，关闭Tomcat等。</li><li>conf:这个目录是Tomcat服务器的配置文件存放目录。(server.xml文件中可以配置端口号，默认Tomcat端口是8080)o lib:这个目录是</li><li>Tomcat服务器的核心程序目录，因为Tomcat服务器是Java语言编写的，这里的jar包里面都是class文件。</li><li>lib:这个目录是Tomcat服务器的核心程序目录，因为Tomcat服务器是Java语言编写的，这里的jar包里面都是class文件。</li><li>logs:Tomcat服务器的日志目录，Tomcat服务器启动等信息都会在这个目录下生成日志文件。</li><li>temp: Tomcat服务器的临时目录。存储临时文件。</li><li>webapps:这个目录当中就是用来存放大量的webapp (web application:..web应用)</li><li>work:这个目录是用来存放ISP文件翻译之后的java文件以及编译之后的class文件。</li></ul><p>启动Tomcat: startup</p><p><strong>关闭Tomcat:stop (shutdown.bat文件重命名为stop.bat，为什么?原因是shutdown命令和windows中的关机命令冲突。所以修改一下。)</strong></p><p><img src="/2022/10/26/JAVAWEB-1/2.png" alt="image-20221022123754439"></p><h2 id="实现一个最基本的web应用-这个web应用中没有java小程序"><a href="#实现一个最基本的web应用-这个web应用中没有java小程序" class="headerlink" title="实现一个最基本的web应用(这个web应用中没有java小程序)"></a>实现一个最基本的web应用(这个web应用中没有java小程序)</h2><ul><li>第一步:找到CATALINA_HOMEwebapps目录，因为所有的webapp要放到webapps目录下。(没有为什么，这是Tomcat服务器的要求。如果不放到这里，Tomcat服务器找不到你的应用。)</li><li>第二步:在CATALINA_HOMElwebapps目录下新建一个子目录，起名:oa这个目录名oa就是你这个webapp的名字。</li><li>第三步:在oa目录下新建资源文件，例如: index.html，编写index.html文件的内容。</li><li>第四步:启动Tomcat服务器</li><li>第五步:打开浏览器，在浏览器地址栏上输入这样的URL:<ul><li><a href="http://127.0.0.1:8080/oa/index.html">http://127.0.0.1:8080/oa/index.html</a></li></ul></li><li>思考—个问题:<ul><li>我们在浏览器上直接输入一个URL，然后回车。这个动作和超链接一样吗?既然是一样的，我们完全可以使用超链接。</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--注意以下的路径，以/开始，带项目名，是一个绝对路径。不需要添加: http:/ /127.0.0.1:8080--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/oa/login.htm7&quot;</span>&gt;</span>user login2&lt;/ a&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--多个层级也没有关系，正常访问即可。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--注意:我们目前前端上的路径都以&quot;/&quot;开始的，都是加项目名的。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/oa/test/debug/d .htm1&quot;</span>&gt;</span>d page<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><a href="http://127.0.0.1:8080/oa/userList.html">http://127.0.0.1:8080/oa/userList.html</a><ul><li>访问这个地址，可以展示一个用户列表页面。但是这个用户列表页面是写死在HTML文件当中的。这种资源我们称为静态资源。怎么能变成动态资源。显然需要连接数据库。</li><li>连接数据库需要JDBC程序，也就是说需要编写Java程序连接数据库，数据库中有多少条记录，页面上就显示多少条记录，这种技术被称为动态网页技术。(动态网页技术并不是说页面中有flash动画。动态网页技术是说页面中的数据是动态的，根据数据库中数据的变化而变化。)</li></ul></li></ul><h2 id="对于一个动态的web应用来说，一个请求和响应的过程有多少个角色参与，角色和角色之间有多少个协议"><a href="#对于一个动态的web应用来说，一个请求和响应的过程有多少个角色参与，角色和角色之间有多少个协议" class="headerlink" title="对于一个动态的web应用来说，一个请求和响应的过程有多少个角色参与，角色和角色之间有多少个协议"></a>对于一个动态的web应用来说，一个请求和响应的过程有多少个角色参与，角色和角色之间有多少个协议</h2><p><img src="/2022/10/26/JAVAWEB-1/3.png" alt="image-20221022153841594"></p><h4 id="有哪些角色-在整个BS结构的系统当中，有哪些人参与进去了"><a href="#有哪些角色-在整个BS结构的系统当中，有哪些人参与进去了" class="headerlink" title="有哪些角色(在整个BS结构的系统当中，有哪些人参与进去了)"></a>有哪些角色(在整个BS结构的系统当中，有哪些人参与进去了)</h4><ul><li>浏览器软件的开发团队（(浏览器软件太多了︰谷歌浏览器、火狐浏览器、IE浏览器…)</li><li>WEB Server的开发团队(WEB Server这个软件也是太多了:Tomcat、Jetty、WebLogic、JBOSS、WebSpher.….）</li><li>DB Server的开发团队(DB Server这个软件也是太多了:Oracle、MySQL….…</li><li>webapp的开发团队(WEB应用是我们做为JavaWEB程序员开发的)</li></ul><h4 id="角色和角色之间需要遵守哪些规范，哪些协议"><a href="#角色和角色之间需要遵守哪些规范，哪些协议" class="headerlink" title="角色和角色之间需要遵守哪些规范，哪些协议"></a>角色和角色之间需要遵守哪些规范，哪些协议</h4><ul><li>webapp的开发团队和WEB Server的开发团队之间有一套规范: JavaEE规范之—Servlet规范。</li><li>Servlet规范的作用是什么?</li><li>WEB Server和webapp解耦合。</li><li>Browser 和 WebServer之间有一套传输协议:<strong>HTTP协议。</strong>(超文本传输协议。)（<strong>计算机与计算机的通信</strong>）</li><li>webapp开发团队和DB Server的开发团队之间有一套规范:JDBC规范。</li></ul><p><img src="/2022/10/26/JAVAWEB-1/4.png" alt="image-20221022155701822"></p><p><strong>之所以可以解耦合就是因为有协议，有规范</strong></p><p>编译时只调用接口的方法，但在运行时是哪个对象就调用该对象里的方法</p><h2 id="模拟Servlet本质"><a href="#模拟Servlet本质" class="headerlink" title="模拟Servlet本质"></a>模拟Servlet本质</h2><ul><li>充当SUN公司的角色，制定Servlet规范<ul><li>javax.servlet.Servlet接口</li></ul></li><li>充当Tomcat服务器的开发者</li><li>充当Webapp的开发者<ul><li>BankServlet implements Servlet</li><li>UserListServlet implements Servlet</li><li>UserLoginServlet implements Servlet</li></ul></li><li>通过我们的分析:<ul><li>对于我们javaweb程序员来说，我们只需要做两件事:<ul><li>编写一个类实现Servlet接口。</li><li>将编写的类配置到配置文件中，在配置文件中:指定请求路径和类名的关系。</li></ul></li></ul></li><li>注意:<ul><li>这个配置文件的文件名不能乱来。固定的。</li><li>这个配置文件的存放路径不能乱来。固定的。</li><li>文件名、文件路径都是SUN公司制定的Servlet规范中的明细。</li></ul></li><li>严格意义上来说Servlet其实并不是简单的一个接口:<ul><li>Servlet规范中规定了:<ul><li>一个合格的webapp应该是—个怎样的目录结构。</li><li>一个合格的webapp应该有一个怎样的配置文件。</li><li>一个合格的webapp配置文件路径放在哪里。</li><li>一个合格的webapp中java程序放在哪里。这些都是Servlet规范中规定的。</li></ul></li></ul></li><li>Tomcat服务器要遵循Servlet规范。JavaWEB程序员也要遵循这个Servlet规范。这样Tomcat服务器和webapp才能解耦合。</li></ul><h5 id="SUN"><a href="#SUN" class="headerlink" title="SUN"></a>SUN</h5><p>&#x2F;*<br>我们现在充当的角色是SUN公司。<br>SUN公司把servlet接口&#x2F;规范制定出来了。<br>*&#x2F;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> javax.servlet;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Servlet</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一个专门提供服务的方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">service</span> <span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="webapp"><a href="#webapp" class="headerlink" title="webapp"></a>webapp</h5><p>&#x2F;&#x2F;充当的角色发生了改变: webapp开发者<br>&#x2F;&#x2F;只要是我们webapp开发者写的xxxservlet都要实现servlet接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjpowernode.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.Servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BankServlet</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//充当的角色发生了改变: webapp开发者</span></span><br><span class="line">    <span class="comment">//只要是我们webapp开发者写的xxxservlet都要实现servlet接口</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;BankServlet &#x27;s service...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjpowernode.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.Servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserListServlet</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span>&#123;</span><br><span class="line">    <span class="comment">//充当的角色发生了改变: webapp开发者</span></span><br><span class="line">    <span class="comment">//只要是我们webapp开发者写的xxxservlet都要实现servlet接口</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserListServlet &#x27;s service...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjpowernode.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.Servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserLoginServlet</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line">    <span class="comment">//充当的角色发生了改变: webapp开发者</span></span><br><span class="line">    <span class="comment">//只要是我们webapp开发者写的xxxservlet都要实现servlet接口</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserLoginServlet &#x27;s service...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.Servlet;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">//充当Tomcat服务器的开发者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tomcat</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println ( <span class="string">&quot;Tomcat服务器启动成功，开始接收用户的访问。&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//简单的使用scanner来模拟一下用户的请求</span></span><br><span class="line">        <span class="comment">//用户访问服务器是通过浏览器上的&quot;请求路径&quot;</span></span><br><span class="line">        <span class="comment">//也就是说用户请求路径不同，后台执行的servlet不同。</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            /userList       UserListservlet</span></span><br><span class="line"><span class="comment">            /login          UserLoginservlet</span></span><br><span class="line"><span class="comment">            /bank           Bankservlet</span></span><br><span class="line"><span class="comment">            /..........</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        System. out.print( <span class="string">&quot;请输入您的访问路径:&quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Scanner</span> (System.in) ;</span><br><span class="line">        <span class="comment">//用户的请求路径   /bbbb</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> s.nextLine();  <span class="comment">// Tomcat服务器已经获取到了用户的请求路径了</span></span><br><span class="line">        <span class="comment">//Tomcat服务器应该通过用户的请求路径找对应的Xxxservlet</span></span><br><span class="line">        <span class="comment">//请求路径和xxxservlet之间的关系应该由谁指定呢?</span></span><br><span class="line">        <span class="comment">//对于Tomcat服务器来说需要解析配置文件</span></span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span> ( <span class="string">&quot;web.properties&quot;</span>);</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span> () ;pro.load (reader) ;</span><br><span class="line">        reader.close () ;</span><br><span class="line">        <span class="comment">//通过key获取value</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> pro.getProperty (key) ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过反射机制创建对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName (className) ;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span>clazz.newInstance() ;   <span class="comment">// obj的类型对于Tomcat服务器开发人员来说不知道。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//但是Tomcat服务器的开发者知道，你写的xXXXservlet一定实现了servlet接口</span></span><br><span class="line">        <span class="type">Servlet</span> <span class="variable">servlet</span> <span class="operator">=</span> (Servlet) obj;</span><br><span class="line">        servlet.service () ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="配置文件-暂时用properties"><a href="#配置文件-暂时用properties" class="headerlink" title="配置文件(暂时用properties)"></a>配置文件(暂时用properties)</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">/aaaa</span>=<span class="string">com.bjpowernode.servlet.UserListServlet</span></span><br><span class="line"><span class="attr">/bbbb</span>=<span class="string">com.bjpowernode.servlet.UserLoginServlet</span></span><br><span class="line"><span class="attr">/cccc</span>=<span class="string">com.bjpowernode.servlet.BankServlet</span></span><br></pre></td></tr></table></figure><p><img src="/2022/10/26/JAVAWEB-1/5.png" alt="image-20221022171042990"></p><h2 id="Servlet规范是一个什么规范"><a href="#Servlet规范是一个什么规范" class="headerlink" title="Servlet规范是一个什么规范?"></a>Servlet规范是一个什么规范?</h2><ul><li><p>遵循Serulet规范的webapp，这个webapp就可以放在不同的WEB服务器中运行。(因为这个webapp是遵循Servlet规范的。)</p></li><li><p>Servlet规范包括什么呢?</p><ul><li><p>规范了哪些接口规范了哪些类</p></li><li><p>规范了一个web应用中应该有哪些配置文件</p></li><li><p>规范了一个web应用中配置文件的名字</p></li><li><p>规范了一个web应用中配置文件存放的路径</p></li><li><p>规范了一个web应用中配置文件的内容</p></li><li><p>规范了一个合法有效的web应用它的目录结构应该是怎样的。</p></li></ul></li></ul><h3 id="开发一个带有Servlet的webapp-重点"><a href="#开发一个带有Servlet的webapp-重点" class="headerlink" title="开发一个带有Servlet的webapp(重点)"></a>开发一个带有Servlet的webapp(重点)</h3><h5 id="开发步骤是怎样的"><a href="#开发步骤是怎样的" class="headerlink" title="开发步骤是怎样的?"></a>开发步骤是怎样的?</h5><ul><li><p>第一步:在webapps目录下新建一个目录，起名crm (这个crm就是webapp的名字)。当然，也可以是其它项目，比如银行项<br>目，可以创建—个目录bank，办公系统可以创建─个oa。</p><ul><li>注意:crm就,是这个webapp的根</li></ul></li><li><p>第二步:在webapp的根下新建一个目录:WEB-INF</p><ul><li>注意:这个目录的名字是Servlet规范中规定的，必须全部大写，必须一模一样。必须的必须。</li></ul></li><li><p>第三步:在WEB-INF目录下新建一个目录: classes</p><ul><li>注意:这个目录的名字必须是全部小写的classes。这也是Servlet规范中规定的。另外这个目录下一定存放的是Java程序编译之后的class文件(这里存放的是字节码文件)。</li></ul></li><li><p>第四步:在WEB-INF目录下新建—个目录:lib</p><ul><li>注意:这个目录不是必须的。但如果一个webapp需要第三方的jar包的话，这个jar包要放到这个lib目录下，这个目录的名字也不能随意编写，必须是全部小写的lib。例如java语言连接数据库需要数据库的驱动jar包。那么这个jar包就一定要放到lib目录下。这Servlet规范中规定的。</li></ul></li><li><p>第五步:在WEB-INF目录下新建一个文件: web.xml</p><ul><li><p>注意:这个文件是必须的，这个文件名必须叫做web.xml。这个文件必须放在这里。一个合法的webapp，web.xml文件是必须的，这个web.xml文件就是一个配置文件，在这个配置文件中描述了请求路径和Servlet类之间的对照关系。</p></li><li><p>这个文件最好从其他的webapp中拷贝，最好别手写。没必要。复制粘贴</p></li><li><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee                      http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;  version=&quot;4.0&quot;  metadata-complete=&quot;true&quot;&gt;&lt;/web-app&gt;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 第六步:编写一个Java程序，这个小ava程序也不能随意开发，这个小java程序必须实现Servlet接口。</span><br><span class="line"></span><br><span class="line">  - 这个Servlet接口不在JDK当中。(因为Serlet不是JavaSE了。Servlet属于JavaEE，是另外的一套类库。)-</span><br><span class="line">  - Servlet接(Servlet.class文件）是Oracle提供的。(最原始的是sun公司提供的。)</span><br><span class="line">  - Servlet接口是JavaEE的规范中的一员。</span><br><span class="line">  - Tomcat服务器实现了Servlet规范，所以Tomcat服务器也需要使用Serlet接口。Tomcat服务器中应该有这个接口，Tomcat服务器的CATALINA_HOME\lib目录下有一个servlet-api.jar，解压这个servlet-api.jar之后，你会看到里面有一个Servlet.class文件。</span><br><span class="line">  - 重点:从lakartaEE9开始，Servlet接口的全名变了: jakarta.servlet.Servlet</span><br><span class="line">  - 注意:编写这个ava小程序的时候，java源代码你愿意在哪里就在哪里，位置无所谓，你只需要将java源代码编译之后的class文件放到classes目录下即可。</span><br><span class="line"></span><br><span class="line">- 第七步:编译我们编写的HelloSerxlet</span><br><span class="line"></span><br><span class="line">  - 重点:你怎么能让你的HelloServlet编译通过呢?配置环境变量CLASSPATH CLASSPATH=.;C:\devlapache-tomcat-10.0.12\lib\servlet-api.jar</span><br><span class="line">  - 思考问题:以上配置的CLASSPATH和Tomcat服务器运行有没有关系?</span><br><span class="line">    - 没有任何关系，以上配置这个环境变量只是为了让你的HelloServlet能够正常编译生成class文件。</span><br><span class="line">    - Tomcat能找到，但是这里我们没有用Tomcat</span><br><span class="line"></span><br><span class="line">- 第八步:将以上编译之后的HelloServlet.class文件拷贝到WEB-INF\classes目录下。</span><br><span class="line"></span><br><span class="line">- 第九步:在web.xml文件中编写配置信息，让&quot;请求路径“和&quot;Servlet类名&quot;关联在一起。</span><br><span class="line"></span><br><span class="line">  - 这一步用专业术语描述:在web.xml文件中注册Servlet类。</span><br><span class="line"></span><br><span class="line">  - **使用了反射机制&lt;servlet-class&gt;com.bjpowernode.servlet.He1loservlet&lt;/servlet-class&gt;**</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    public class HelloServlet &#123;</span><br><span class="line">        public class HelloServlet implements Servlet &#123;</span><br><span class="line">            //5个方法</span><br><span class="line">            public void init(ServletConfig config) throws ServletException &#123;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            public void service(ServletRequest request, ServletResponse response)</span><br><span class="line">                    throws servletException, IOException &#123;</span><br><span class="line">                System.out.println(&quot;My First Servlet, Hello Servlet&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            public void destroy() &#123;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            public String getServletInfo() &#123;</span><br><span class="line">                return &quot;&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            public Servletconfig getServletConfig() &#123;</span><br><span class="line">                return nul1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>&#96;&#96;&#96;xml</p><?xml version="1.0" encoding="UTF-8"?><p><web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="http://xmlns.jcp.org/xml/ns/javaee                  http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0" metadata-complete="true"></web-app></p><pre><code>&lt;!--servlet描述信息--&gt;&lt;!--任何一个servlet都对应一个servlet-mapping --&gt;&lt;servlet&gt;    &lt;servlet-name&gt;fdsafdsagfdsafdsa&lt;/servlet-name&gt;&lt;! --这个位置必须是带有包名的全限定类名--&gt;    &lt;servlet-class&gt;com.bjpowernode.servlet.He1loservlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;!--servlet映射信息--&gt;&lt;servlet-mapping&gt;    &lt;!--这个也是随便的，不过这里写的内容要和上面的一样。--&gt;    &lt;servlet-name&gt;fdsafdsagfdsafdsa&lt;/servlet-name&gt;    &lt;!--这里需要一个路径--&gt;    &lt;!--这个路径唯一的要求是必须以 / 开始--&gt;    &lt;!--当前这个路径可以随便写--&gt;    &lt;url-pattern&gt;/fdsa/fd/saf/d/sa/fd/sa/fd&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - ![image-20221022183943835](./JAVAWEB-1/6.png)</span><br><span class="line"></span><br><span class="line">- 第十步:启动Tomcat服务器</span><br><span class="line"></span><br><span class="line">- 第十一步:打开浏览器，在浏览器地址栏上输入一个url，这个URL必须是:</span><br><span class="line"></span><br><span class="line">  - http://127.0.0.1:8080/crm/fdsa/fd/saf/d/sa/fd/sa/fd</span><br><span class="line">  - 非常重要的一件事:浏览器上的请求路径不能随便写，这个请求路径必须和web.xml文件中的urlpattern一致。</span><br><span class="line">  - 注意:浏览器上的请求路径和web.xml文件中的url-pattern的唯一区别就是∶浏览器上的请求路径带项目名:/crm</span><br><span class="line"></span><br><span class="line">- 浏览器上编写的路径太复杂，可以使用超链接。(非常重要: html页面只能放到WEB-INF目录外面。)</span><br><span class="line"></span><br><span class="line">- 以后不需要我们编写main方法了。tomcat服务器负责调用main方法，Tomcat服务器启动的时候执行的就是main方法。我们javaweb程序员只需要编写Servlet接口的实现类，然后将其注册到web.xml文件中，即可。</span><br><span class="line"></span><br><span class="line">- 总结一下:一个合法的webapp目录结构应该是怎样的?</span><br><span class="line"></span><br><span class="line">  ```xml</span><br><span class="line">  webapproot</span><br><span class="line">  |------WEB-INF</span><br><span class="line">  | ------classes(存放字节码)</span><br><span class="line">  | ------1ib(第三方jar包)</span><br><span class="line">  | ------web.xm1(注册servlet)</span><br><span class="line">  |------htm1</span><br><span class="line">  |------css</span><br><span class="line">  |------javascriptl------image</span><br><span class="line">  .......</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="浏览器发送请求，到最终服务器调用Servlet中的方法，是怎样的一个过程"><a href="#浏览器发送请求，到最终服务器调用Servlet中的方法，是怎样的一个过程" class="headerlink" title="浏览器发送请求，到最终服务器调用Servlet中的方法，是怎样的一个过程?"></a>浏览器发送请求，到最终服务器调用Servlet中的方法，是怎样的一个过程?</h5><ul><li>(以下这个过程描述的很粗糙。其中还有很多步骤我省略了。)</li><li>用户输入URL，或者直接点击超链接: <a href="http://127.0.0.1:8080/crm/fdsa/fd/saf/d/sa/fd/sa/fd%E7%84%B6%E5%90%8E">http://127.0.0.1:8080/crm/fdsa/fd/saf/d/sa/fd/sa/fd然后</a></li><li>Tomcat服务器接收到请求，截取路径: lcrm&#x2F;fdsa&#x2F;fd&#x2F;saf&#x2F;d&#x2F;sa&#x2F;fd&#x2F;sa&#x2F;fd</li><li>Tomcat服务器找到crm项目</li><li>Tomcat服务器在web.xm文件中查找&#x2F;fdsa&#x2F;fd&#x2F;saf&#x2F;d&#x2F;sa&#x2F;fd&#x2F;sa&#x2F;fd对应的Servle是:com.bipowernode.servlet.HelloServlet</li><li>Tomcat服务器通过反射机制，创建com.bjpowernode.servlet.HelloServlet的对象。</li><li>Tomcat服务器调用com.bjpowernode.servlet.HelloServlet对象的service方法。</li></ul><h5 id="关于JavaEE的版本"><a href="#关于JavaEE的版本" class="headerlink" title="关于JavaEE的版本"></a>关于JavaEE的版本</h5><ul><li>JavaEE目前最高版本是JavaEE8</li><li>JavaEE被Oracle捐献了，Oracle将JavaEE规范捐献给Apache了。</li><li>Apache巴JavaEE换名了，以后不叫avaEE了，以后叫做jakartaEE。</li><li>以后没有JavaEE了。以后都叫做JakartaEE。</li><li>JavaEE8版本升级之后的””LavaEE 9”，不再是”lavaEE9”这个名了，叫做lakartaEE9</li></ul><h5 id="解决Tomcat服务器在DOs命令窗口中的乱码问题（控制台乱码"><a href="#解决Tomcat服务器在DOs命令窗口中的乱码问题（控制台乱码" class="headerlink" title="解决Tomcat服务器在DOs命令窗口中的乱码问题（控制台乱码)"></a>解决Tomcat服务器在DOs命令窗口中的乱码问题（控制台乱码)</h5><p>将CATALINA_HOME&#x2F;conf&#x2F;logging.properties文件中的内容修改如下:<br>java.util.logging.ConsoleHandler.encoding &#x3D; GBK</p><h5 id="向浏览器响应一段HTML代码"><a href="#向浏览器响应一段HTML代码" class="headerlink" title="向浏览器响应一段HTML代码"></a>向浏览器响应一段HTML代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest request, ServletResponse response)</span></span><br><span class="line">                <span class="keyword">throws</span> servletException, IOException &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;My First Servlet, Hello Servlet&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置响应的内容类型是普通文本或html代码</span></span><br><span class="line">            <span class="comment">//需要在获取流对象之前设置,有效。</span></span><br><span class="line">            response.setContentType ( <span class="string">&quot;text/ html&quot;</span> ) ;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//怎么将一个信息直接输出到浏览器上?</span></span><br><span class="line">            <span class="comment">// 需要使用servletResponse接口:response</span></span><br><span class="line">            <span class="comment">// response表示响应:从服务器向浏览器发送数据叫做响应。</span></span><br><span class="line">            <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter () ;</span><br><span class="line">            out.print ( <span class="string">&quot;Hello Servlet, You are my first servlet ! &quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置响应的内容类型时不要在获取流之后设置。</span></span><br><span class="line">            <span class="comment">//response.setContentType ( &quot;text/html&quot;) ;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//浏览器是能够识别html代码的，那我们是不是应该输出一段HTM代码呢?</span></span><br><span class="line">            out.print ( <span class="string">&quot;&lt;h1&gt;hello servlet，你好servlet&lt;/h1&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//这是一个输出流,负责输出字符串到浏览器</span></span><br><span class="line">            <span class="comment">//这个输出流不需要我们刷新，也不需要我们关闭，这些都由Tomcat来维护。</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            out.flush () ;</span></span><br><span class="line"><span class="comment">            out.close() ;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h5 id="在Servlet中连接数据库，怎么做"><a href="#在Servlet中连接数据库，怎么做" class="headerlink" title="在Servlet中连接数据库，怎么做?"></a>在Servlet中连接数据库，怎么做?</h5><ul><li>Servlet是Java程序，所以在Servlet中完全可以编写JDBC代码连接数据库。</li><li>在一个webapp中去连接数据库，需要将驱动jar包放到WEB-INF&#x2F;Iib目录下。(com.mysql.cj.jdbc.Driver这个类就在驱动jar包当中。)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentServlet</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest request, ServletResponse response)</span></span><br><span class="line">                <span class="keyword">throws</span> servletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">            response.setContentType ( <span class="string">&quot;text/html&quot;</span> ) ;</span><br><span class="line">            <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter () ;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//编写JDBC代码,连接数据库,查询所有学生信息。</span></span><br><span class="line">            <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//注册驱动</span></span><br><span class="line">                Class.forName ( <span class="string">&quot;com. mysql.cj.jdbc. Driver&quot;</span> ) ;</span><br><span class="line">                <span class="comment">//获取连接</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql: //localhost: 3306/bjpowernode&quot;</span> ;</span><br><span class="line">                <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span> ;</span><br><span class="line">                <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">                conn = DriverManager. getConnection(url ,user,password) ;</span><br><span class="line">                <span class="comment">//获取预编译的数据库操作对象</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select no , name from t_student&quot;</span> ;</span><br><span class="line">                ps =conn. prepareStatement(sql);</span><br><span class="line">                <span class="comment">//执行SQL</span></span><br><span class="line">                rs = ps.executeQuery ();</span><br><span class="line">                <span class="comment">//处理查询结果集</span></span><br><span class="line">                <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">no</span> <span class="operator">=</span> rs.getString ( <span class="string">&quot;no&quot;</span> );</span><br><span class="line">                    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString ( <span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">//                  System.out.println (no + &quot;，&quot; + name) ;</span></span><br><span class="line">                    out.print (no + <span class="string">&quot;, &quot;</span> + name + <span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace () ;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//释放资源</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (rs != <span class="literal">null</span>) &#123;</span><br><span class="line">                        rs.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ps != <span class="literal">null</span>) &#123;</span><br><span class="line">                        ps.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">                        conn.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="在集成开发环境当中开发Servlet程序"><a href="#在集成开发环境当中开发Servlet程序" class="headerlink" title="在集成开发环境当中开发Servlet程序"></a>在集成开发环境当中开发Servlet程序</h5><ul><li><p>集成开发工具很多，其中目前使用比较多的是:</p><ul><li>Intelli lDEA (这个居多，IDEA在提示功能方面要强于Eclipse，也就是说IDEA使用起来比Eclipse更加智能，更好用。JetBrain公<br>司开发的。收费的。)</li><li>Eclipse(这个少一些)，Eclipse目前还是有团队使用，只不过处于减少的趋势，自己从事工作之后，可能会遇到。Eclipse是IBM团队开发的。Eclipse寓意是“日食”。”日食”表示将太阳吃掉。太阳是SUN。IBM团队开发Eclipse的寓意是吞并SUN公司，但是2009年的时候SUN公司被Oracle公司并购了。IBM并没有成功并购SUN公司。</li></ul></li><li><p>使用IDEA集成开发工具开发Servlet</p><ul><li><p>第一步: New Project(我比较习惯先创建一个Empty Project【空工程】，然后在空工程下新建Module【模块】，这不是必须的，只是—种习惯，你可以直接新建非空的Project)</p></li><li><p>第二步:新建模块(File –&gt; new –&gt; Module…)</p><ul><li>这里新建的是一个普通的lavaSE模块(这里先不要新建Java Enterprise模块)</li><li>这个Module自动会被放在javaweb的project下面。</li><li>这个Module起名: servlet01</li></ul></li><li><p>第三步:让Module变成lawaEE的模块。(让Module变成webapp的模块。符合webapp规范。符合Servlet规范的Module)</p><ul><li>在Module上点击右键:Add Framework Support…(添加框架支持)</li><li>在弹出的窗口中，选择Web Application(选择的是webapp的支持)</li><li>选择了这个webapp的支持之后，IDEA会自动给你生成一个符合Servlet规范的webpp目录结构。</li><li><strong>重点，需要注意的:在IDEA工具中根据Web Application模板生成的目录中有一个web目录，这个目录就代表webapp的根</strong></li></ul></li><li><p>第四步(非必须)︰根据Web Application生成的资源中有index.jsp文件，这里我选择删除这个index.jsp文件。</p></li><li><p>第五步:编写Servlet (StudentServlet)</p><ul><li>class StudentServlet implements Servlet</li><li>这个时候发现Servlet.class文件没有。怎么办?将CATALINA_HOME&#x2F;lib&#x2F;servlet-api.jar和jsp-api.jar添加到classpath当中<br>(这里的classpath说的是IDEA的classpath)<ul><li>File –&gt; Project Structrue –&gt; Modules –&gt;+加号–&gt;Add JARS….</li></ul></li><li>实现jakarta.servlet.Servlet接口中的5个方法。</li></ul></li><li><p>第六步:在Servlet当中的service方法中编写业务代码（我们这里连接数据库了。)</p></li><li><p>第七步:在WEB-INF目录下新建了一个子目录: lib(这个目录名可不能随意，必须是全部小写的lib)，<strong>并且将连接数据库的驱动jar包放到lib目录下。</strong></p></li><li><p>第八步:在web.xml文件中完成StudentServlet类的注册。(请求路径和Servlet之间对应起来)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>studentServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.bjpowernode.javaweb.servlet.StudentServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>studentServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/servlet/student<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>第九步:给一个html页面，在HTML页面中编写一个超链接，用户点击这个超链接，发送请求，Tomcat执行后台的StudentServlet。</p><ul><li><p>student.html</p></li><li><p>这个文件不能放到WEB-INF目录里面，只能放到WEB-INF目录外面。 student.html文件的内容</p></li><li><pre><code class="xml">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;student page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;!--这里的项目名是/xmm ,无法动态获取,先写死--&gt;    &lt;a href=&quot; /xmm/servlet/student&quot;&gt;student list&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre></li></ul></li><li><p>第十步:让IDEA工具去关联Tomcat服务器。关联的过程当中将webapp部署到Tomcat服务器当中。</p><ul><li>IDEA工具右上角，绿色小锤子右边有一个: Add Configuration</li><li>左上角加号，点击Tomcat Server –&gt; local</li><li>在弹出的界面中设置服务器Server的参数（基本上不用动)</li><li>在当前窗口中有一个Deployment (点击这个用来部署webapp)，继续点击加号，部署即可。修改Application context为: &#x2F;xmm</li></ul></li><li><p>第十一步:启动Tomcat服务器</p><ul><li>在右上角有绿色的箭头，或者绿色的小虫子，点击这个绿色的小虫子，可以采用debug的模式启动Tomcat服务器。</li><li>我们开发中建议适用debug模式启动Tomcat</li></ul></li><li><p>第十二步:打开浏览器，在浏览器地址栏上输入:<a href="http://localhost:8080/xmm">http://localhost:8080/xmm</a></p></li></ul><p>代码：和上面一样</p><p>一些图片</p><p><img src="/2022/10/26/JAVAWEB-1/7.png" alt="image-20221022194740875"></p><p><img src="/2022/10/26/JAVAWEB-1/8.png" alt="image-20221022203459310"></p>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注解(一)</title>
      <link href="/2022/10/08/%E6%B3%A8%E8%A7%A3-%E4%B8%80/"/>
      <url>/2022/10/08/%E6%B3%A8%E8%A7%A3-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>注解，或者叫做注释，英文单词是:Annotation</p><p>注解Annotation是一种引用数据类型。编译之后也是生成xxx.class文件.</p><p>怎么自定义注解呢? 语法格式?</p><ul><li>[修饰符列表]  @interface  注解类型名 {</li><li>}</li></ul><p>注解怎么使用,，用在什么地方?</p><p>​注解使用时的语法格式是:</p><ul><li><p>@注解类型名</p></li><li><p>第二:注解可以出现在类上、属性上、方法上、变量上等….</p></li><li><p>注解还可以出现在注解上。</p></li><li><p>JDK内置了哪些注解呢?</p><ul><li><p>java. lang包下的注释类型:</p></li><li><p>掌握:</p></li><li><p>Deprecated用@Deprecated注释的程序元索，</p></li><li><p>不鼓励程序员使用这样的元素，通常是因为它很危险或存在更好的选择。</p></li><li><p>掌握:</p></li><li><p>Override表示一个方法声明打算重写超类中的另一个方法声明。</p></li><li><p>不用掌握:</p></li><li><p>Suppresswarnings指示应该在注释元素（以及包含在该注释元素中的所有程序元素)中取消显示指定的编译器警告。</p></li></ul></li></ul><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>什么是元注解?<br>用来标注”注解类型”的”注解”，称为元注解。常见的元注解有哪些?</p><ul><li>Target</li><li>Retention</li></ul><p>关于Target注解:<br>    这是一个元注解，用来标注注斛类型n的”注解”<br>    这个Target注解用来标注”被标注的注解”可以出现在哪些位置上。</p><p>@Target(ElementType.METHOD):表示”被标注的注解”只能出现在方法上.</p><p>@Target(value&#x3D;{CONSTRUCTOR，FIELD，LOCAL_VARIABLE，METHOD，PACKAGE，MODULE,PARAMETER，TYPE})</p><p>表示该注解可以出现在:<br>构造方法上<br>字段上<br>局部变量上方法上<br>类上…</p><p>关于Retention注解:</p><p>这是一个元注解，用来标注”注解类型”的”注解”</p><p>这个Retention注解用来标注”被标注的注解”最终保存在哪里。</p><p>@Retention(RetentionPolicy .SOURCE):表示该注解只被保留在java源文件中</p><p>@Retention(RetentionPolicy .CLASS):表示该注解被保存在class文件中。</p><p>@Retention(RetentionPolicy .RUNTIME):表示该注解被保存在class文件中，并且可以被反射机制所读取</p><h2 id="注解中定义属性"><a href="#注解中定义属性" class="headerlink" title="注解中定义属性"></a>注解中定义属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAnnotationTest</span> &#123;</span><br><span class="line"><span class="comment">//报错的原因:如果一个注解当中有属性，那么必须给属性赋值。（除非该属性使用default指定了默认值）</span></span><br><span class="line">    <span class="comment">/*@MyAnnotation</span></span><br><span class="line"><span class="comment">public void doSome()&#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//@MyAnnotation(属性名=属性值)</span></span><br><span class="line">    <span class="comment">//指定name属性的值就好了</span></span><br><span class="line">    <span class="meta">@MyAnnotation(name=&quot;zhangsan&quot;, color=&quot;红色&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyAnnotation</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *我们通常在注解当中可以定义属性，以下这个是MyAnnotation的name属性。</span></span><br><span class="line"><span class="comment">    *看着像1个方法，但实际上我们称之为属性nameo</span></span><br><span class="line"><span class="comment">    *@return</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    String <span class="title function_">name</span><span class="params">( )</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    颜色属性</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    string <span class="title function_">color</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    年龄属性</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">age</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">25</span>; <span class="comment">//属性指定默认值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="属性是value时可以省略"><a href="#属性是value时可以省略" class="headerlink" title="属性是value时可以省略"></a>属性是value时可以省略</h2><p>如果一个注解的属性的名字是value的话，<strong>并且只有一个属性的话，</strong>在使用的时候，该属性名可以省略。|</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAnnotationTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//报错原因:没有指定属性的值。</span></span><br><span class="line">    <span class="comment">/*@MyAnnotation</span></span><br><span class="line"><span class="comment">    public void dosome( )&#123;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="meta">@MyAnnotation(value = &quot;hehe&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@MyAnnotalpion( &quot;haha&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">do0ther</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    指定一个value属性。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="注解属性是一个数组"><a href="#注解属性是一个数组" class="headerlink" title="注解属性是一个数组"></a>注解属性是一个数组</h2><p>Retention的源代码<br>&#x2F;&#x2F;元注解<br>public @interface Retention {l<br>&#x2F;&#x2F;属性<br>RetentionPol1cy value () ;<br>}<br>RetentionPolioy的源代码:<br>public enum RetentionPolicy {<br>    SOURCE,<br>    CLASS,</p><p>​RUNTIME<br>}<br>Target的源代码</p><p><strong>如果数组中只有1个元素:大括号可以省略。</strong></p><p><strong>看看Retention，Target的源代码，你会发现使用的就是枚举和枚举数组</strong>，所以你懂的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        注解当中的属性可以是哪―种类型?</span></span><br><span class="line"><span class="comment">        属性的类型可以是:</span></span><br><span class="line"><span class="comment">        byte short int long float double boolean char String Class 枚举类型以及以上每一种的数组形式。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">value1</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    String <span class="title function_">value2</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>[ ] value3();</span><br><span class="line">    </span><br><span class="line">    string[] value4();</span><br><span class="line">    </span><br><span class="line">    Season <span class="title function_">value5</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    Season[ ] value6();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">parameterType</span>();</span><br><span class="line">    </span><br><span class="line">    Class[] parameterTypes();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//枚举</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Season</span> &#123;</span><br><span class="line">    SPRING,SUMMER,AUTUMN,WINTER;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> OtherAnnotation &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    年龄厨性</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">age</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    邮箱地址属性，支持多个</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    string[] email( );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    平季节数组,Season是枚举类翟</span></span><br><span class="line"><span class="comment">    <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    season[ ] seasonArray();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OtherAnnotationTest</span> &#123;</span><br><span class="line">    <span class="comment">//数组是大括号</span></span><br><span class="line">    <span class="meta">@otherAnnotation(age = 25,email = &#123; &quot;zhangsan@123.com&quot; , &quot;zhangsan@sohu.com&quot; &#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dosome</span><span class="params">()</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果数组中只有1个元素:大括号可以省略。</span></span><br><span class="line"><span class="meta">@OtherAnnotation(age = 25，email = &quot;zhangsan@123.com&quot;, seasonArray = &#123;Season.SPRING,Season.SUNMNER&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doother</span><span class="params">()</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="反射注解"><a href="#反射注解" class="headerlink" title="反射注解"></a>反射注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectAnnotation</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[ ] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//获取这个类</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">c</span> = class.forName(<span class="string">&quot;com.bjpowernode.java.annotation5.MyAnnotationTest&quot;</span>);</span><br><span class="line"><span class="comment">//判断类上面是否有@MyAnnotation</span></span><br><span class="line">        <span class="comment">//System.out.println(c.isAnnotationPresent(MyAnnotation.cLass)); //true </span></span><br><span class="line">        <span class="keyword">if</span>(c.isAnnotationPresent(MyAnnotation.c1ass))&#123;</span><br><span class="line">            <span class="comment">//获取该注解对象</span></span><br><span class="line">            <span class="type">MyAnnotation</span> <span class="variable">myAnnotation</span> <span class="operator">=</span> (MyAnnotation)c.getAnnotation(MyAnnotation.class);</span><br><span class="line">            <span class="comment">//System.out.println(&quot;类上面的注解对象”+ myAnnotation); //l@com.bjpowernode.java.</span></span><br><span class="line">            <span class="comment">//获取注解对象的属性怎么办﹖和调接口没区别。</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> myAnnotation.value();</span><br><span class="line">            system.out.println(value);</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="comment">//判断string类上面是否存在这个注解</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">stringClass</span> <span class="operator">=</span> class.forName( <span class="string">&quot;java.lang.String&quot;</span> );</span><br><span class="line">        System.out.println(stringClass.isAnnotationPresent(MyAnnotation.class)); <span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义注解</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//只允许该注解可以标注类、方法</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE，ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="comment">//希望这个注解可以被反射</span></span><br><span class="line"><span class="meta">@Retention</span> (RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">vaLue属性。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">String <span class="title function_">value</span><span class="params">( )</span> defau1t<span class="string">&quot;北京大兴区&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注解使用</span></span><br><span class="line"><span class="meta">@MyAnnotation(&quot;上海浦东区&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAnnotationTest</span> &#123;</span><br><span class="line">    <span class="comment">//@MyAnnotation</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//@MyAnnotation</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyAnnotationTest</span><span class="params">( )</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@MyAnnotation</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">( )</span>&#123;</span><br><span class="line">    <span class="comment">//@MyAnnotation</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="通过反射获取注解对象属性的值"><a href="#通过反射获取注解对象属性的值" class="headerlink" title="通过反射获取注解对象属性的值"></a>通过反射获取注解对象属性的值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义注解</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line"></span><br><span class="line">╱*</span><br><span class="line">username属性</span><br><span class="line">    */</span><br><span class="line">string <span class="title function_">username</span><span class="params">( )</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">password国性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    string <span class="title function_">password</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAnnotationTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyAnnotation(username = &quot;admin&quot;, password = &quot;456456&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dosome</span><span class="params">()</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[ ] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//获取MyAnnotationTest的doSome()方法上面的注解信息。</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> class.forName(<span class="string">&quot;com.bjpowernode,java.annotation6.MyAnnotationTest&quot;</span> );</span><br><span class="line">        <span class="comment">//获取doSome( )方法</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">doSomeMethod</span> <span class="operator">=</span> c.getDeclaredMethod( name: <span class="string">&quot;doSome&quot;</span>);</span><br><span class="line">        <span class="comment">//判断该方法上是否存在这个注解</span></span><br><span class="line">    <span class="keyword">if</span>( doSomeMethod.isAnnotationPresent(MyAnnotation.class)) &#123;</span><br><span class="line">    <span class="type">MyAnnotation</span> <span class="variable">myAnnotation</span> <span class="operator">=</span> doSomeMethod.getAnnotation(MyAnnotation.class);</span><br><span class="line">            System.out.println( myAnnotation.username( ));</span><br><span class="line">    System.out.println(myAnnotation.password());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="注解在开发中有什么用"><a href="#注解在开发中有什么用" class="headerlink" title="注解在开发中有什么用"></a>注解在开发中有什么用</h2><p>注解在程序当中相当于一种标记，如果有这个注解怎么办，没有这个注解怎么办</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个User类</span></span><br><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    string name;</span><br><span class="line">    </span><br><span class="line">    String password;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个注解</span></span><br><span class="line"><span class="comment">//表示这个注解只能出现在类上面</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="comment">//该注解可以被反射机制读取到</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Id &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这个注解@Id用来标注类，被标注的类中必须有一个int类型的id属性，没有就报异常。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//获取类</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">userClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com. bjpowernode.java.annotation7.User&quot;</span>);</span><br><span class="line">        <span class="comment">//判断类上是否存在Id注解</span></span><br><span class="line">        <span class="keyword">if</span>(userClass.isAnnotationPresent( Id.class)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当一个类上面有@Id注解的时候，要求类中必须存在int类型的id属性</span></span><br><span class="line">            <span class="comment">//如果没有int类型的id属性则报异常。</span></span><br><span class="line">            <span class="comment">//获取类的属性</span></span><br><span class="line">            Field[] fields = userClass.getDeclaredFields();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isok</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//给一个默认的标记</span></span><br><span class="line">            <span class="keyword">for</span>(Field field : fields)&#123;</span><br><span class="line">                <span class="keyword">if</span>( <span class="string">&quot;id&quot;</span>.equals(field.getName()) &amp;&amp; <span class="string">&quot;int&quot;</span>.equals(field.getType( ).getSimpleName()))&#123;</span><br><span class="line">                    <span class="comment">//表示这个类是合法的类。有@Id注解，则这个类中必须有int类型的id</span></span><br><span class="line">                    isOk = <span class="literal">true</span>;<span class="comment">//表示合法</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//判断是否合法</span></span><br><span class="line">            <span class="keyword">if</span>( !isOk)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">HasNotIdPropertyException</span>(<span class="string">&quot;被@Id注解标注的类中必须要有一个int类型的id属性!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HasNotIdPropertyException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HasNotIdPropertyException</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HasNotIdPropertyException</span><span class="params">(String s)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java基础 </tag>
            
            <tag> Annotation </tag>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射</title>
      <link href="/2022/10/08/%E5%8F%8D%E5%B0%84/"/>
      <url>/2022/10/08/%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h2 id="反射机制有什么用"><a href="#反射机制有什么用" class="headerlink" title="反射机制有什么用?"></a>反射机制有什么用?</h2><p>通过java语言中的反射机制<strong>可以操作字节码文件</strong>。</p><p>有<strong>点类似于黑客</strong>。(可以读和修改字节码文件。)</p><p>通过反射机制可以操作<strong>代码片段</strong>。(class文件。)</p><h2 id="反射机制的相关类在哪个包下"><a href="#反射机制的相关类在哪个包下" class="headerlink" title="反射机制的相关类在哪个包下?"></a>反射机制的相关类在哪个包下?</h2><p>java . lang . reflect.* ;</p><h2 id="反射机制相关的重要的类有哪些"><a href="#反射机制相关的重要的类有哪些" class="headerlink" title="反射机制相关的重要的类有哪些?"></a>反射机制相关的重要的类有哪些?</h2><p>java.lang.class: 代表整个字节码,代表一个类型–代表整个类</p><p>java.lang.reflect.Method:代表字节码中的方法字节码。–代表类中的方法</p><p>java.lang.reflect.Constructor:代表字节码中的构造方法字节码。–代表类中的构造方法</p><p>java. lang.reflect.Field:代表字节码中的属性字节码。  –代表类中的成员</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">java.lang.class:</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="comment">//Field</span></span><br><span class="line">    <span class="type">int</span> no;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//constructor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">user</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span> <span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Method</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNo</span> <span class="params">(<span class="type">int</span> no)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNo</span> <span class="params">( )</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取Class的三种方式"><a href="#获取Class的三种方式" class="headerlink" title="获取Class的三种方式"></a>获取Class的三种方式</h2><p>第一种</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">要操作一个类的字节码，需要首先获取到这个类的字节码，怎么获取java.Lang.CLass实例?</span></span><br><span class="line"><span class="comment">三种方式</span></span><br><span class="line"><span class="comment">    第一种: cLass c = CLass.forName(&quot;完整类名带包名&quot;);</span></span><br><span class="line"><span class="comment">    第二种:class c =对象.getCLass();</span></span><br><span class="line"><span class="comment">    第三种：Class c = 任何类型.class</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( string[ ] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        cLass.forName()</span></span><br><span class="line"><span class="comment">            1、静态方法</span></span><br><span class="line"><span class="comment">            2、方法的参数是一个字符串。</span></span><br><span class="line"><span class="comment">            3、字符串需要的是一个完整类名。</span></span><br><span class="line"><span class="comment">            4、完整类名必须带有包名。java.Lang包也不能省略。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">c2</span> = <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c1 = class.forName (<span class="string">&quot;java.lang.String&quot;</span>); <span class="comment">// c1代表string.class文件，或者说c1代表string类型</span></span><br><span class="line">            c2 = class.forName( <span class="string">&quot;java.util.Date&quot;</span>); <span class="comment">//c2代表Date类型</span></span><br><span class="line">            <span class="type">Class</span> <span class="variable">c3</span> <span class="operator">=</span> class.forName( <span class="string">&quot;java.lang.Integer&quot;</span>); <span class="comment">// c3代表Integer类型</span></span><br><span class="line">            <span class="type">Class</span> <span class="variable">c4</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.System&quot;</span>);  <span class="comment">//c4代表System类型</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (classNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//java中任何一个对象都有一个方法 : getClass()</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span> ;</span><br><span class="line"><span class="type">Class</span> <span class="variable">x</span> <span class="operator">=</span> s.getClass();<span class="comment">// x代表string.cLass字节码文件.x代表String类型。</span></span><br><span class="line">        System.out.println(c1 == x); <span class="comment">// true ( ==判断的是对象的内存地址。)</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">time</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>( ) ;</span><br><span class="line"><span class="type">Class</span> <span class="variable">y</span> <span class="operator">=</span> time.getClass();</span><br><span class="line">System.out.println(c2 = y);<span class="comment">// true (c2秘y两个变量中保存的内存地址都是一样的，都指向方法区中的字节码文件</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三种方式，java语言中任何一种类型，包括基本数据类型，它都有.cLass属性。</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">z</span> <span class="operator">=</span> String.class; <span class="comment">//z代表string类型</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">k</span> <span class="operator">=</span> Date.class;  <span class="comment">//k代表Date类型Class f = int.c1ass; l/ f代表int类型</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">e</span> <span class="operator">=</span> <span class="type">double</span>.class; <span class="comment">// e代表double类型</span></span><br><span class="line">        System.out.println(x == z); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2022/10/08/%E5%8F%8D%E5%B0%84/1.png" alt="image-20221005132905741"></p><h2 id="通过放射实例化对象"><a href="#通过放射实例化对象" class="headerlink" title="通过放射实例化对象"></a>通过放射实例化对象</h2><p>​通过cLass的newInstance()方法来实例化对象。<br>​    注意:newInstance()方法内部实际上调用了无参数构造方法，必须保证无参构造存在才可以。|</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">获取到cLass ，能干什么?</span></span><br><span class="line"><span class="comment">    通过cLass的newInstance()方法来实例化对象。</span></span><br><span class="line"><span class="comment">    注意:newInstance()方法内部实际上调用了无参数构造方法，必须保证无参构造存在才可以。|</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//这是不使用反射机制，创建对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>( );</span><br><span class="line">system.out.println(user);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过反射机制，获取CLass，通过cLass来实例化对象</span></span><br><span class="line">            <span class="keyword">class</span> <span class="title class_">c</span> = class.forName( <span class="string">&quot;com. bjpowernode.java.bean.User&quot;</span> );</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//newInstance(）这个方法会调用user这个类的无参数构造方法，完成对象的创建。</span></span><br><span class="line">            <span class="comment">//重点是:newInstance()调用的是无参构造，必须保证无参构造是存在的!</span></span><br><span class="line">            <span class="type">object</span> <span class="variable">obj</span> <span class="operator">=</span> c.newInstance();</span><br><span class="line">        System.out.println(obj); <span class="comment">//com.bjpowernode .java.bean.User@10f87f48</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (classNotFoundException e) &#123;</span><br><span class="line">        e.printstackTrace();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IllegalAccessException e)&#123;</span><br><span class="line">        e.printstackTrace();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">        e.printStackTrace( );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">         </span><br><span class="line">     &#125;</span><br><span class="line"> &#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="反射机制的灵活性"><a href="#反射机制的灵活性" class="headerlink" title="反射机制的灵活性"></a>反射机制的灵活性</h2><p>为什么要使用反射来创建对象？？？</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置文件</span></span><br><span class="line"><span class="attr">className</span>=<span class="string">com.bjpowernode.java.bean.User</span></span><br><span class="line"><span class="comment">#可以修改配置文件</span></span><br></pre></td></tr></table></figure><p>​–以下代码可以通过修改上面的配置文件，来创建不同的类对象</p><p>​如className&#x3D;java.util.date</p><p>​那么创建出来的对象就是date类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    验证反射机制的灵活性。</span></span><br><span class="line"><span class="comment">    java代码写一边，在不改变java源代码的基础之上，可以做到不同对象的实例化。</span></span><br><span class="line"><span class="comment">    非常之灵活（符合oCP开闭原则:对扩展开放，对修改关闭。)</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    后期我们学习的是高级框架，而工作过程中，也都是使用高级框架，包括: ssh ssm</span></span><br><span class="line"><span class="comment">    Spring SpringMVC MyBatisSpring Struts Hibernate...</span></span><br><span class="line"><span class="comment">    这些高级框架底层实现原理:部采用了反射机制。所以反射机制还是重要的。学会了反射机制有利于你理解剖析框架底层的源代码。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//这种方式代码就写死了。只能创建一个user类型的对象</span></span><br><span class="line">        <span class="comment">//User user = new User();</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//以下代码是灵活的，代码不需要改动，可以修改配置文件，配置文件修改之后，可以创建出不同的实例对象。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过Io流读取cLassinfo.properties文件</span></span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>( fileName: <span class="string">&quot;chapter25/classinfo.properties&quot;</span>);</span><br><span class="line">        <span class="comment">//创建属性类对象Map</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>(); <span class="comment">//key value都是string</span></span><br><span class="line">        <span class="comment">//加载</span></span><br><span class="line">        pro.load(reader);</span><br><span class="line">        <span class="comment">//关闭流</span></span><br><span class="line">        reader.close();</span><br><span class="line">        <span class="comment">//通过key获取vaLue</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> pro.getProperty ( <span class="string">&quot;className&quot;</span> );</span><br><span class="line">        System.out.println(className);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//通过反射机制实例化对象</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">c</span> = class.forName(className);</span><br><span class="line">        <span class="type">object</span> <span class="variable">obj</span> <span class="operator">=</span> c.newInstance();</span><br><span class="line">        System.out.println(obj);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="class-forName-发生了什么"><a href="#class-forName-发生了什么" class="headerlink" title="class.forName()发生了什么"></a>class.forName()发生了什么</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">研究一下 : cLass.forName()发生了什么?</span></span><br><span class="line"><span class="comment">记住，重点:</span></span><br><span class="line"><span class="comment">如果你只是希望―个类的静态代码块执行，其它代码一律不执行，你可以使用:</span></span><br><span class="line"><span class="comment">cLass.forName(&quot;完整类名&quot;);</span></span><br><span class="line"><span class="comment">这个方法的执行会导致类加载，类加载时，静态代码块执行。</span></span><br><span class="line"><span class="comment">    提示:1</span></span><br><span class="line"><span class="comment">    后面JDBC技术的时候我们还需要。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//class.forName( )这个方法的执行会导致:类加载。</span></span><br><span class="line">            Class.forName( <span class="string">&quot;com.bjpowernode.java.reflect.MyClass&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (classNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="comment">//静态代码块在类加载时执行，并且只执行一次。</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">System.out.print1n( <span class="string">&quot;MyClass类的静态代码块执行了!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="获取类路径下文件的绝对路径"><a href="#获取类路径下文件的绝对路径" class="headerlink" title="获取类路径下文件的绝对路径"></a>获取类路径下文件的绝对路径</h2><p>out才是真正的根路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">研究一下文件路径的问题。</span></span><br><span class="line"><span class="comment">怎么获取一个文件的绝对路径。以下讲解的这种方式是通用的。但前提是:文件需要在类路怪下。才能用这种方式。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AboutPath</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//这种方式的路径缺点是:移糙性差，在IDEA中默认的当前路径是project的根。</span></span><br><span class="line">    <span class="comment">//这个代码假设离开了IDEA，换到了其它位置，可能当前路径就不是project的根了，这时这个路径就无效了。</span></span><br><span class="line">    <span class="comment">//FileReader reader = new FileReader( &quot;chapter25/cLassinfo2.properties&quot;);</span></span><br><span class="line">    <span class="comment">//接下来说一种比较通用的一种路径。即使代码换位置了，这样编写仍然是通用的。</span></span><br><span class="line">    <span class="comment">//注意:使用以下通用方式的前提是:这个文件必须在类路径下。</span></span><br><span class="line"><span class="comment">//什么类路径下?方式在src下的都是类路径下。【记住它】</span></span><br><span class="line"><span class="comment">//src是类的根路径。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    解释:</span></span><br><span class="line"><span class="comment">    Thread .currentThread()当前线程对象</span></span><br><span class="line"><span class="comment">    getContextCLassLoader(）是线程对象的方法，可以获取到当前线程的类加载器对象。</span></span><br><span class="line"><span class="comment">    getResource()【获取资源】这是类加载器对象的方法，当前线程的类加载器默认从类的根路径下加载资源。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader()</span><br><span class="line">        .getResource( name: <span class="string">&quot;classinfo2.properties&quot;</span>).getPath();  <span class="comment">//这种方式获取文件绝对路径是通用的</span></span><br><span class="line"><span class="comment">//采用以上的代码可以拿到—个文件的绝对路释。</span></span><br><span class="line"><span class="comment">//c:/Users/Administrator/IdeaProjects/javase/out/production/chapter25/classinfo2.properties</span></span><br><span class="line">    System.out.print1n(path);</span><br><span class="line">    </span><br><span class="line">     <span class="type">String</span> <span class="variable">path2</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader()</span><br><span class="line">        .getResource( name: <span class="string">&quot;com/test/db.properties&quot;</span>).getPath();</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="以流的形式直接返回"><a href="#以流的形式直接返回" class="headerlink" title="以流的形式直接返回"></a>以流的形式直接返回</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args )</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//获取一个文件的绝对路径了! ! ! !!</span></span><br><span class="line">    <span class="comment">/*String path = Thread . currentThread( ) .getContextCLassLoader()</span></span><br><span class="line"><span class="comment">        .getResource( &quot;cLassinfo2.properties&quot; ).getPath( );</span></span><br><span class="line"><span class="comment">    FileReader reader = new FiLeReader(path);*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//直接以流的形式返回</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">reader</span> <span class="operator">=</span> Thread.currentThread( ).getContextClassLoader()</span><br><span class="line">.getResourceAsStream( name: <span class="string">&quot;classinfo2.properties&quot;</span>);</span><br><span class="line"><span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">pro.load(reader);</span><br><span class="line">reader.close();<span class="comment">//通过key获取value</span></span><br><span class="line"><span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> pro.getProperty( <span class="string">&quot;className&quot;</span> );</span><br><span class="line">System.out.print1n(className) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="资源绑定器"><a href="#资源绑定器" class="headerlink" title="资源绑定器"></a>资源绑定器</h2><p>一直在用，血统纯正</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java.util包下提供了一个资源绑定器，便于获取属性配置文件中的内容。使用以下这种方式的时候，属性配置文件xxx.properties必须放到类路径下。*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResourceBundleTest</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//资源绑定器，只能绑定xxx . properties文件。并且这个文件必须在类路径下。文件扩展名也必须是properties</span></span><br><span class="line">        <span class="comment">//并且在写路径的时候，路径后面的扩展名不能写。</span></span><br><span class="line">        <span class="comment">//ResourceBundle bundle = ResourceBundLe.getBundle(&quot;cLassinfo2&quot; ); //千万不能加 .properties!!!</span></span><br><span class="line">        <span class="type">ResourceBundle</span> <span class="variable">bundle</span> <span class="operator">=</span> ResourceBundle.getBundle( <span class="string">&quot; com/bjpowernode/java/ bean/db&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> bundle.getString( key: <span class="string">&quot;className&quot;</span>);</span><br><span class="line">        System.out.print1n(className) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>关于JDK中自带的类加载器:</p><h4 id="什么是类加载器"><a href="#什么是类加载器" class="headerlink" title="什么是类加载器?"></a>什么是类加载器?</h4><p>专门负责加载类的命令&#x2F;工具。<br>ClassLoader</p><h4 id="JDK中自带了3个类加载器"><a href="#JDK中自带了3个类加载器" class="headerlink" title="JDK中自带了3个类加载器"></a>JDK中自带了3个类加载器</h4><ul><li><p>启动类加载器</p></li><li><p>扩展类加教器</p></li><li><p>应用类加载器</p></li></ul><h4 id="假设有这样一段代码"><a href="#假设有这样一段代码" class="headerlink" title="假设有这样一段代码:"></a>假设有这样一段代码:</h4><p>string s - “ abc” ;<br>代码在开始执行之前，会将所需要类全部加载到M当中。通过类加载器加载，看到以上代码类加载器会找string.class文件，找到就加载，那么是怎么进行加载的呢?<br>首先通过”启动类加载器”加载。<br>注意:启动类加载器专门加载: c:\Program Files\Java\jdk1.8.0_101ljre</p><p><img src="/2022/10/08/%E5%8F%8D%E5%B0%84/3.png" alt="image-20221005154300031"></p><p>rt.jar中都是JDK最核心的类库。</p><p>如果通过”启动类加载器”加载不到的时候，</p><p>会通过扩展类加载器”加载。<br>注意:扩展类加载器专门加载: C:\Program Files\Java\jdk1.8.0_144\jre\lib\ext</p><p><img src="/2022/10/08/%E5%8F%8D%E5%B0%84/2.png" alt="image-20221005154231210"></p><p>如果”扩展类加载器”没有加载到，那么</p><p>会通过”应用类加载器”加载。</p><p>注意:应用类加载器专门加载: <strong>classpath</strong>中的类。</p><h4 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><p><strong>java中为了保证类加载的安全，</strong>使用了双亲委派机制.优先从启动类加载器中加载，这个称为’’父”<br>“父”无法加载到，再从扩展类加载器中加载，这个称为”母”。双亲委派。如果都加载不到，才会考虑从应用类加载器中加载。直到加载到为止。</p><p><strong>父不是代码上的继承关系</strong></p><h2 id="获取Field"><a href="#获取Field" class="headerlink" title="获取Field"></a>获取Field</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反射属性Field</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Field翻译为字段，其实就是属性/成员</span></span><br><span class="line"><span class="comment">// 4个Field，分别采用了不同的访问控制权限修饰符</span></span><br><span class="line">    <span class="keyword">private</span> String name;  <span class="comment">//Field对象</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> age; <span class="comment">//FieLd对象boolean sex;</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> no;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">MATH_PI</span> <span class="operator">=</span> <span class="number">3.1415926</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"><span class="comment">//获取整个类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">studentClass</span> = Class.forName( <span class="string">&quot;com.bjpowernode.java.bean.Student&quot;</span>);<span class="comment">//获取类中所有的Field</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//com. bjpowernode.java.bean.Student</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> studentClass.getName();</span><br><span class="line">    System.out.println(<span class="string">&quot;完整类名:“ + className);</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    String simpleName = studentClass.getSimpleName();</span></span><br><span class="line"><span class="string">    System.out.println(&quot;</span>简类名:“ + simpleName);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取类中所有的public修饰的Field</span></span><br><span class="line">Field[] fields = studentClass.getFields();</span><br><span class="line">System.out.println(fields.length);<span class="comment">//测试数组中只有1个元素//取出这个Field</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> fields[<span class="number">0</span>];<span class="comment">//取出这个Field它的名字</span></span><br><span class="line"><span class="type">String</span> <span class="variable">fieldName</span> <span class="operator">=</span> f.getName( );</span><br><span class="line">    System.out.print1n(fieldName);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取所有的Field</span></span><br><span class="line">Field[] fs = studentClass.getDeclaredFields( );</span><br><span class="line">    System.out.print1n(fs. length); <span class="comment">//4</span></span><br><span class="line">system.out.println( <span class="string">&quot;===============================&quot;</span>);</span><br><span class="line">    <span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">for</span>(Field field : fs) &#123;</span><br><span class="line"><span class="comment">//获取属性的修饰符列表</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> field.getNodifiers();<span class="comment">//返回的修饰符是一个数字，每个数字是修饰符的代号!! !</span></span><br><span class="line">        system.out.println(i);</span><br><span class="line"><span class="comment">//可以将这个代号”数字转换成“字符串吗?</span></span><br><span class="line"><span class="type">String</span> <span class="variable">modifierstring</span> <span class="operator">=</span> Modifier.tostring(i);</span><br><span class="line">        System.out.println(modifierstring);</span><br><span class="line"><span class="comment">//获取属性的类型</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">fieldType</span> <span class="operator">=</span> field.getType();</span><br><span class="line">        <span class="comment">//String fName = fieldType.getName( );</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fName</span> <span class="operator">=</span> fieldType.getsimpleName();</span><br><span class="line">        system.out.println(fName) ;</span><br><span class="line">        <span class="comment">//获取属性的名字</span></span><br><span class="line">        System.out.println(field.getName());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反编译Field"><a href="#反编译Field" class="headerlink" title="反编译Field"></a>反编译Field</h2><p>获取java代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//创建这个是为了拼接字符串。</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">studentClass</span> <span class="operator">=</span> Class.forName( <span class="string">&quot;com.bjpowernode.java.bean.Student&quot;</span> );</span><br><span class="line">        s.append(Modifier.toString(studentClass.getModifiers()) + <span class="string">&quot; c1ass &quot;</span> + studentClass.getSimpleName() + <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">        Field[] fields = studentclass.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span>(Field field : fields)&#123;</span><br><span class="line">            s.append(<span class="string">&quot;\t&quot;</span> );</span><br><span class="line">            sappend(Modifier.toString(field.getModifiers());</span><br><span class="line">s.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">s. append(field.getType().getSimpleName());</span><br><span class="line">s.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">s.append(field.getName( ));</span><br><span class="line">s.append(<span class="string">&quot; ; \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        s.append(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2022/10/08/%E5%8F%8D%E5%B0%84/4.png" alt="image-20221005171152766"></p><h2 id="通过反射机制访问对象属性"><a href="#通过反射机制访问对象属性" class="headerlink" title="通过反射机制访问对象属性"></a>通过反射机制访问对象属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*必须掌握:</span></span><br><span class="line"><span class="comment">怎么通过反射机制访问一个java对象的属性?</span></span><br><span class="line"><span class="comment">给属性赋值set</span></span><br><span class="line"><span class="comment">获取属性的值get*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest07</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//我们不使用反射机制，怎么去访问一个对象的属性呢?</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="comment">//给属性赋值</span></span><br><span class="line">        s.no = <span class="number">1111</span>;<span class="comment">//三要素:给s对象的no属性赋值1111</span></span><br><span class="line">        <span class="comment">//要素1 :对象s</span></span><br><span class="line">        <span class="comment">//要素2 :no属性</span></span><br><span class="line">        <span class="comment">//要素3:1111</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//读属性值</span></span><br><span class="line">        <span class="comment">//两个要素:获取s对象的no属性的值</span></span><br><span class="line">        system.out.println( s.no);</span><br><span class="line">        <span class="comment">//使用反射机制，怎么去访问一个对象的属性。( set get )</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">studentClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.bjpowernode.java.bean.Student&quot;</span> );</span><br><span class="line">        <span class="type">object</span> <span class="variable">obj</span> <span class="operator">=</span> studentClass.newInstance(); <span class="comment">// obj就是Student对象。（底层调用无参数构造方法)</span></span><br><span class="line">        <span class="comment">//获取no属性（根据属性的名称来获取Field )</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">noFiled</span> <span class="operator">=</span> studentClass.getDeclaredField( <span class="string">&quot;no&quot;</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        给obj对象(Student对象)的no属性赋值</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">            虽然使用了反射机制，但是三要素还是缺一不可:</span></span><br><span class="line"><span class="comment">            要素1 : obj对象</span></span><br><span class="line"><span class="comment">            要素2 :no属性要素3 :2222值</span></span><br><span class="line"><span class="comment">        注意:反射机制让代码复杂了，但是为了一个“灵活”，这也是值得的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        noFiled.set(obj，<span class="number">22222</span>);<span class="comment">//给obj对象的no属性赋值2222</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//读取属性的值</span></span><br><span class="line"><span class="comment">//两个要素:获取obj对象的no属性的值。</span></span><br><span class="line">        System.out.println(noFiled.get(obj));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//可以访问私有的属性吗?</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> studentClass.getDeclaredField( <span class="string">&quot;name&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//打破封装（反射机制的缺点:打破封装，可能会给不法分子留下机会!!! )</span></span><br><span class="line">        <span class="comment">//这样设置完之后，在外部也是可以访问private的。</span></span><br><span class="line">        nameField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        </span><br><span class="line"><span class="comment">//给name属性赋值</span></span><br><span class="line">        nameField.set(obj, <span class="string">&quot;jackson&quot;</span> );<span class="comment">//获取name属性的值</span></span><br><span class="line">        System.out.println( nameField.get(obj));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="可变长度参数"><a href="#可变长度参数" class="headerlink" title="可变长度参数"></a>可变长度参数</h2><p>可变长度参数</p><p>int. . . args这就是可变长度参数</p><p>语法是:类型…（注意:<strong>一定是3个点</strong>。)</p><p>1、可变长度参数要求的参数个数是:G~N个。</p><p>2、可变长度参数在参数列表中必须在最后一个位置上，而且可变长度参数只能有1个。</p><p>3、可变长度参数可以当做一个数组来看待</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    可变长度参数</span></span><br><span class="line"><span class="comment">    int. . . args这就是可变长度参数</span></span><br><span class="line"><span class="comment">    语法是:类型...（注意:一定是3个点。)</span></span><br><span class="line"><span class="comment">    1、可变长度参数要求的参数个数是:G~N个。</span></span><br><span class="line"><span class="comment">    2、可变长度参数在参数列表中必须在最后一个位置上，而且可变长度参数只能有1个。</span></span><br><span class="line"><span class="comment">    3、可变长度参数可以当做一个数组来看待</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArgsTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( string[] args)</span> &#123;</span><br><span class="line">        m( );</span><br><span class="line">        m( <span class="number">10</span>);</span><br><span class="line">        m(<span class="number">10</span>，<span class="number">20</span>);</span><br><span class="line">        <span class="comment">//编译报错</span></span><br><span class="line">        <span class="comment">// m ( &quot;abc&quot; );</span></span><br><span class="line">        m2( <span class="number">100</span>) ;</span><br><span class="line">        m2( <span class="number">200</span>, <span class="string">&quot;abe&quot;</span> );</span><br><span class="line">        m2( <span class="number">200</span>,<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span> );</span><br><span class="line">        m2( <span class="number">200</span>，<span class="string">&quot;abe&quot;</span>, <span class="string">&quot;def&quot;</span>, “xyz<span class="string">&quot; );</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        m3(&quot;</span>ab<span class="string">&quot;, &quot;</span>de<span class="string">&quot;, &quot;</span>kk<span class="string">&quot;, &quot;</span>ff<span class="string">&quot;);</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        String[ ] strs = &#123;&quot;</span>a<span class="string">&quot; , &quot;</span>b<span class="string">&quot;,&quot;</span>c<span class="string">&quot;&#125;;</span></span><br><span class="line"><span class="string">//也可以传1个数组</span></span><br><span class="line"><span class="string">        m3(strs);</span></span><br><span class="line"><span class="string">        //直接传1个数组</span></span><br><span class="line"><span class="string">        m3(new String[]&#123;&quot;</span>我<span class="string">&quot; , &quot;</span>是<span class="string">&quot;, &quot;</span>中<span class="string">&quot;, &quot;</span>国<span class="string">&quot;,&quot;</span>人<span class="string">&quot;&#125;);//没必要</span></span><br><span class="line"><span class="string">        m3( &quot;</span>我<span class="string">&quot;, &quot;</span>是<span class="string">&quot; ,&quot;</span>中<span class="string">&quot; , &quot;</span>国<span class="string">&quot;，&quot;</span>人<span class="string">&quot;);</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string">           </span></span><br><span class="line"><span class="string">public static void m(int. . . args)&#123;</span></span><br><span class="line"><span class="string">        System.out.print1n( &quot;</span>m方法执行了!<span class="string">&quot;);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">//public static void m2(int. .. args2, String. . . args1)&#123;&#125;</span></span><br><span class="line"><span class="string">           </span></span><br><span class="line"><span class="string">     //必须在最后，只能有1个。</span></span><br><span class="line"><span class="string">    public static void m2(int a, string. . . args1)&#123;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    public static void m3( String... args)&#123;</span></span><br><span class="line"><span class="string">        //args有length属性，说明args是一个数组!</span></span><br><span class="line"><span class="string">            //可以将可变长度参数当做一个数组来看。</span></span><br><span class="line"><span class="string">        for(int i = 0; i &lt; args.length; i++)&#123;</span></span><br><span class="line"><span class="string">            system.out.println(args[i]);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><h2 id="反射Method"><a href="#反射Method" class="headerlink" title="反射Method"></a>反射Method</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">用户业务类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*登录方法</span></span><br><span class="line"><span class="comment">*<span class="doctag">@param</span> name用户名</span></span><br><span class="line"><span class="comment">*<span class="doctag">@param</span> password密码</span></span><br><span class="line"><span class="comment">*<span class="doctag">@return</span> true表示登录成功，false表示登录失败!</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">login</span><span class="params">(String name, string password)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( <span class="string">&quot;admin&quot;</span>.equals(name) &amp;&amp; <span class="string">&quot;123&quot;</span>.equals(password))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">*退出系统的方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logout</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;系统已经安全退出!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest08</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//获取类了</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">userServiceClass</span> <span class="operator">=</span> Class.forName( <span class="string">&quot; com.bjpowernode.java.service.UserService&quot;</span>);</span><br><span class="line">        <span class="comment">//获取所有的Method (包括私有的!)</span></span><br><span class="line">        Method[]methods = userServiceClass.getDeclaredMethods();</span><br><span class="line">        <span class="comment">//System .out.printLn(methods.Length); // 2</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//遍历Method</span></span><br><span class="line">        <span class="keyword">for</span>(Method method : methods)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//获取修饰符列表</span></span><br><span class="line">System.out.println(Modifier.toString(method.getNodifiers()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取方法的返回值类型</span></span><br><span class="line">        system.out.println(method.getReturnType( ).getsimpleName());</span><br><span class="line">            <span class="comment">//获取方法名</span></span><br><span class="line">        system.out. println(method.getName( ));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//方法的修饰符列表（—个方法的参数可能会有多个。）</span></span><br><span class="line">Class[] parameterTypes = method.getParameterTypes();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">class</span> <span class="title class_">parameterType</span> : parameterTypes)&#123;</span><br><span class="line">System.out.println(parameterType.getsimpleName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="反编译Method"><a href="#反编译Method" class="headerlink" title="反编译Method"></a>反编译Method</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*了解一下，不需要掌握*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest09</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>() ;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">userServiceClass</span> <span class="operator">=</span> Class.forName( <span class="string">&quot;com.bjpowernode.java.service.UserService&quot;</span>);</span><br><span class="line">        s.append(Modifier.toString(userServiceClass.getModifiers()) + <span class="string">&quot;class&quot;</span> + userServiceClass.getSimpleName + <span class="string">&quot;&#123;&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        Method[ ] methods = userServiceClass.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span>(Method method : methods)&#123;</span><br><span class="line">            <span class="comment">//public boolean login(String name , String password)&#123;&#125;</span></span><br><span class="line">            s.append(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            s.append(Modifier.toString( method.getModifiers()));</span><br><span class="line">            s.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            s.append(method.getReturnType( ).getsimpleName());</span><br><span class="line">            s.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            s.append(method .getName( ));</span><br><span class="line">            s.append(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">            <span class="comment">//参数列表</span></span><br><span class="line">            Class[] parameterTypes = method.getParameterTypes();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">class</span> <span class="title class_">parameterType</span> : parameterTypes)&#123;</span><br><span class="line">s.append(parameterType.getsimpleName( ));</span><br><span class="line">                s.append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">&#125;            </span><br><span class="line">            </span><br><span class="line">            <span class="comment">//删除指定下标位置上的字符</span></span><br><span class="line"><span class="keyword">if</span>(parameterTypes.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                s.deleteCharAt(s.length() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            s.append(<span class="string">&quot;)&#123;&#125;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">            s.append(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">            system.out.println(s);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="反射机制调用方法"><a href="#反射机制调用方法" class="headerlink" title="反射机制调用方法"></a>反射机制调用方法</h2><h4 id="必须掌握"><a href="#必须掌握" class="headerlink" title="必须掌握"></a>必须掌握</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest10</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[ ] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//不使用反射机制，怎么调用方法</span></span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line">        <span class="comment">//调用方法</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            要素分析:</span></span><br><span class="line"><span class="comment">            要素1∶对象userService</span></span><br><span class="line"><span class="comment">            要素2: login方法名</span></span><br><span class="line"><span class="comment">            要素3:叉参列表</span></span><br><span class="line"><span class="comment">            要素4:返回值</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">loginSuccess</span> <span class="operator">=</span> userService.login( <span class="string">&quot;admin&quot;</span>，<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="comment">//System.out.printLn( LoginSuccess);</span></span><br><span class="line">        System.out.println(loginSuccess ?<span class="string">&quot;登录成功&quot;</span>:<span class="string">&quot;登录失败&quot;</span>);</span><br><span class="line">        <span class="comment">//使用反射机制来调用―个对象的方法该怎么做?</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">userServiceClass</span> <span class="operator">=</span> Class.forName( <span class="string">&quot; com.bjpowernode.java.service.UserService&quot;</span>);</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> userServiceClass.newInstance();</span><br><span class="line">        <span class="comment">//获取Method</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">loginMethod</span> <span class="operator">=</span> userServiceClass.getDeclaredMethod( <span class="string">&quot;login&quot;</span>,String.class,String.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Method loginMethod = userServiceCLass.getDecLaredMethod( &quot;Login&quot;, int.cLass);</span></span><br><span class="line">        <span class="comment">//调用方法</span></span><br><span class="line">        <span class="comment">//调用方法有几个要素?也需要4要素。</span></span><br><span class="line">        <span class="comment">//反射机制中最最最最最重要的一个方法，必须记住。</span></span><br><span class="line">        <span class="comment">//四要素:</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        loginMethod方法</span></span><br><span class="line"><span class="comment">        obj对象</span></span><br><span class="line"><span class="comment">        &quot;admin &quot; , &quot;123”实参</span></span><br><span class="line"><span class="comment">        retValue返回值</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">object</span> <span class="variable">retValue</span> <span class="operator">=</span> loginMethod.invoke(obj,...args: <span class="string">&quot;admin &quot;</span> , <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        System.out.println(retValue);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="反射Constructor"><a href="#反射Constructor" class="headerlink" title="反射Constructor"></a>反射Constructor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Vip</span> &#123;</span><br><span class="line"><span class="type">int</span> no;</span><br><span class="line">    String name;</span><br><span class="line">    String birth;</span><br><span class="line">    <span class="type">boolean</span> sex;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Vip</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Vip</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Vip</span><span class="params">(<span class="type">int</span> no，string name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Vip</span><span class="params">(<span class="type">int</span> no, String name, string birth)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.birth = birth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Vip</span><span class="params">(<span class="type">int</span> no，string name，String birth，<span class="type">boolean</span> sex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.birth = birth;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest11</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">Class</span> <span class="variable">vipClass</span> <span class="operator">=</span> class.forName( <span class="string">&quot;com.bjpowernode.java.bean.Vip&quot;</span> );</span><br><span class="line">    s.append(Modifier.toString(vipClass.getModifiers()));</span><br><span class="line">    s.append( <span class="string">&quot; class &quot;</span>);</span><br><span class="line">    s.append(vipclass.getSimpleName());</span><br><span class="line">    s.append( <span class="string">&quot;&#123;\n&quot;</span>);</span><br><span class="line">    <span class="comment">//拼接构造方法</span></span><br><span class="line">    Constructor[] constructors = vipClass.getDeclaredConstructors();</span><br><span class="line">    <span class="keyword">for</span>(Constructor constructor : constructors)&#123;</span><br><span class="line">    <span class="comment">// public vip(int no，String name，string birth， boolean sex) &#123;</span></span><br><span class="line">        s.append(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        s.append(Modifier.tostring( constructor.getModifiers()));</span><br><span class="line">        s.append(<span class="string">&quot; “);</span></span><br><span class="line"><span class="string">        s.append(vipClass.getsimpleName( ));</span></span><br><span class="line"><span class="string">        s.append( &quot;</span>(<span class="string">&quot;);</span></span><br><span class="line"><span class="string">//拼接参数</span></span><br><span class="line"><span class="string">class[] parameterTypes = constructor.getParameterTypes();</span></span><br><span class="line"><span class="string">for(Class parameterType : parameterTypes)&#123;</span></span><br><span class="line"><span class="string">        s.append( parameterType.getsimpleName());</span></span><br><span class="line"><span class="string">            s.append(&quot;</span> , <span class="string">&quot;);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        //删除最后下标位置上的字符</span></span><br><span class="line"><span class="string">        if(parameterTypes.length &gt; 0) &#123;</span></span><br><span class="line"><span class="string">s.deleteCharAt(s.length() - 1);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        s.append(&quot;</span>)&#123;&#125;\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">s.append(&quot;</span>&#125;<span class="string">&quot;);</span></span><br><span class="line"><span class="string">    System.out.println(s );</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="反射机制调用构造方法"><a href="#反射机制调用构造方法" class="headerlink" title="反射机制调用构造方法"></a>反射机制调用构造方法</h2><p>一般重要</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest12</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[ ] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"><span class="comment">//不使用反射机制怎么创建对象</span></span><br><span class="line"><span class="type">vip</span> <span class="variable">v1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vip</span>();</span><br><span class="line">        <span class="type">vip</span> <span class="variable">v2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vip</span>( <span class="number">110</span>，<span class="string">&quot;zhangsan&quot;</span>，<span class="string">&quot;2001-10-11&quot;</span>， <span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//使用反射机制怎么创建对象呢?</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> class.forName( <span class="string">&quot;com.bjpowernode.java.bean.Vip&quot;</span>); </span><br><span class="line">        <span class="comment">//调用无参数构造方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> c.newInstance();</span><br><span class="line">        <span class="comment">//调用有参数的构造方法怎么办?</span></span><br><span class="line">        <span class="comment">//第一步:先获取到这个有参数的构造方法</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">con</span> <span class="operator">=</span> c.getDeclaredConstructor(<span class="type">int</span>. class，String.class，String.class,<span class="type">boolean</span>.class);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第二步:调用构造方法new对象</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">object</span> <span class="variable">new0bj</span> <span class="operator">=</span> con.newInstance(<span class="number">110</span>，<span class="string">&quot;jackson&quot;</span>，<span class="string">&quot;1990-10-11&quot;</span>， <span class="literal">true</span>);</span><br><span class="line">        System.out. println(newObj);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取无参数构造方法</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">con2</span> <span class="operator">=</span> c.getDeclaredConstructor();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">newObj2</span> <span class="operator">=</span> con2.newInstance( );</span><br><span class="line">        System.out.println( newObj2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="反射获取父类和接口"><a href="#反射获取父类和接口" class="headerlink" title="反射获取父类和接口"></a>反射获取父类和接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">重点:给你一 类，怎么获取这个类的父类，已经实现了哪些接口?</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> c1ass ReflectTest13 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args )</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//String举例</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">stringClass</span> <span class="operator">=</span> class.forName( <span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line">        <span class="comment">//获取String的父类</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">superClass</span> <span class="operator">=</span> stringClass.getSuperclass();</span><br><span class="line">        System.out.println( superClass.getName( ));</span><br><span class="line">        <span class="comment">//获取String类实现的所有接口(一个类可以实现多个接口。)</span></span><br><span class="line">        Class[] interfaces = stringClass.getInterfaces( );</span><br><span class="line">        <span class="keyword">for</span>(Class in : interfaces)&#123;</span><br><span class="line">            System.out.println(in.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 反射 </tag>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>static</title>
      <link href="/2022/10/08/static/"/>
      <url>/2022/10/08/static/</url>
      
        <content type="html"><![CDATA[<h2 id="Static"><a href="#Static" class="headerlink" title="Static"></a>Static</h2><p>1、static翻译为”静态“</p><p>2、所有static修饰的都是类相关的，类级别的。</p><p>3、所有static修饰的，都是采用”类名.“的方式访问</p><p>4、static修饰的变量：静态变量</p><p>5、static修饰的方法：静态方法</p><p>变量的分类：</p><p>变量根据声明的位置进行划分：</p><p>​在方法体当中声明的变量叫做：局部变量。</p><p>​在方法体外声明的变量叫做：成员变量。</p><p>成员变量又可以分为：</p><p>​静态变量</p><p>​实例变量</p><h2 id="static代码块"><a href="#static代码块" class="headerlink" title="static代码块"></a>static代码块</h2><p>1、静态代码块在类加载是执行，并且在main方法之前执行，并且只执行一次</p><p>2、静态代码块有什么作用</p><p>第一：静态代码块不是那么常用</p><p>第二：静态代码块这种语法机制实际上是sun公司给我们java程序员的一个特殊时刻&#x2F;时机，这个时机叫做类加载时机</p><p>具体业务：</p><p>​项目经理说了：大家注意了，所有我们编写的程序中，只要是类加载了，请记录一下</p><p>类加载的日志信息（在几时几分几秒，那个类加载到<strong>JVM</strong>中）</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h4 id="静态变量在什么时候初始化？"><a href="#静态变量在什么时候初始化？" class="headerlink" title="静态变量在什么时候初始化？"></a>静态变量在什么时候初始化？</h4><p>类加载时初始化</p><h4 id="静态变量存储在哪里？"><a href="#静态变量存储在哪里？" class="headerlink" title="静态变量存储在哪里？"></a><strong>静态变量存储在哪里？</strong></h4><p>方法区</p><h4 id="静态代码块在什么时候执行？"><a href="#静态代码块在什么时候执行？" class="headerlink" title="静态代码块在什么时候执行？"></a>静态代码块在什么时候执行？</h4><p>类加载时执行</p>]]></content>
      
      
      
        <tags>
            
            <tag> 静态代码块 </tag>
            
            <tag> static </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程(一)</title>
      <link href="/2022/10/08/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%80/"/>
      <url>/2022/10/08/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是线程，什么是进程"><a href="#1-什么是线程，什么是进程" class="headerlink" title="1.什么是线程，什么是进程?"></a>1.什么是线程，什么是进程?</h2><p>进程是一个应用程序（<strong>一个进程是一个软件</strong>）</p><p>线程是一个进程中的执行场景&#x2F;执行单元</p><p>一个进程可以启动多个线程</p><p><strong>JVM是一个进程</strong></p><h2 id="2-对于JAVA来说，当在DOS命令窗口中输入：java-HellowWorld-回车之后"><a href="#2-对于JAVA来说，当在DOS命令窗口中输入：java-HellowWorld-回车之后" class="headerlink" title="2.对于JAVA来说，当在DOS命令窗口中输入：java HellowWorld 回车之后"></a>2.对于JAVA来说，当在DOS命令窗口中输入：java HellowWorld 回车之后</h2><p><strong>会先启动JVM，JVM就是一个进程。</strong></p><p>JVM再启动一主线程调用main()方法</p><p>同时再启动一个垃圾回收线程负责看护，回收垃圾。</p><p>最起码，现在Java程序当中至少有两个线程并发</p><p>一个是垃圾回收线程，一个是执行main()方法的主线程</p><h2 id="3-线程共享？"><a href="#3-线程共享？" class="headerlink" title="3.线程共享？"></a>3.线程共享？</h2><p>进程A和进程B独立不共享</p><p>线程A和线程B呢？</p><p>在java语言中</p><p>线程A和线程B，<strong>堆内存和方法区内存共享，</strong></p><p><strong>堆内存只有一块！！！</strong></p><p><strong>方法区只有一块！！！</strong></p><p><strong>堆内存和方法区只有一块！！！！</strong></p><p><strong>但是栈内存独立，一个线程一个栈</strong></p><p>假设启动10个线程，会有10个栈空间，每个栈和每个栈之间互不干扰，<strong>各自执行各的，这就是多线程并发</strong></p><p><strong>java中之所以有多线程，目的就是为了提高程序的处理效率</strong></p><h2 id="4-思考一个问题"><a href="#4-思考一个问题" class="headerlink" title="4.思考一个问题"></a>4.思考一个问题</h2><p>使用多线程机制之后，main方法结束，是不是有可能程序也不会结束。</p><p>main方法结束只是主线程结束了，<strong>主栈空了，其他的栈可能还在压栈弹栈</strong></p><h2 id="5-分析一个问题"><a href="#5-分析一个问题" class="headerlink" title="5.分析一个问题"></a>5.分析一个问题</h2><p>对于单核的CPU来说，真的可以做到真正的多线程并发吗？</p><p>什么是真正的多线程并发</p><p>t1执行t1</p><p>t2执行t2</p><p>t1不会影响t2，t2不会影响t1，这叫真正的多线程并发</p><p>对于多核CPU来说，真正的多线程并发是没有问题的</p><p>4核CPU表示同一个时间点上，可以真正的有4个进程并发执行</p><p>单核CPU表示只有一个大脑：</p><p>不能够做到真正的多线程并发，但是可以做到给人一种多线程并发的感觉。</p><p>电影院采用胶卷播放电影，一个胶卷一个胶卷播放速度达到一定程度之后，人类的眼睛产生了错觉，感觉是动画的。这说明人类的反应速度很慢，就像一根钢针扎到手上，到最终感觉到疼，这个过程是需要”很长的”时间的，在这个期间计算机可以进行亿万次的循环。所以计算机的执行速度很快。</p><h2 id="6-实现线程第一种"><a href="#6-实现线程第一种" class="headerlink" title="6.实现线程第一种"></a>6.实现线程第一种</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class MyThread extends Thread() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">    //这段代码运行在分支线程</span><br><span class="line">System.out.println(&quot;分支线程&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//程序永远自上而下</span><br><span class="line">public class ThreadTest02() &#123;</span><br><span class="line">    MyThread myThread = new MyThread();</span><br><span class="line">    myThread.start();</span><br><span class="line">    myThread.run();//不会启动线程，不会分配新的分支栈</span><br><span class="line">    //这段代码运行在主线程</span><br><span class="line">    System.out.println(&quot;主线程&quot;)</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>继承Thread</p><h2 id="7-start方法"><a href="#7-start方法" class="headerlink" title="7.start方法"></a>7.start方法</h2><p>start方法的作用是启动一个分支线程，在JVM中开辟一个新的栈空间，这段代码瞬间就结束了</p><p>这段代码的任务只是开启一个新的栈空间，只要新的栈空间开出来，start（）方法就结束了，线程就启动成功了</p><p><strong>启动成功的线程会自动调用run（）方法，并且run方法在分支栈的栈底部（压栈）</strong></p><p>run方法在分支栈的栈底部，main方法在主栈的底部，run和main是平级的</p><h2 id="8-实现线程第二种"><a href="#8-实现线程第二种" class="headerlink" title="8.实现线程第二种"></a>8.实现线程第二种</h2><p>继承Runnable接口</p><p>比较常用，因为：<strong>一个类实现了接口，它还可以区继承其他的类，更灵活</strong></p><h2 id="9-关于线程对象的生命周期"><a href="#9-关于线程对象的生命周期" class="headerlink" title="9.关于线程对象的生命周期"></a>9.关于线程对象的生命周期</h2><p><img src="/2022/10/08/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%80/1.png" alt="image-20221003165006794"></p><h2 id="10-获取线程名字"><a href="#10-获取线程名字" class="headerlink" title="10.获取线程名字"></a>10.获取线程名字</h2><p>thread.getName()    &#x2F;&#x2F;默认名字为thread-0，1，2，3…n</p><h2 id="11-修改线程名字"><a href="#11-修改线程名字" class="headerlink" title="11.修改线程名字"></a>11.修改线程名字</h2><p>thread.setName()</p><h2 id="12-获取当前线程对象"><a href="#12-获取当前线程对象" class="headerlink" title="12.获取当前线程对象"></a>12.获取当前线程对象</h2><p>Thread.currentThread()为静态方法</p><p>出现在run方法，谁执行run方法，当前线程就是谁</p><p>出现在main方法，当前线程就是main</p><h2 id="13-线程的sleep方法"><a href="#13-线程的sleep方法" class="headerlink" title="13.线程的sleep方法"></a>13.线程的sleep方法</h2><p>static void sleep(Long millis)</p><p>静态方法</p><p>参数是毫秒</p><p>作用:让当前线程进入休眠，进入“阻塞状态”，放弃占有CPU时间片，让给其它线程使用。</p><p>这行代码出现在A线程中，A线程就会进入休眠。</p><p>这行代码出现在B线程中，B线程就会进入休眠。</p><h2 id="14-子类不能抛出比父类更多的异常"><a href="#14-子类不能抛出比父类更多的异常" class="headerlink" title="14.子类不能抛出比父类更多的异常"></a>14.子类不能抛出比父类更多的异常</h2><p>&#x2F;&#x2F;重点: run()当中的异常不能throws ，只能try catch</p><p>&#x2F;&#x2F;因为run()方法在父类中没有抛出任何异常，子类不能比父类抛出更多的异常。</p><h2 id="15-终止线程的睡眠"><a href="#15-终止线程的睡眠" class="headerlink" title="15.终止线程的睡眠"></a>15.终止线程的睡眠</h2><p>&#x2F;&#x2F;终断t线程的睡眠（这种终断睡眠的方式伙靠了java的异常处理机制。)</p><p>thread.interrupt();</p><h2 id="16-强行终止线程的执行"><a href="#16-强行终止线程的执行" class="headerlink" title="16.强行终止线程的执行"></a>16.强行终止线程的执行</h2><p>thread.stop()    &#x2F;&#x2F;已过时，不建议使用</p><p>存在很大的缺点，容易丢失数据，<strong>因为是直接杀死线程</strong>，线程的没保存的数据会丢失</p><h2 id="17-合理终止一个线程的执行"><a href="#17-合理终止一个线程的执行" class="headerlink" title="17.合理终止一个线程的执行"></a>17.合理终止一个线程的执行</h2><p>判断，打标记，thread.run()</p><h2 id="18-关于线程的调度"><a href="#18-关于线程的调度" class="headerlink" title="18.关于线程的调度"></a>18.关于线程的调度</h2><p>常见的线程调度模型有哪些？</p><p>抢占式调度模型：</p><p>哪个线程的优先级比较高，抢到CPU时间片的概率就高一些&#x2F;多一些</p><p>java采用的就是抢占式调度模型</p><p>均分式调度模型</p><p>平均分配CPU时间片，每个线程占有的CPU时间片时间长度一样</p><p>平均分配，以且平等</p><p>有一些编程语言，线程调度模型采用的就是这种方式</p><h2 id="18-java中有哪些方法是和线程优先级有关的呢？"><a href="#18-java中有哪些方法是和线程优先级有关的呢？" class="headerlink" title="18.java中有哪些方法是和线程优先级有关的呢？"></a>18.java中有哪些方法是和线程优先级有关的呢？</h2><p>实例方法</p><p>void setPriority (int newPriority)设置线程的优先级</p><p>int getPriority ()获取线程优先级</p><p>最低优先级1</p><p>默认优先级是5最高优先级10</p><p>优先级比较高的获取cPu时间片可能会多一些。(但也不完全是，大概率是多的。)</p><h2 id="19-线程让位"><a href="#19-线程让位" class="headerlink" title="19.线程让位"></a>19.线程让位</h2><p>static void yield()让位方法</p><p>暂停当前正在执行的线程对象，并执行其他线程</p><p>yield()方法不是阻塞方法。让当前线程让位，让给其它线程使用。yield()方法的执行会让当前线程从”运行状态”回到“就绪状态”。注意:在回到就绪之后，有可能还会再次抢到。</p><h2 id="20-线程安全"><a href="#20-线程安全" class="headerlink" title="20.***线程安全"></a>20.***线程安全</h2><p>多线程并发环境下，数据安全问题</p><h4 id="为什么是重点？"><a href="#为什么是重点？" class="headerlink" title="为什么是重点？"></a>为什么是重点？</h4><p>以后在开发中，我们的项目都是运行在服务器当中，而服务器已经将线程的定义，线程对象的创建，线程的启动等，都已经实现完了。这些代码我们都不需要编马。</p><p>最重要的是:你要知道，你编写的程序需要放到一个多线程的环境下运行，你更需要关注的是这些数据</p><p>在多线程并发的环境下是否是安全的。(重点:*****)</p><h4 id="什么时候数据在多线程并发的环境下会存在安全问题呢"><a href="#什么时候数据在多线程并发的环境下会存在安全问题呢" class="headerlink" title="什么时候数据在多线程并发的环境下会存在安全问题呢?"></a>什么时候数据在多线程并发的环境下会存在安全问题呢?</h4><p><strong>三个条件:</strong><br><strong>条件1:多线程并发。</strong></p><p><strong>条件2:有共享数据。</strong><br><strong>条件3:共享薮据有修改的行为。</strong><br><strong>满足以上3个条件之后，就会存在线程安全问题。</strong></p><h4 id="怎么解决线程安全问题呢"><a href="#怎么解决线程安全问题呢" class="headerlink" title="怎么解决线程安全问题呢?"></a>怎么解决线程安全问题呢?</h4><p>当多线程并发的环境下，有共享数据，并且这个数据还会被修改，此时就存在线程安全问题,怎么解决这个问题?<br>线程排队执行。(不能并发).用排队执行解决线程安全问题。这种机制被称为:线程同步机制。<br>专业术语叫做:线程同步，实际上就是线程不能并发了，线程必须排队执行。<br>怎么解决线程安全问题呀?<br>使用”线程同步机制”。<br>线程同步就是线程排队了，线程排队了就会牺牲一部分效率，没办法，数据安全第一位，只有数据安全了，我们才可以谈效率。数据不安全，没有效率的事儿。</p><h4 id="说到线程同步这块，涉及到这两个专业术语"><a href="#说到线程同步这块，涉及到这两个专业术语" class="headerlink" title="说到线程同步这块，涉及到这两个专业术语:"></a>说到线程同步这块，涉及到这两个专业术语:</h4><p>异步编程模型:<br>线程t1和线程t2，各自执行各自的，t1不管t2，t2不管t1，谁也不需要等谁,这种编程模型叫做:异步编程模型。其实就是:多线程并发(效率较高。)<br><strong>异步就是并发。</strong><br>同步编程模型:<br>线程t1和线程t2，在线程t1执行的时候，必须等待t2线程执行结束,或者说在t2线程执行的时候，必须等待t1线程执行结束，两个线程之间发生了等待关系，这就是同步编程模型。<br>效率较低。线程排队执行。<br><strong>同步就是排队。</strong></p><h2 id="21-synchronization"><a href="#21-synchronization" class="headerlink" title="21.synchronization"></a>21.synchronization</h2><p><strong>synchronization()</strong></p><p>()中写什么?<br>那要看你想让哪些线程同步。<br>假设t1、t2、t3、t4、t5，有5个线程，<br>你只希望t1 t2 t3排队，t4 t5不需要排队。怎么办?你一定要在()中写一个t1 t2 t3共享的对象。而这个对象对于t4 t5来说不是共享的。<br>这里的共享对象是:账户对象。<br>账户对象是共享的，那么this就是账户对象吧!!!不一定是this ，<strong>这里只要是多线程共享的那个对象就行。</strong></p><p><strong>在java语言中，任何一个对象都有一把锁”，其实这把锁就是标记。(只是把它叫做锁。)100个对象，100把锁。1个对象1把锁。</strong><br>以下代码的执行原理?<br>1、假设t1和t2线程并发，开始执行以下代码的时候，肯定有一个先一个后。<br>2、假设t1先执行了，遇到了synchronized，这个时候自动找后面共享对象”的对象锁，找到之后，并占有这把锁，然后执行同步代码块中的程序，在程序执行过程中一亘都是占有这把锁的。疸到同步代码块代码结束，这把锁才会释放。<br>3、假设t1已经占有这把锁，此时t2也遇到synchronized关键字，也会去占有后面共享对象的这把锁，结果这把锁被t1占有，t2只能在同步代码块外面等待t1的结束，亘到t1把同步代码块执行结束了，t1会归还这把锁，此时t2终于等到这把锁，然后t2占有这把锁之后，进入同步代码块执行程序。<br>这样就达到了线程排队执行。<br>这里需要注意的是:这个共享对象一定要选好了。这个共享对象一定是你需要排队执行的这些线程对象所共享的。</p><p>实例变量。( Account对象是多线程共享的，Account对象中的实例变量obj也是共享的）</p><h2 id="22-Java中有三大变量"><a href="#22-Java中有三大变量" class="headerlink" title="22.***Java中有三大变量?"></a>22.***Java中有三大变量?</h2><p>实例变量:在堆中。<br>静态变量:在方法区。<br>局部变量:在栈中。<br>以上三大变量中:<br>局部都变量永远都不会存在线程安全问题。<br>因为局部变量不共享。(一个线程一个栈。)<br>局部变量在栈中。所以局部变量永远都不会共享。实例变量在堆中，维只有1个.<br>静态变量在方法区中,方法区只有1个。<br>堆和方法区都是多线程共享的，所以可能存在线程安全问题。</p><p>在实例方法上可以使用synchronized吗?可以的。<br>synchronized出现在实例方法上，一定锁的是this。没得挑。只能是this。不能是其他的对象了。<br>所以这种方式不灵活。<br>另外还有一个缺点: synchronized出现在实例方法上，表示整个方法体都需要同步，可能会无故扩大同步的范围，导致程序的执行效率降低。所以这种方式不常用。</p><p>synchronized使用在实例方法上有什么优点?<br>代码写的少了。节俭了。<br>如果共享的对象就是this ，并且需要同步的代码块是整个方法体，建议使用这种方式。</p><p>如果使用局部变量的话:建议使用:stringBuilder.<br>因为局部变量不存在线程安全问题。选择stringBuilder.stringBuffer效率比较低.<br>ArrayList是非线程安全的。veator是线程安全的。<br>HashMap Hashset是非线程安全的。Hashtable是线程安全的。</p><h2 id="23-synchronized有三种写法"><a href="#23-synchronized有三种写法" class="headerlink" title="23.synchronized有三种写法:"></a>23.synchronized有三种写法:</h2><p>第一种:同步代码块<br>灵活<br>synchronized(线程共享对象){<br>同步代码块;<br>}<br>第二种:在实例方法上使用synchronized<br>表示共享对象一定是this<br>并且同步代码块是整个方法体。<br>第三种:在静态方法上使用synchronized<br>表示找类锁。<br>类锁永远只有1把。<br>就算创建了100个对象，那类锁也只有一把。<br>对象锁:1个对象1把锁，100个对象100把锁-类锁:10o个对象,也可能只是1把类锁、</p><h2 id="面试题1"><a href="#面试题1" class="headerlink" title="面试题1"></a>面试题1</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">dosome</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println( <span class="string">&quot;doSome begin&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sLeep( millis: <span class="number">1080</span> * <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    System.out.println( <span class="string">&quot;doSome over&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    pubiic <span class="keyword">void</span> <span class="title function_">doother</span><span class="params">()</span>&#123;<span class="comment">//没有synchronized</span></span><br><span class="line">        System.out.println( <span class="string">&quot;doOther begin&quot;</span> );</span><br><span class="line">        System.out.println(<span class="string">&quot;doOther over&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>虽然一个对象只有一把锁，但只有被synchronization修饰需要这把锁</strong></p><h2 id="24-死锁"><a href="#24-死锁" class="headerlink" title="24.死锁"></a>24.死锁</h2><p>不用我多说吧</p><h2 id="25-聊一聊，我们以后开发中应该怎么解决线程安全问题"><a href="#25-聊一聊，我们以后开发中应该怎么解决线程安全问题" class="headerlink" title="25.聊一聊，我们以后开发中应该怎么解决线程安全问题?"></a>25.聊一聊，我们以后开发中应该怎么解决线程安全问题?</h2><p>是一上来就选择线程同步吗?synchronized<br>不是，synchronized会让程序的执行效率降低，用户体验不好。系统的用户吞吐量降低。用户体验差。在不得已的情况下再选择线程同步机制。<br>第一种方案:尽量使用局部变量代替”实例变量和静态变量”。<br>第二种方案:如果必须是实例变量，那么可以考虑创建多个对象，这样<br>实例变量的内存就不共享了。(一个线程对应1个对象，100个线程对应100个对象，对象不共享,就没有数据安全问题了。）<br>第三种方案:如果不能使用局部变量，对象也不能创建多个，这个时候就只能选择synchronized了。线程同步机制。</p><h2 id="26-线程这块还有那些内容呢-列举一下"><a href="#26-线程这块还有那些内容呢-列举一下" class="headerlink" title="26.线程这块还有那些内容呢?列举一下"></a>26.线程这块还有那些内容呢?列举一下</h2><ul><li>守护线程</li><li>定时器</li><li>实现线程的第三种方式: FutureTask方式，实现callable接口。(JDK8新特性。)</li><li>关于object类中的wait和notify方法。(生产者和消费者模式! )</li></ul><h2 id="27-守护线程"><a href="#27-守护线程" class="headerlink" title="27.守护线程"></a>27.守护线程</h2><p>java语言中线程分为两大类:<br>一类是:用户线程<br>一类是:守护线程(后台线程)<br>其中具有代表性的就是:垃圾回收线程(守护线程）-守护线程的特点:<br>一般守护线程是一个<strong>死循环</strong>，<strong>所有的用户线程只要结束，守护线程自动结束。</strong><br>注意:主线程main方法是一个用户线程。守护线程用在什么地方呢?<br>每天00:00的时候系统数据自动备份。<br>这个需要使用到定时器，并且我们可以将定时器设置为守护线程。一直在那里看着，没到00:00的时候就备份一次。所有的用户线程如果结束了，守护线程自动退出，没有必要进行数据备份了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest14</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BakDataThread</span>( );</span><br><span class="line">t.setName(<span class="string">&quot;备份数据的线程&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动线程之前，将线程设置为守护线程</span></span><br><span class="line">    t.setDaemon(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    t.start();</span><br><span class="line"><span class="comment">//主线程∶主线程是用户线程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        system.out.println(Thread.currentThread( ).getName( ) + <span class="string">&quot;---&gt;&quot;</span> + i);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>) ;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace( );</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BakDataThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//即使是死循环，但由于该线程是守护者，当用户线程结束，守护线程自动终止。|while(true)&#123;</span></span><br><span class="line">        system.out.println( Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + (++i))</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printstackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置守护线程方法</p><p><strong>thread.setDaemon()</strong></p><h2 id="28-定时器"><a href="#28-定时器" class="headerlink" title="28.定时器"></a>28.定时器</h2><p>定时器的作用:<br><strong>间隔特定的时间,执行特定的程序-</strong><br>每周要进行银行账户的总账操作。每天要进行数据的备份操作。<br>在实际的开发中，每隔多久执行一段特定的程序，这种需求是很常见的，那么在java中其实可以采用多种方式实现:<br>可以使用sleep方法，睡眠，设置睡眠时间，没到这个时间点醒来，执行任务。这种方式是最原始的定时器。(比较low)<br>在java的类库中已经写好了一个定时器: java.util.Timer，可以直接拿来用。不过，这种方式在目前的开发中也很少用，因为现在有很多高级框架都是支持定时任务的。<br>在实际的开发中，目前使用较多的是spring框架中提供的springTask框架这个框架只要进行简单的配置，就可以完成定时器的任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">timerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建定时器对象</span></span><br><span class="line">        <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">        <span class="comment">//Timer timer = new Timer(true); //守护线程的方式</span></span><br><span class="line">        <span class="comment">//指定定时任务</span></span><br><span class="line">        <span class="comment">//timer.schedule(定时任务，第一次执行时间，间隔多久执行一次);</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span> );</span><br><span class="line">        <span class="type">Date</span> <span class="variable">firstTime</span> <span class="operator">=</span> sdf.parse(<span class="string">&quot;202e-03-14 09:3e:ee&quot;</span>);</span><br><span class="line">        timer.schedule(<span class="keyword">new</span> <span class="title class_">LogTimerTask</span>() , firstTime，period: <span class="number">1000</span> *<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//编写一个定时任务类</span></span><br><span class="line"><span class="comment">//假设这是一个记录日志的定时任务</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogTimerTask</span> <span class="keyword">extends</span> <span class="title class_">TimerTask</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//编写你需要执行的任务就行了。</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">strTime</span> <span class="operator">=</span> sdf.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        system.out.println(strTime + <span class="string">&quot;:成功完成了一次数据备份!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用匿名内部类</p><h2 id="29-线程第三种实现方式（JDK8新特性）"><a href="#29-线程第三种实现方式（JDK8新特性）" class="headerlink" title="29.线程第三种实现方式（JDK8新特性）"></a>29.线程第三种实现方式（JDK8新特性）</h2><p>这种方式实现的线程可町以获取线程的返回值-<br>之前讲解的那两种方式是无法获取线程返回值的，<strong>因为run方法返回void.</strong><br>思考:<br>系统委派一个线程去执行一个任务，该线程执行完任务之后，可能会有一个执行结果，我们怎么能拿到这个执行结果呢?<br>使用第三种方式:实现callable接口方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest15</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[ ] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//第一步:创建一个未来任务类”对象。</span></span><br><span class="line">        <span class="comment">//参数非常重要，需要给一个CalLable接口实现类对象。</span></span><br><span class="line">        <span class="type">FutureTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(<span class="keyword">new</span> <span class="title class_">Callable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> 0bject <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123; <span class="comment">// call()方法就相当于run方法。只不过这个有返回值</span></span><br><span class="line">                <span class="comment">//线程执行一个任务，执行之后可能会有一个执行结果</span></span><br><span class="line">                <span class="comment">//模拟执行</span></span><br><span class="line">                System.out.println(<span class="string">&quot;ca11 method begin&quot;</span> );</span><br><span class="line">                Thread.sleep( <span class="number">1008</span>* <span class="number">10</span>) ;</span><br><span class="line">                System.out.println(<span class="string">&quot;call method end! &quot;</span> );</span><br><span class="line">                <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">                <span class="keyword">return</span> a+b;  <span class="comment">//自动装箱，300结果变成Integer</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">                </span><br><span class="line"><span class="comment">//创建线程对象</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">    <span class="comment">//启动线程</span></span><br><span class="line">    t.start( );</span><br><span class="line">    <span class="comment">//这里是main方法，这是在主线程中。</span></span><br><span class="line">    <span class="comment">//在主线程中，怎么获取t线程的返回结果?</span></span><br><span class="line"><span class="comment">//get()方法的执行会导致““当前线程阻塞”</span></span><br><span class="line"><span class="type">object</span> <span class="variable">obj</span> <span class="operator">=</span> task.get();</span><br><span class="line">    system.out.print1n(<span class="string">&quot;线程执行结果:&quot;</span> +obj);</span><br><span class="line">    <span class="comment">//main方法这里的程序要想执行必须等待get()方法的结束</span></span><br><span class="line">    <span class="comment">//而get()方法可能需要很久。因为get()方法是为了拿另一个线程的执行结果</span></span><br><span class="line"><span class="comment">//另一个线程执行是需要时间的。</span></span><br><span class="line">    System.out.print1n( <span class="string">&quot;hello wor1d! &quot;</span>);</span><br><span class="line">&#125;                                                                          </span><br></pre></td></tr></table></figure><ul><li>main方法这里的程序要想执行必须等待get()方法的结束</li><li>而get()方法可能需要很久。因为get()方法是为了拿另一个线程的执行结果</li><li>另一个线程执行是需要时间的。</li></ul><p>——    可以获取到线程的返回结果</p><p>——效率比较低，在获取t线程执行结果的时候，当前线程受阻塞，效率较低</p><h2 id="30-关于Object类中的wait和notify方法"><a href="#30-关于Object类中的wait和notify方法" class="headerlink" title="30.关于Object类中的wait和notify方法"></a>30.关于Object类中的wait和notify方法</h2><p>第一: <strong>wait和notify方法不是线程对象的方法，是java中任何一个java对象都有的方法，因为这两个方式是object类中自带的。</strong><br><strong>wait方法和notify方法不是通过线程对象调用，</strong>不是这样的: t.wait()，也不是这样的: t.notify()..不对。</p><p>第二: wait()方法作用?<br>object o &#x3D; new Object() ;</p><p>o. wait() ;<br>表示:<br>让正在o对象上活动的线程进入等待状态，无期限等待，直到被唤醒为止.<br>o.wait();方法的调用，会让”当前线程（正在o对象上活动的线程)”进入等待状态,l</p><p>第三: notify()方法作用?</p><p>object o &#x3D; new Object () ;</p><p>o.notify () ;<br>表示:<br>唤醒正在o对象上等待的线程。还有一个notifyAl1()方法:</p><p><strong>这个方法是唤醒o对象上处于等待的所有线程。</strong></p><img src="/2022/10/08/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%80/3.png" alt="image-20221004140839660" style="zoom:67%;"><img src="/2022/10/08/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%80/2.png" alt="image-20221004104504639" style="zoom:67%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、使用wait方法和notify方法实现(生产者和消费者模式”)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2、什么是“&quot;生产者和消费者模式”?</span></span><br><span class="line"><span class="comment">生产线程负责生产，消费线程负责消费。生产线程和消费线程要达到均衡。</span></span><br><span class="line"><span class="comment">这是一种特殊的业务需求，在这种特殊的情况下需要使用vait方法和notify方法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3、wait和notify方法不是线程对象的方法，是普通java对象都有的方法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4、wait方法和notify方法建立在线程同步的基础之上。因为多线程要同时操作一个仓库。有线程安全问题。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">5、wait方法作用: o.wait()让正在o对象上活动的线程t进入等待状态，并且释放掉t线程之前占有的o对象的锁。·</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">6、notify方法作用: o.notify()让正在o对象上等待的线程唤醒，只是通知，不会释放o对象上之前占有的锁。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">7、模拟这样一个需求:</span></span><br><span class="line"><span class="comment">仓库我们采用List集合。</span></span><br><span class="line"><span class="comment">List集合中假设只能存储1个元素。1个元素就表示仓库满了。</span></span><br><span class="line"><span class="comment">如果List集合中元素个数是e，就表示仓库空了。保证List集合中永远都是最多存储1个元素。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">必须做到这种效果:生产1个消费1个。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest16</span> &#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( string[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个仓库对象，共享的</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="comment">//创建两个线程</span></span><br><span class="line">        <span class="comment">//生产者线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Product</span>(list));</span><br><span class="line">        <span class="comment">//消费者线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer</span>(list));</span><br><span class="line">        </span><br><span class="line">        t1.setName(<span class="string">&quot;生产者线程&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;消费者线程&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产线程</span></span><br><span class="line">c1ass Producer imp1ements Runnable &#123;</span><br><span class="line">    <span class="comment">//仓库</span></span><br><span class="line">    <span class="keyword">private</span> List list; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Product</span><span class="params">(List list)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list = list;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">( )</span> &#123;</span><br><span class="line">        <span class="comment">//一直生产（使用死循环来模拟一直生产）</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//给仓库对象List加锁。</span></span><br><span class="line">            <span class="keyword">synchronized</span> (list)&#123;</span><br><span class="line">                <span class="keyword">if</span>(1ist.size() &gt; <span class="number">0</span>)&#123;<span class="comment">//大于0，说明仓库中已经有1个元素了。</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//当前线程进入等待状态，并且释放Producer之前占有的List集合的锁。</span></span><br><span class="line">                        list.wait();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//程序能够执行到这里说明仓库是空的，可以生产object obj = new Object();</span></span><br><span class="line">                list.add(obj);</span><br><span class="line">                System.out.println(Thread.currentThread( ) .getName() + <span class="string">&quot;---&gt;&quot;</span> + obj);</span><br><span class="line">                <span class="comment">//唤醒消费者进行消费</span></span><br><span class="line">                list.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> imp1ements Runnable &#123;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//仓库</span></span><br><span class="line">    <span class="keyword">private</span> List list; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(List list)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list = list;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">( )</span> &#123;</span><br><span class="line">    <span class="comment">//一直消费</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>( list.size() == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//仓库已经空了。</span></span><br><span class="line">                <span class="comment">//消费者线程等待，释放掉list集合的锁</span></span><br><span class="line">                    list.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedExceptioh e) &#123;</span><br><span class="line">                    e.printstackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//程序能够执行到此处说明仓库中有数据，进行消费。</span></span><br><span class="line">            <span class="type">object</span> <span class="variable">obj</span> <span class="operator">=</span> list.remove(<span class="number">0</span>);</span><br><span class="line">            System.out.println(Thread.currentThread( ).getName() + <span class="string">&quot;---&gt;&quot;</span> + obj);</span><br><span class="line">            <span class="comment">//唤醒生产者生产。</span></span><br><span class="line">            list.notify();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 高并发 </tag>
            
            <tag> 多线程 </tag>
            
            <tag> thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM(一)</title>
      <link href="/2022/10/08/JVM-%E4%B8%80/"/>
      <url>/2022/10/08/JVM-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="1、JVM基础"><a href="#1、JVM基础" class="headerlink" title="1、JVM基础"></a>1、JVM基础</h2><p><img src="/2022/10/08/JVM-%E4%B8%80/1.png" alt="image-20220925110713917"></p><p><img src="/2022/10/08/JVM-%E4%B8%80/2.png" alt="image-20220925110752227"></p><p><img src="/2022/10/08/JVM-%E4%B8%80/3.png" alt="image-20220925110822373"></p><p>——————–JVM与java无关，只与**.class**文件有关</p><p><strong>JVM是一种规范，它定义了java虚拟机应该执行什么，java虚拟机应该具备哪些模块，遇到哪些指令应该做什么等等</strong></p><p><img src="/2022/10/08/JVM-%E4%B8%80/4.png" alt="image-20220925111215847"></p><p>我们常用的是Hotspot：</p><p><img src="/2022/10/08/JVM-%E4%B8%80/5.png" alt="image-20220925113617889"></p><p>类编译，加载，初始化</p><p>类加载过程</p><p><img src="/2022/10/08/JVM-%E4%B8%80/6.png" alt="image-20220925130824497"></p><p>注意Bootstrap是C++实现的，调用**getClassLoader()**方法会返回空，因为Jave中没有一个class和她对应，所以会返回null</p><p>双亲委派：不是语法上的继承关系，即不是继承机制</p><p>为什么需要双亲委派机制：安全问题，防止自己写的<strong>java.lang.string</strong>覆盖原生的</p><p><img src="/2022/10/08/JVM-%E4%B8%80/7.png" alt="image-20220925132327032"></p><p>每个加载器都有自己的缓存</p><p><img src="/2022/10/08/JVM-%E4%B8%80/8.png" alt="image-20220925134458883"></p><p>对于没有依赖关系的两个变量初始化，CPU可能会进行指令重排，所以需要加Volatile：</p><h2 id="1-2-ClassFileFormat"><a href="#1-2-ClassFileFormat" class="headerlink" title="1.2 ClassFileFormat"></a>1.2 ClassFileFormat</h2><p><img src="/2022/10/08/JVM-%E4%B8%80/39.png" alt="image-20221004220136856"></p><ul><li>二进制字节流</li><li>数据类型： u1，u2，u4，u8和 _info(表类型)      <strong>u1一个字节（无符号） u2俩个字节（无符号）以此类推</strong></li></ul><p>​ –_info来源是hotspot源码中的写法</p><ul><li>查看16进制的ClassFile</li></ul><p>​–sublime &#x2F; notepad &#x2F;<br>​–IDEA插件-BinEd</p><p>​–<img src="/2022/10/08/JVM-%E4%B8%80/38.png" alt="image-20221004215735612" style="zoom:67%;"></p><ul><li>有很多可以观察ByteCode的方法</li></ul><p>​–iavap<br>​–JBE -可以直接修改<br>​–JClassLib - IDEA插件之一</p><p>​–<img src="/2022/10/08/JVM-%E4%B8%80/40.png" alt="image-20221004220452674" style="zoom:50%;"></p><ul><li><p>classfile构成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4magic;</span><br><span class="line">    u2minor_version;</span><br><span class="line">    u2major_version;</span><br><span class="line">    u2constant_poo1_count;//数组16，下标从1开始，0下标留着备用</span><br><span class="line">    cp_info constant_poo1[constant_poo1_count - 1];</span><br><span class="line">u2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="1-3对象头包括什么"><a href="#1-3对象头包括什么" class="headerlink" title="1.3对象头包括什么"></a>1.3对象头包括什么</h2><p><img src="/2022/10/08/JVM-%E4%B8%80/41.png" alt="image-20221004221345407"></p><ul><li><p>mark word</p><ul><li><p>锁信息</p></li><li><p>GC</p></li><li><p>identity HasCode（没有重写的HasCode）</p></li></ul></li></ul><h2 id="1-4对象定位"><a href="#1-4对象定位" class="headerlink" title="1.4对象定位"></a>1.4对象定位</h2><img src="/2022/10/08/JVM-%E4%B8%80/42.png" alt="image-20221005091628138"><h2 id="1-5对象怎么分配"><a href="#1-5对象怎么分配" class="headerlink" title="1.5对象怎么分配"></a>1.5对象怎么分配</h2><ul><li>优先存在栈上?（判断是否逃逸：没有引用指向她？）（<strong>不用GC，随着方法结束弹出栈，效率快，快</strong>） </li><li>老年代（大对象）</li><li>线程本地缓冲区（TLAB）</li></ul><p>​–ThreadLoacl  （TL）</p><p>​–AllocationBuffer（AB）</p><ul><li>伊甸区</li></ul><p>​–<strong>线程的小小空间</strong>，<strong>每个线程自己的TLAB</strong>（3个线程抢位置，谁抢到给谁分配，算法为碰撞指针，总而言之，JVM得协调，这样会消耗资源，<strong>与其这样，不如给每个线程一块小小空间（TLAB）</strong>）</p><ul><li><p>GC</p></li><li><p><strong>幸存区1，幸存区2，循环往复，直到年龄够大</strong></p></li><li><p>老年代</p></li><li><p>FullGC</p></li></ul><h2 id="1-6一个Object占多少字节"><a href="#1-6一个Object占多少字节" class="headerlink" title="1.6一个Object占多少字节"></a>1.6一个Object占多少字节</h2><ul><li><p>Object obj &#x3D; new Object();</p><ul><li>普通的对象new出来16个字节</li></ul></li><li><p>mark word  8个字节</p><ul><li>默认压缩情况下classPointer 4个字节</li></ul></li><li><p>对齐 4个字节</p></li></ul><h2 id="1-7对象创建过程"><a href="#1-7对象创建过程" class="headerlink" title="1.7对象创建过程"></a>1.7对象创建过程</h2><ul><li>第一步默认值</li><li>第二步初始值</li><li>第三步建立关联</li></ul><p><img src="/2022/10/08/JVM-%E4%B8%80/43.png" alt="image-20221005113805878"></p><h2 id="1-8单例模式"><a href="#1-8单例模式" class="headerlink" title="1.8单例模式"></a>1.8单例模式</h2><p><strong>提示：static private final</strong></p><p>饿汉式：二话不说现直接创建对象，类似悲观锁</p><p>懒汉式：类似按需加载DLC（双检锁）加 Volatile</p><ul><li>反例破坏单例</li><li>反序列化破坏单例</li><li>Unsafe破坏单例</li></ul><p>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Mgr06 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//业务逻辑代码省略</span></span><br><span class="line">    <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123; <span class="comment">//Double Check Lock</span></span><br><span class="line">    <span class="comment">//双重检查</span></span><br><span class="line">        <span class="keyword">synchronized</span> (Mgr06.class) &#123;</span><br><span class="line">            <span class="keyword">if</span>( INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(  <span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace( );</span><br><span class="line">                &#125;</span><br><span class="line">                INSTANCE = <span class="keyword">new</span> <span class="title class_">Mgr06</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h4><p>compare and swap(比较并交换)自旋锁，乐观锁</p><h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><p><img src="/2022/10/08/JVM-%E4%B8%80/44.png" alt="image-20221005112639267"></p><p>版本号解决，加一个版本号</p><h4 id="CPU乱序执行"><a href="#CPU乱序执行" class="headerlink" title="CPU乱序执行"></a>CPU乱序执行</h4><p><strong>CPU速度比内存快100倍</strong></p><p><strong>CPU（是CPU）指令乱序执行</strong></p><p>CPU在进行<strong>读等待的同时执行指令</strong>，是CPU乱序的，<strong>根源不是乱，而是提高效率</strong></p><p><img src="/2022/10/08/JVM-%E4%B8%80/45.png" alt="image-20221005105440655"></p><h2 id="1-9DCL和Volatile"><a href="#1-9DCL和Volatile" class="headerlink" title="1.9DCL和Volatile"></a>1.9DCL和Volatile</h2><p><img src="/2022/10/08/JVM-%E4%B8%80/46.png" alt="image-20221005114703529"></p><p><strong>new了一半，指令重排，先关联，构造还没调用，直接返回了（详情请看单例模式和对象new的过程）</strong></p><h2 id="2、GC"><a href="#2、GC" class="headerlink" title="2、GC"></a>2、GC</h2><h4 id="1-从本质谈起"><a href="#1-从本质谈起" class="headerlink" title="1.从本质谈起"></a>1.从本质谈起</h4><p><strong>QQ.exe</strong> —–&gt;操作系统load到内存——–&gt;<strong>形成进程，进程里包含一条一条指令</strong>——-&gt;CPU一条一条的拿数据执行（需要内存的辅助）</p><p><img src="/2022/10/08/JVM-%E4%B8%80/9.png" alt="image-20220928130451378"></p><h4 id="2-程序的栈（stack-frame）和堆"><a href="#2-程序的栈（stack-frame）和堆" class="headerlink" title="2.程序的栈（stack frame）和堆"></a>2.程序的栈（stack frame）和堆</h4><p><img src="/2022/10/08/JVM-%E4%B8%80/10.png" alt="image-20220929190541995"></p><p>栈的内存空间：自动管理（方法执行完自动弹出）</p><p>堆内存管理：多年的难题</p><h4 id="3-最难调试的Bug"><a href="#3-最难调试的Bug" class="headerlink" title="3.最难调试的Bug"></a>3.最难调试的Bug</h4><ul><li><p>野指针</p><p>–同一个对象，两个指针，另一个不知道还拿来用</p><p>–同一个指针不同位置</p><p>–不再指向任何对象的指针</p><p>–NullPointException</p><p>例如：</p><p><img src="/2022/10/08/JVM-%E4%B8%80/11.png" alt="image-20220929193002660"></p><p>图中m()方法把对象给干掉了，main方法中的O也指向了该对象，导致o指向空对象，更有甚者，这块内存又被别人给占了，那么o就会指向别人的对象（<strong>GO语言诞生：Google为了替代以前写过的C语言程序，C语言写程序写起来方便，快，但维护特别麻烦，Bug调试起来特别困难，所以开发Go语言，不在手工维护这些内存空间，而是和Java一样引入GC</strong>）</p></li><li><p>并发问题</p><p>–<strong>多线程访问同一块内存空间</strong></p></li></ul><p>为什么分层，分代，因为以整块内存只用一种算法怎么算都有毛病，所以需要分层，使用综合算法</p><h2 id="3、语言的发展历史"><a href="#3、语言的发展历史" class="headerlink" title="3、语言的发展历史"></a>3、语言的发展历史</h2><p><strong>向着Bug容易调试的方向发展</strong></p><ul><li><p>C&#x2F;C++</p><p>–手工管理内存：malloc等，free&#x2F; new delete（各种判断，各种麻烦的Bug）</p><p>–<strong>忘记删除忘记释放（memory leak    太多导致    out of memory） —————–最次调优——–重启</strong></p><img src="/2022/10/08/JVM-%E4%B8%80/12.png" alt="image-20220929203045722" style="zoom: 50%;"><p>–释放多次（鞭尸问题倒不是很大），产生极难调试的Bug，一个线程空间莫名奇妙的被另一个释放了。</p><img src="/2022/10/08/JVM-%E4%B8%80/13.png" alt="image-20220929203845762" style="zoom: 80%;"><p>–<strong>开发效率很低，运行速率很高</strong></p></li><li><p>Java，python，go</p><p>–方便内存管理的语言，问题还是存在，</p><p>–GC –Garbage Collection  （原来需要小心翼翼的管理，不能多删，不能误删，现在不需要，<strong>我们只管分配内存</strong>，不需要自己去维护删除这块，但是谁来帮我们管理删除这块？这就需要另起一个线程—-GC来帮我们管理，业务线程起来之后，还会启动许多线程，其中就包括GC）</p><p>如下图：不断分配内存，迟早爆炸</p><img src="/2022/10/08/JVM-%E4%B8%80/14.png" alt="image-20220929205519946" style="zoom: 67%;"><p>–大大降低程序员的门槛（空指针依然存在NullpointException，你懂的）</p><p>–<strong>效率降低（多开了线程，必然的）</strong></p><p>– JIT（Just IN TIME，重复，多次使用的代码保存到本地）只有一小段代码与C效率一样</p><p>–架构师思维（达成目的的工具，各有各的特点）</p></li><li><p>rust</p><p>–运行效率超高（asm C C++）</p><p>–<strong>不用手工管理内存（没有GC）</strong></p><p>–<strong>学习曲线巨高</strong>（ownership所有权）</p><p>一个变量有且只有一个值，即多个变量指向同一个内存这种现象不会发生，这就是所有权的概念（一夫一妻制）</p><p>–只要程序语法通过，就不会有Bug（语法非常特殊）（不是逻辑Bug）</p></li></ul><h2 id="4、Garbage-（什么是垃圾）"><a href="#4、Garbage-（什么是垃圾）" class="headerlink" title="4、Garbage?（什么是垃圾）"></a>4、Garbage?（什么是垃圾）</h2><p>什么是垃圾—————在运行过程中，没有任何引用指向他（对象）</p><img src="/2022/10/08/JVM-%E4%B8%80/15.png" alt="image-20220929212549906" style="zoom: 50%;"><h2 id="5、How-To-Find-Garbage-（如何定位垃圾）"><a href="#5、How-To-Find-Garbage-（如何定位垃圾）" class="headerlink" title="5、How To Find Garbage?（如何定位垃圾）"></a>5、How To Find Garbage?（如何定位垃圾）</h2><p>有两种方法</p><h5 id="第一种：reference-count（引用计数）"><a href="#第一种：reference-count（引用计数）" class="headerlink" title="第一种：reference count（引用计数）"></a>第一种：reference count（引用计数）</h5><img src="/2022/10/08/JVM-%E4%B8%80/16.png" alt="image-20220929213055291" style="zoom:50%;"><p><strong>如上图，一个引用消失，数字减一。</strong></p><p>缺点：循环引用： A-&gt;B,B-&gt;C,C-&gt;A  （<strong>一个个垃圾变成一坨垃圾！！！</strong>）</p><img src="/2022/10/08/JVM-%E4%B8%80/17.png" alt="image-20220929213329706" style="zoom:33%;"><h5 id="第二种：Root-Searching（根可达算法）"><a href="#第二种：Root-Searching（根可达算法）" class="headerlink" title="第二种：Root Searching（根可达算法）"></a>第二种：Root Searching（根可达算法）</h5><img src="/2022/10/08/JVM-%E4%B8%80/18.png" alt="image-20220929213634483" style="zoom: 33%;"><p><strong>顺着根找</strong>（什么是根？一般是main函数中的new，你懂的）</p><h2 id="6、Garbage-Algorithms（清除算法）"><a href="#6、Garbage-Algorithms（清除算法）" class="headerlink" title="6、Garbage Algorithms（清除算法）"></a>6、Garbage Algorithms（清除算法）</h2><ul><li>Mark Sweep（标记清除）</li><li>Copying（拷贝）</li><li>Mark-Compact（标记压缩）</li></ul><h4 id="1-Mark-Sweep（标记清除）"><a href="#1-Mark-Sweep（标记清除）" class="headerlink" title="1. Mark Sweep（标记清除）"></a>1. Mark Sweep（标记清除）</h4><img src="/2022/10/08/JVM-%E4%B8%80/19.png" alt="image-20220930083631352" style="zoom:50%;"><p>顺着根开始找，找的到的（有引用的）全都不是垃圾，<strong>找不到的全是垃圾</strong>，清除！！！</p><p>缺点：内存变得碎片化，如上图，东一片，西一片，这时候要是来了一片大内存分配下去，<strong>你会发现找不到内存分配</strong></p><h4 id="2-Copying（拷贝）"><a href="#2-Copying（拷贝）" class="headerlink" title="2. Copying（拷贝）"></a>2. Copying（拷贝）</h4><img src="/2022/10/08/JVM-%E4%B8%80/20.png" alt="image-20220930084206447" style="zoom:50%;"><p>将内存一分为二，设为内存A，内存B，内存A顺着根开始找，把找的到的（即不是垃圾的），<strong>排好序</strong>，复制到另一块内存B，清空内存A，</p><p><strong>效率也很高</strong></p><p>缺点：<strong>浪费内存</strong></p><h4 id="3-Mark-Compact（标记压缩）"><a href="#3-Mark-Compact（标记压缩）" class="headerlink" title="3. Mark-Compact（标记压缩）"></a>3. Mark-Compact（标记压缩）</h4><img src="/2022/10/08/JVM-%E4%B8%80/21.png" alt="image-20220930085025365" style="zoom:50%;"><p>在回收的时候，顺便排序，让内存是连续的，其余的内存都是可用的，如上图，</p><p>缺点：<strong>效率低！！！！</strong></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>三总算法都有毛病，当你把内存分成一整块的时候，不管是哪种算法都有毛病，<strong>所有GC非常聪明，他是对这三种算法进行综合运用，同时对内存进行了划分，三种算法的综合运用诞生了各种各样的垃圾回收器，每一种都有自己的特点</strong></p><h2 id="7、Garbage-Collectors（垃圾回收器）"><a href="#7、Garbage-Collectors（垃圾回收器）" class="headerlink" title="7、Garbage Collectors（垃圾回收器）"></a>7、Garbage Collectors（垃圾回收器）</h2><h4 id="1-总图"><a href="#1-总图" class="headerlink" title="1. 总图"></a>1. 总图</h4><img src="/2022/10/08/JVM-%E4%B8%80/22.png" alt="image-20220930090038852" style="zoom:50%;"><h4 id="2-GC的演化"><a href="#2-GC的演化" class="headerlink" title="2. GC的演化"></a>2. GC的演化</h4><p>随着内存大小的不断增大而演进</p><p>几兆——几十兆</p><p>​–Serial 单线程STW垃圾回收 年青代，老年代</p><p>几十兆——上百兆1G（房间变大了，只有妈妈一个人不够用）</p><p>​–parallel 并行多线程</p><p>几十个G</p><p>​–</p><p>​–内存越来越大，来多少人都不够，线程越多，效率越高？，不一定，又阈值，超过阈值，效率反而降低</p><p>​<strong>原因：CPU一个核同一时刻只能执行一个线程，16核16线程，1000个线程跑进来会进行排队，切换</strong></p><p>​<strong>执行你回儿，执行他一会儿，这个过程叫线程切换，线程切换也是需要消耗CPU资源的，线程切换所需的资源就超过了线程本身运行所需要的资源</strong></p><p>​–效率提不上去？——惊天地泣鬼神的<strong>Concurrent GC</strong>出现了  </p><h4 id="–Concurrent"><a href="#–Concurrent" class="headerlink" title="–Concurrent"></a>–Concurrent</h4><p>从线程的角度：</p><p>业务线程和GC线程同时运行，之前的是业务线程和GC只能跑一个，因为STW（stop-the-world）</p><p>业务线程永远有响应</p><p>产生各种麻烦的问题——一边制造垃圾，一边清理垃圾</p><h4 id="3-内存分代模型（前6种）"><a href="#3-内存分代模型（前6种）" class="headerlink" title="3. 内存分代模型（前6种）"></a>3. 内存分代模型（前6种）</h4><img src="/2022/10/08/JVM-%E4%B8%80/23.png" alt="image-20220930090825869" style="zoom:50%;"><p><strong>新生代：</strong>  </p><p>刚刚诞生的对象，年轻的，频繁被GC扫，</p><p><strong>老年代：</strong>GC扫描多次后都没有进行回收，说明是个老顽固，如果在扫描就是浪费资源，所以把它放到老年代，等到老年代内存满了，装不下了，就扫描一次老年代清掉没用的垃圾</p><p><strong>总结</strong>：<strong>综合算法的体现，新生代使用Copying算法，老年代使用Mark Sweep或者Mark-Compact又或者两者都使用</strong>，<strong>jdk1.8或者以前所采用的都是分代模型</strong></p><p>​–年轻代的Copying算法与上面的有点不一样，年轻代的Copying算法是根据工业实践的出来的结果，一般来说，一次年轻代的回收   称为min GC 或者 YGC，大概会回收90%的对象，剩下的只有10%，没必要分成两半，一般是</p><p>​8（eden）：1（survivor）：1（survivor）</p><p>例如：</p><p>​10个对象刚刚被创建出来，放在eden区，一次GC干掉了90%，还剩一个对象放在survivor1区，eden整体清空，第二次又创建了10个对象放在eden区，这时候会扫描eden区和survivor1区，又干掉90%，把存活下来的放在survivor2区，eden和survivor1区整体清空，第三次则存活下来的则是放在survivor1区，eden和survivor2区整体清空，如此循环往复。十分简单，当survivor装不下放入老年代，<strong>老年代满了FullGC</strong></p><p><strong>方法区：1.7之前永久代，1.8之后叫元空间，不管怎么变都叫方法区</strong></p><h5 id="Serial（在年青代工作）（单线程）"><a href="#Serial（在年青代工作）（单线程）" class="headerlink" title="Serial（在年青代工作）（单线程）"></a>Serial（在年青代工作）（单线程）</h5><p>你，你女盆友，你男盆友，哥三儿在房间里（年青代）扔纸团，扔到满了，这时候妈妈（GC）进来了，停止扔纸团（业务线程停止）不管做什么，什么姿势，都不许动了，这时候妈妈根查找清理没用的线团（垃圾）清完之后才能动，又继续玩，继续扔线团</p><img src="/2022/10/08/JVM-%E4%B8%80/24.png" alt="image-20220930102733438" style="zoom:50%;"><p><strong>停止这段时间称为——stop-the-world（STW）</strong></p><p>内存小，一个线程足矣</p><h5 id="Serial-Old（在老年代工作）"><a href="#Serial-Old（在老年代工作）" class="headerlink" title="Serial Old（在老年代工作）"></a>Serial Old（在老年代工作）</h5><p>在老年代也是如此，也是一个线程，只不过算法不一样</p><img src="/2022/10/08/JVM-%E4%B8%80/25.png" alt="image-20220930103021181" style="zoom:50%;"><h5 id="parallel-Scavenge（多线程，年青代）"><a href="#parallel-Scavenge（多线程，年青代）" class="headerlink" title="parallel Scavenge（多线程，年青代）"></a>parallel Scavenge（多线程，年青代）</h5><p><strong>1.8默认垃圾回收器</strong></p><p>还是哥三儿，不过这次房间（内存）满了，不止妈妈进来清扫，还有爷爷，姥姥，舅舅进来清扫（多线程）</p><h5 id="parallel-Old（多线程，老年代）"><a href="#parallel-Old（多线程，老年代）" class="headerlink" title="parallel Old（多线程，老年代）"></a>parallel Old（多线程，老年代）</h5><p>查看默认GC命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintCommandLineFlags -version</span><br></pre></td></tr></table></figure><p><img src="/2022/10/08/JVM-%E4%B8%80/26.png" alt="image-20220930104229448"></p><p>-XX:+UseParallelGC       &#x2F;&#x2F;意思是parallel Scavenge+parallel Old  组合</p><h5 id="开天辟地Concurrent的第一个垃圾回收器——CMS"><a href="#开天辟地Concurrent的第一个垃圾回收器——CMS" class="headerlink" title="开天辟地Concurrent的第一个垃圾回收器——CMS"></a>开天辟地Concurrent的第一个垃圾回收器——CMS</h5><p>CMS全称——concurrent mark sweep（并发的标记清除）（工作在老年代）</p><p>第一个Concurrent，像秦始皇，有天生的Bug</p><h5 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h5><img src="/2022/10/08/JVM-%E4%B8%80/27.png" alt="image-20220930115002678" style="zoom:33%;"><p>工作在年青代的<strong>多线程</strong>，与CMS打配合</p><p>​–为什么不用 parallel？</p><p>​enhancement 增强，是Parallel Scavenge的增强，为了配合CMS</p><h5 id="垃圾回收器CMS算法理论"><a href="#垃圾回收器CMS算法理论" class="headerlink" title="垃圾回收器CMS算法理论"></a>垃圾回收器CMS算法理论</h5><img src="/2022/10/08/JVM-%E4%B8%80/28.png" alt="image-20220930120311581" style="zoom:50%;"><p>底层角度：6个阶段</p><p>线程角度：4个阶段</p><p>线程角度：</p><ul><li><p>初始标记，找到根对象，只需找到跟对象，依然会STW，但是根对象相对较少，所以STW会很快</p></li><li><p>并发标记，业务线程继续，业务一边运行，GC一边工作（标记），一定会存在错标，</p><p>–错标主要有两种情况，垃圾变成不是垃圾，不是垃圾变成垃圾</p><p>–<strong>著名的三色标记算法发生在此阶段</strong></p></li><li><p>重新标记，修正过程，业务线程不能继续，都发生错误了，肯定不能继续，也会发生STW</p></li><li><p>并发清理</p></li></ul><h4 id="4-三色标记算法"><a href="#4-三色标记算法" class="headerlink" title="4. 三色标记算法"></a>4. 三色标记算法</h4><p>并发标记阶段，还没有清理，只是在标记，业务线程一边运行，GC一边找，GC就会问哥们儿是垃圾吗？哥们儿是垃圾吗？哥们儿是垃圾吗？因为线程会切换，同一个线程会隔一段时间运行隔一段时间运行，所以需要把状态保存下来，如上一次运行扫描到50%这个程度了，下次要在这个基础之上继续扫描，直到扫描完全部才算结束，然后才开始清理</p><p>小知识：线程的运行时间是由操作系统来进行调度的，他调度的时间片以及时间长都不是固定的，LinuxCPU内核采用的是CFS（完全公平算法）算法，<strong>所以必须要把标记到那里保存下来，怎么记录下来呢，采用的就是三色标记算法</strong></p><img src="/2022/10/08/JVM-%E4%B8%80/29.png" alt="image-20220930171816913" style="zoom:50%;"><p>黑色：孩子都扫描完，黑色</p><p>灰色：孩子未扫描完，灰色</p><p>白色：没用遍历到的节点，白色，枚举完还是白色，当垃圾清除</p><p>用两位来标记颜色（00 01 10 11），标记在对象上，放在mark word（详情看**.class文件解读**）上</p><p><strong>两个问题（详情CSDN三色标记）</strong></p><p>本应该是垃圾的对象被视为非垃圾（问题不大）</p><p>一个本不应该是垃圾的对象被视为垃圾（GG）</p><p>所以需要remark（重新标记阶段），必须从头扫一遍，STW非常漫长（慢啊啊啊A~A~~A），因此，没有任何一个JDK版本把它作为默认的垃圾回收器</p><p>漏标必然存在</p><p>三色只是一个扫描算法，普遍使用，错不在他，是CMS的Incremental Update有Bug，G1的STAB没Bug（？？？好用！！！），1.8之前没得选，想要并发的话，1.7诞生G1，可惜当时的G1不成熟</p><h4 id="5-内存不分代模型"><a href="#5-内存不分代模型" class="headerlink" title="5. 内存不分代模型"></a>5. 内存不分代模型</h4><h5 id="Epsilon："><a href="#Epsilon：" class="headerlink" title="Epsilon："></a>Epsilon：</h5><p>什么也不干垃圾回收器,开发JVM的人做DeBug用的</p><p>内存超级大，也用不了这么多内存，就什么也不干，等程序结束自己释放内存，效率极高（什么也不干Very Good）</p><h5 id="G1：目前主流"><a href="#G1：目前主流" class="headerlink" title="G1：目前主流"></a>G1：目前主流</h5><img src="/2022/10/08/JVM-%E4%B8%80/30.png" alt="image-20220930190521288" style="zoom:50%;"><p>摒弃了分代模型，因为随着内存越来越大，不管怎么采用并发玩一边，速度都玩不转，CMS固有的Bug，必须改进。</p><p>产生Region（分区算法），永远有空的内存可用，需要连续内存（Humongous），如何连不上开始整理</p><p>缺点：一次回收要把G1的年青代全部回收完，当你的年青代很大的时候，一次YGC的STW也需要很长时间</p><p>G1逻辑上是分代的，物理不分代</p><h5 id="ZGC（分页算法）"><a href="#ZGC（分页算法）" class="headerlink" title="ZGC（分页算法）"></a>ZGC（分页算法）</h5><p>因为G1的缺点，所以诞生了ZGC（分页算法），goLong的核心</p><p>​–支持TB级别（4T，据说以经扩展到16T）</p><p>​–最大GC停顿10ms</p><p>​–内存增大，停顿时间不长</p><p>​–throughPut不超过15%影响</p><p>​–SPECjbb 2015基准测试，128G堆内存，单纯GC停顿最大1.68ms，平均1.09ms</p><ul><li>Colored Point（颜色指针）太复杂以后研究</li><li>loadBarrier（读屏障）</li><li>SingleGeneration（不再分代）</li><li>内存大小固定，为2的倍数，1，2，4，8，16，32</li></ul><h5 id="Shenandoal"><a href="#Shenandoal" class="headerlink" title="Shenandoal"></a>Shenandoal</h5><p>开源，红帽提供，与ZGC类似，不分代</p><h2 id="8、什么是调优"><a href="#8、什么是调优" class="headerlink" title="8、什么是调优"></a>8、什么是调优</h2><p>为什么一个百万级的TPS系统会频繁GC</p><p>被问调优，一定要指明是那个垃圾回收器（GC）</p><p><strong>什么是调优？</strong></p><ul><li>根据内存进行JVM规划和预调优</li><li>优化运行JVM运行环境（慢，卡顿）（怎么才能定位一个系统的瓶颈？压测）</li><li>解决JVM运行过程中出现的各种问题（Memory Leak ）（OOM  out of memory）</li></ul><p>GC日志详解（<strong>之后补充</strong>）</p><p><strong>工业生产环境中，一个Java程序应该设置什么参数</strong></p><img src="/2022/10/08/JVM-%E4%B8%80/31.png" alt="image-20220930203711901" style="zoom:50%;"><p>JVM可能一个月才出一次问题，很难模拟</p><p>模拟银行或者互联网金融体系，风控（可信度—贷款，家里有矿，贷多一点）根据过去的情况，是否按时还款，有没有借贷不还的，取出用户信息计算出来的，套用风险控制模型计算出他的贷款额度，或者是否给他贷款</p><p>创建一个List，不断往里头扔对象，很快就内存溢出了（这个例子太简单）</p><p>一个方法每次从数据库拿出100条数据，放进任务列表里，起了一个线程池，定时执行任务，50个线程，固定频率拿出数据进行计算</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -Xms200M -Xms200M -XX:+PrintGC  com.......   //-Xms200M -Xms200M设置一样，防止内存抖动，防止内存涨来涨去，缩来//缩去</span><br><span class="line">//-XX:+PrintGC 输出GC日志</span><br></pre></td></tr></table></figure><p><img src="/2022/10/08/JVM-%E4%B8%80/32.png" alt="image-20220930211110355"></p><p>一个Java命令会启动一个Java虚拟机，两个则启动两个Java虚拟机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java//查询命令参数</span><br><span class="line">java -X//查询带X的非标参数</span><br><span class="line">java -XX:+PrintFlagsFinal -version   //查询所有参数的最终值，带XX的有700多个，我们用的只有几十个而已</span><br></pre></td></tr></table></figure><p>带XX的有700多个，我们用的<strong>只有几十个而已</strong></p><p>-X     非标参数，用来调优</p><p>-XX   真正的调优参数</p><h5 id="jps（java-process-系统里的Java进程）"><a href="#jps（java-process-系统里的Java进程）" class="headerlink" title="jps（java process 系统里的Java进程）"></a>jps（java process 系统里的Java进程）</h5><p><img src="/2022/10/08/JVM-%E4%B8%80/33.png" alt="image-20220930212903658"></p><p>两个进程 </p><ul><li>JPS本身</li><li>FullGC</li></ul><h5 id="jinfo-11800（进程名称）"><a href="#jinfo-11800（进程名称）" class="headerlink" title="jinfo   11800（进程名称）"></a>jinfo   11800（进程名称）</h5><h5 id="jstat（java的统计信息-或者-java的跟踪信息）"><a href="#jstat（java的统计信息-或者-java的跟踪信息）" class="headerlink" title="jstat（java的统计信息    或者  java的跟踪信息）"></a>jstat（java的统计信息    或者  java的跟踪信息）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jstat -gc 11800  // 加上进程号， 跟踪gc的信息</span><br><span class="line">jstat -gc 11800 500  //每500秒打印一次，后面有工具</span><br></pre></td></tr></table></figure><h5 id="jstack-（跟踪线程的）"><a href="#jstack-（跟踪线程的）" class="headerlink" title="jstack （跟踪线程的）"></a>jstack （跟踪线程的）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack 11800   //把11800所有线程列出来</span><br></pre></td></tr></table></figure><p><img src="/2022/10/08/JVM-%E4%B8%80/34.png" alt="image-20220930213944875"></p><ul><li>线程名字</li><li>线程编号</li><li>线程优先级</li><li>操作系统级别优先级</li><li>线程状态</li><li>线程的调用堆栈（即这个方法调用了那个方法，这个方法又调了哪个方法）</li></ul><p>如果很多个线程一直在waiting，可能是死锁</p><h5 id="top"><a href="#top" class="headerlink" title="top"></a>top</h5><p>显示当前系统里哪个进程占CPU、内存</p><h5 id="top-Hp-11800"><a href="#top-Hp-11800" class="headerlink" title="top -Hp 11800"></a>top -Hp 11800</h5><p>查看11800进程里的所有线程</p><h5 id="JVM的CPU爆了，怎么查"><a href="#JVM的CPU爆了，怎么查" class="headerlink" title="JVM的CPU爆了，怎么查"></a>JVM的CPU爆了，怎么查</h5><p>jvm占据很高CPU，怎么查&#x2F;追踪：top查进程信息，找出消耗高的，top -Hp 11800查线程信息找出是这个进程里哪个线程消耗高，</p><p>再使用jstack对比线程信息，找到该消耗高的线程（定位），会有两种情况：</p><p>第一种：该线程是VM线程，一般是GC，查看GC日志；</p><p>​–频繁GC？压力爆表如双十一</p><p>​–内存回收不掉，内存泄漏</p><p>第二种：业务线程。二话不说，查看他调用了什么方法</p><p><img src="/2022/10/08/JVM-%E4%B8%80/35.png" alt="image-20221001091752421"></p><p>频繁FullGC，200M内存回收完还是200M，内存被占满了</p><h5 id="jmap："><a href="#jmap：" class="headerlink" title="jmap："></a>jmap：</h5><p>—– 是谁在调用内存。</p><p>—–查看堆内存中对象占用情况，不同类的对象占用内存比重</p><p>——产生堆转储文件，把<strong>JVM</strong>导出来存到硬盘上，拿来分析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jmap -histo 11988   //查看当前进程所有类又多少个实例</span><br><span class="line">jmap -histo 11988 | head 20   //查看前20个</span><br></pre></td></tr></table></figure><p><strong>多运行几次，注意看哪些类的实例个数在不断增长，说明没有被回收</strong>，然后查业务逻辑</p><p>jmap会让整个JVM卡死，STW，把对象输出出来，生产环境肯定不能这么干</p><p><strong>可以在测试环境执行，复制一份到备份机上执行</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dumpa:format=b,file=20200912.hprof 11988 //把堆内存转储成文件，来对他进行分析</span><br></pre></td></tr></table></figure><p>把java的整个堆转成文件，在网下载图形工具进行分析，java自带了一个</p><p>往外到文件，依然会让JVM卡死</p><p>一定设置好启动参数</p><p>-XX:+HeapDumpOnOutOfMemoryError  &#x2F;&#x2F; 当内存爆了，自动生成堆转储文件，在使用工具分析</p><p>生成环境下，除了运维，不多开端口，若是远程连接，会导致不安全，且性能下降10%-15%</p><p>​–压测的时候查看</p><p>​–做了负载均衡，把出问题的机器摘出来，在分析</p><p>​–双十一之类，互联网连接特别多，使用tcp copy命令复制一份，一份给生产环境，一份给测试环境</p><h5 id="Arthas"><a href="#Arthas" class="headerlink" title="Arthas"></a>Arthas</h5><p><img src="/2022/10/08/JVM-%E4%B8%80/36.png" alt="image-20221002092318715"></p><p>查找所有Java进程</p><p>然后选择进行挂载，对他进行观察</p><p>影响系统进程，10%-15%</p><p><strong>替代之前所有命令，且直观</strong></p><h6 id="dashboard（仪表盘）"><a href="#dashboard（仪表盘）" class="headerlink" title="dashboard（仪表盘）"></a>dashboard（仪表盘）</h6><p><img src="/2022/10/08/JVM-%E4%B8%80/37.png" alt="image-20221002092622596"></p><p><strong>结合了前面所有命令，可以看到，这个进程里有哪些线程，哪些线程在吃CPU，且在最前面</strong></p><p>还包括堆内存占多少，非堆内存占多少，</p><h6 id="heap-dump"><a href="#heap-dump" class="headerlink" title="heap dump"></a>heap dump</h6><p>替代jmap</p><h6 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread -b  //直接找死锁，不像上面那么麻烦</span><br></pre></td></tr></table></figure><h6 id="jvm"><a href="#jvm" class="headerlink" title="jvm"></a>jvm</h6><p>与jinfo差不多</p><h6 id="trace"><a href="#trace" class="headerlink" title="trace"></a>trace</h6><p><strong>以上只是定位问题</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> .class </tag>
            
            <tag> GC </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合</title>
      <link href="/2022/09/21/%E9%9B%86%E5%90%88/"/>
      <url>/2022/09/21/%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="1-数组"><a href="#1-数组" class="headerlink" title="1. 数组"></a>1. 数组</h2><p>Array：</p><ol><li>Java语言中的数组是一种引用数据类型。不属于基本数据类型。数组的父类是Object。</li><li>数组实际上是一个容器，可以同时容纳多个元素。（数组是一个数据的集合）</li><li>数组可以存储基本数据类型，也可以存储引用数据类型的数据</li><li>数组因为是引用数据类型，所以数组对象是存储在堆内存当中的（数组是存储在堆中的）</li><li>数组当中如果存储的是<strong>Java对象</strong>的话，实际上存储的是对象的<strong>引用（内存地址）</strong>，数组中不能直接存储Java对象</li><li>数组一旦创建，在Java中规定，长度不可改变。（数组长度不可变）</li><li>所有数组对象都有Length属性（Java自带的），用来获取数组中的元素的个数。</li><li>Java中的数组要求数组中的元素的类型统一。比如int类型数组只能存储int类型，Person类型只能存储Person类型</li><li>数组在内存方面存储的时候，<strong>数组中的元素内存地址是连续的</strong>（存储的每一个元素都是有规则的挨着排列的）。内存地址连续这是数组存储元素的特点（特色），数组实际上是一种简单的数据结构。</li><li>所有的数组都是拿“第一个小方框的内存地址”作为整个数组对象的内存地址。</li><li>数组中每个元素都是有下标的，下标从零开始，以1递增。最后一个元素的下标是：length-1，下标非常重要，因为我们对数组中元素进行<strong>“存取”</strong>的时候，都需要通过下标来进行</li></ol><p>一维数组内存结构</p><p><img src="/2022/09/21/%E9%9B%86%E5%90%88/1.png" alt="1"></p><p>数组这种数据结构的优点和缺点是什么？</p><p>优点：查询&#x2F;查找&#x2F;检索某个下标上的元素时效率极高，可以说是查询效率最高的一种数据结构。</p><p>为什么检索效率高？</p><p>​第一：每一个元素的内存地址在空间存储上是连续的。</p><p>​第二： 每一个元素类型相同，所以占用空间的大小是一样的。</p><p>​第三： 知道一个元素的内存地址，下标，知道每一个元素占用的空间大小，<strong>所以通过一个数学表达式就可以计算出某个下标上的元素的内存地址，所以数组的检索效率是最高的。</strong></p><p>数组中存储100个元素与存储100万个元素，在元素查询&#x2F;检索方面效率是一样的，因为数组查找元素时不会一个一个的查找，而是通过数学表达式计算出来的（算出一个内存地址，直接定位）</p><p>缺点：</p><p>​第一：由于为了保证数组中每个元素的内存地址连续，所以在数组上随机删除或者增加元素的时候，效率较低，因为随机增删元素会涉及到后面元素统一向前或者向后位移的操作。</p><p>​<strong>第二：数组不能存储大数据量，为什么？</strong></p><p>因为很难在内存空间上找到一块特别大的连续的内存空间。</p><p>声明与定义一个一维数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">500</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] array1 = <span class="keyword">new</span> <span class="title class_">int</span>[] <span class="comment">//这里的5表示数组元素的个数</span></span><br></pre></td></tr></table></figure><p>ArrayIndexOutOfBoundsException：数组越界异常</p><h2 id="2-集合的概述"><a href="#2-集合的概述" class="headerlink" title="2. 集合的概述"></a>2. 集合的概述</h2><h3 id="什么是集合-有什么用"><a href="#什么是集合-有什么用" class="headerlink" title="什么是集合?有什么用?"></a>什么是集合?有什么用?</h3><p>数组其实就是一个集合。集合实际上就是一个容器。可以来容纳其它类型的数据。</p><p>集合为什么说在开发中使用较多?</p><ul><li>集合是一个容器，是一个载体，可以一次容纳多个对象。在实际开发中，假设连接数据库，数据库当中有10条记录，那么假设把这10条记录查询出来，在java程序中会将10条数据封装成10个java对象，然后将10个java对象放到某一个集合当中，将集合传到前端，然后遍历集合，将一个数据一个薮据展现出来。</li><li><strong>集合不能直接存储基本数据类型，另外集合也不能直接存储java对象，集合当中存储的都是java对象的内存地址</strong>。（或者说集合中存储的是引用。)<br>list.add ( 100) ; &#x2F;&#x2F;自动装箱Integer<br>注意:<br><strong>集合在java中本身是一个容器，是一个对象。集合中任何时候存储的都是出“引用”。</strong></li></ul><p>在java中每一个不同的集合，<strong>底层会对应不同的数据结构</strong>。往不同的集合中存储元素，等于将数据放到了不同的数据结构当中。什么是数据结构﹖数据存储的结构就是数据结构。不同的数据结构，数据存储方式不同。例如:<br>数组、二叉树、链表、哈希表…<br>以上这些都是常见的数据结构。</p><ul><li>你往集合c1中放数据，可能是放到数组上了.</li><li>你往集合c2中放数据，可能是放到二叉树上了-</li></ul><p>你使用不同的集合等同于使用了不同的数据结构。<br>你在java集合这一章节，你需要掌握的不是精通数据结构。java中已经将数据结构实现了，已经写好了这些常用的集合类，你只需要掌握怎么用?在什么情况下选择哪一种合适的集合去使用即可.</p><ul><li>new ArrayList() ;创建一个集合，底层是数组。</li><li>new LinkedList();创建一个集合对象，底层是链表.</li><li>new Treeset() ;创建一个集合对象,底层是二叉树。</li></ul><h2 id="3-集合继承结构图"><a href="#3-集合继承结构图" class="headerlink" title="3.集合继承结构图"></a>3.集合继承结构图</h2><p><img src="/2022/09/21/%E9%9B%86%E5%90%88/2.png" alt="image-20221006144926866"></p><p><img src="/2022/09/21/%E9%9B%86%E5%90%88/3.png" alt="image-20221006145242562"></p><h2 id="4-Map集合继承结构图"><a href="#4-Map集合继承结构图" class="headerlink" title="4.Map集合继承结构图"></a>4.Map集合继承结构图</h2><p><img src="/2022/09/21/%E9%9B%86%E5%90%88/4.png" alt="image-20221006145456889"></p><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p>总结(所有的实现类):,</p><ul><li><p>ArrayList:底层是数组。vLinkedList:底层是双向链表。,</p></li><li><p>Vector:底层是数组，线程安全的，效率较低，使用较少。v</p></li><li><p>HashSet:底层是HashMap，放到HashSet.集合中的元素等同于放到HashMap集合 key部分了。.</p></li><li><p>TreeSet:底层是TreeMap，放到TreeSet.集合中的元素等同于放到TreeMap集合 key部分了。</p></li><li><p>HashMap:底层是哈希表。,</p></li><li><p>Hashtable:底层也是哈希表，只不过线程安全的，效率较低，使用较少。</p></li><li><p>Properties:是线程安全的，并且 key和value只能存储字符串 String。</p></li><li><p>TreeMap:底层是二叉树。TreeMap集合的 key可以自动按照大小顺序排序。</p></li><li><p>List集合存储元素的特点:</p><ul><li><p>有序可重复</p></li><li><p>有序:存进去的顺序和取出的顺序相同，每一个元素都有下标。</p></li><li><p>可重复:存进去1，可以再存储一个1.</p></li></ul></li><li><p>set集合存储元素的特点:,</p><ul><li>无序不可重复</li><li>无序:存进去的顺序和取出的顺序不一定相同。另外set集合中元素没有下标。</li><li>不可重复:存进去1，不能再存储1了。</li></ul></li><li><p>SortedSet集合存储元素特点:</p><ul><li><p>首先是无序不可重复的，但是SortedSet集合中的元素是可排序的。</p></li><li><p>无序:存进去的顺序和取出的顺序不一定相同。另外 set集合中元素没有下标。</p></li><li><p>不可重复:存进去1，不能再存储1了。</p></li><li><p><strong>可排序:可以按照大小顺序排列。</strong></p></li></ul></li></ul><h2 id="5-Collection中常用的方法"><a href="#5-Collection中常用的方法" class="headerlink" title="5.Collection中常用的方法"></a>5.Collection中常用的方法</h2><p>集合.size()获取集合中元素的个数</p><p>集合.clear()清空集合</p><p>集合.add()向集合中添加元素</p><p>集合.remove()删除集合中的某个元素</p><p>集合.isEmpty判断该集合中元素个数是否为0</p><p>集合.toArray()调用这个方法可以把集合转换成数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1集合中能存放什么元素</span></span><br><span class="line"><span class="comment">没有使用&quot;泛型”之前，collection中可以存储object的所有子类型。使用了“泛型”之后，collection中只能存储某个具体的类型。</span></span><br><span class="line"><span class="comment">Collection中什么都能存，只要是object的子类型就行。（集合中不能亘接存储基本数据类型，也不能存java对象，只是存储java对象的内存地址。)</span></span><br><span class="line"><span class="comment">2、Collection中的常用方法</span></span><br><span class="line"><span class="comment">booLean add( object e)向集合中添加元素</span></span><br><span class="line"><span class="comment">int size()获取集合中元素的个数</span></span><br><span class="line"><span class="comment">void clear()清空集合</span></span><br><span class="line"><span class="comment">boolean contains(Object o)判断当前集合中是否包含元素o，包含返回true，不包含返回false</span></span><br><span class="line"><span class="comment">boolean remove( 0bject o)删除集合中的某个元素。</span></span><br><span class="line"><span class="comment">boolean isEmpty()判断该集合中元素的个数是否为e</span></span><br><span class="line"><span class="comment">object[] toArray()调用这个方法可以把集合转换成数组。【作为了解，使用不多。】</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个集合对象</span></span><br><span class="line">        <span class="comment">//Collection c = new Collection(); //接口是抽象的，无法实例化。</span></span><br><span class="line">        <span class="comment">//多态</span></span><br><span class="line">        <span class="type">Collection</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="comment">//测试collection接口中的常用方法</span></span><br><span class="line">        c.add(<span class="number">1200</span>);<span class="comment">//自动装箱(java5的新特性。),实际上是放进去了一个对象的内存地址。Integer x = new Integer(1200)</span></span><br><span class="line">        c.add(<span class="number">3.14</span>);<span class="comment">//自动装箱</span></span><br><span class="line">        c.add( <span class="keyword">new</span> <span class="title class_">object</span>());</span><br><span class="line">        c.add( <span class="keyword">new</span> <span class="title class_">student</span>());</span><br><span class="line">        c.add(<span class="literal">true</span>); <span class="comment">//自动装箱</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取集合中元素的个数</span></span><br><span class="line">System.out.println(<span class="string">&quot;集合中元素个数是:&quot;</span> + c.size());<span class="comment">// 5</span></span><br><span class="line"><span class="comment">//清空集合</span></span><br><span class="line">        c.clear( );</span><br><span class="line">        System.out.println(<span class="string">&quot;集合中元素个数是:&quot;</span> + c.size()); <span class="comment">// 0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//再向集合中添加元素</span></span><br><span class="line">        c.add(<span class="string">&quot;he1lo&quot;</span>); <span class="comment">//&quot;heLlo&quot;对象的内存地址放到了集合当中。</span></span><br><span class="line">        c.add( <span class="string">&quot;wor1d&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;浩克&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;绿巨人&quot;</span>);</span><br><span class="line">        c.add( <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//判断集合中是否包含&quot;绿巨人”</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> c.contains(<span class="string">&quot;绿巨人&quot;</span>);</span><br><span class="line">        System.out.print1n(flag); <span class="comment">//true</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag2</span> <span class="operator">=</span> c.contains(<span class="string">&quot;绿巨人2&quot;</span>);</span><br><span class="line">        System.out.println(flag2); <span class="comment">// false</span></span><br><span class="line">        system.out.println(c.contains(<span class="number">1</span>)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;集合中元素个数是:&quot;</span> + c.size());<span class="comment">// 5</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//删除集合中某个元素</span></span><br><span class="line">        c.remove(<span class="number">1</span>);</span><br><span class="line">        system.out.println(<span class="string">&quot;集合中元素个数是:&quot;</span> + c.size()); <span class="comment">// 4</span></span><br><span class="line">        <span class="comment">//判断集合是否为空（集合中是否存在元素)</span></span><br><span class="line">        system.out.println(c.isEmpty()); <span class="comment">//falsel</span></span><br><span class="line">        <span class="comment">//清空</span></span><br><span class="line">        c.clear( );</span><br><span class="line">        system.out.println(c.isEmpty()); <span class="comment">//true ( true表示集合中没有元素了!)</span></span><br><span class="line">        c.add( <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        c.add( <span class="string">&quot;def&quot;</span> ) ;</span><br><span class="line">        c.add( <span class="number">100</span>) ;</span><br><span class="line">        c.add( <span class="string">&quot;he11owor1d ! &quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//转换成数组</span></span><br><span class="line">        object[] objs =c.toArray();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; objs.length; i++)&#123;</span><br><span class="line">        <span class="comment">//逼历数组</span></span><br><span class="line">        <span class="type">object</span> <span class="variable">o</span> <span class="operator">=</span> objs[i];</span><br><span class="line">            System.out.println(o) ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-Collection集合迭代"><a href="#6-Collection集合迭代" class="headerlink" title="6.Collection集合迭代"></a>6.Collection集合迭代</h2><p><strong>&#x2F;&#x2F;注意:以</strong>下<strong>讲解的逼历方式&#x2F;迭代方式，是所有Collection通用的一种方式。</strong>**<br>        <strong>&#x2F;&#x2F;在Map集合中不能用。在所有的Collection以及子类中使用。</strong>**</p><p><strong>&#x2F;&#x2F;不管你当初存进去什么，取出来统一都是object。</strong></p><p>迭代器是通用的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//注意:以下讲解的逼历方式/迭代方式，是所有Collection通用的一种方式。</span></span><br><span class="line">        <span class="comment">//在Map集合中不能用。在所有的Collection以及子类中使用。</span></span><br><span class="line">        <span class="comment">//创建集合对象</span></span><br><span class="line">        <span class="type">Collection</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();<span class="comment">//后面的集合无所谓，主要是看前面的Collection接口，怎么遍历/迭代。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        c.add ( <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;def&quot;</span>);</span><br><span class="line">        c.add ( <span class="number">100</span>) ;</span><br><span class="line">        c.add( <span class="keyword">new</span> <span class="title class_">Object</span>( ));</span><br><span class="line">        <span class="comment">//对集合collection进行逼历/迭代</span></span><br><span class="line">        <span class="comment">//第一步:获取集合对象的迭代器对象</span></span><br><span class="line">        <span class="type">IteratorIterator</span> <span class="variable">it</span> <span class="operator">=</span> c.iterator();</span><br><span class="line">        <span class="comment">//第二步:通过以上获取的迭代器对象开始迭代/逼历集合。</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        以下两个方法是迭代器对象Iterator中的方法:</span></span><br><span class="line"><span class="comment">        boolean hasNext( )如果仍有元素可以迭代，则返回true</span></span><br><span class="line"><span class="comment">        oobject next( )返回迭代的下一个元素。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">boolean</span> <span class="variable">hasNext</span> <span class="operator">=</span> it.hasNext();</span><br><span class="line">        <span class="keyword">if</span>(hasNext) &#123;</span><br><span class="line">            <span class="comment">//不管你当初存进去什么，取出来统一都是object。</span></span><br><span class="line">            <span class="type">object</span> <span class="variable">obj</span> <span class="operator">=</span> it.next();</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2022/09/21/%E9%9B%86%E5%90%88/5.png" alt="image-20221006154204253"></p><h2 id="7-Contains方法解析"><a href="#7-Contains方法解析" class="headerlink" title="7.Contains方法解析"></a>7.Contains方法解析</h2><p><img src="/2022/09/21/%E9%9B%86%E5%90%88/6.png" alt="image-20221006163104159"></p><p><strong>contains方法里使用了equals方法，</strong>而equals比较的是内存地址，<strong>所以放在集合里的元素需要重写equals方法</strong></p><p>String里也重写了equals方法，so，你懂的，<strong>remove也是一样</strong></p><h2 id="8-List特有的方法"><a href="#8-List特有的方法" class="headerlink" title="8.List特有的方法"></a>8.List特有的方法</h2><p>1、List集合存储元素特点:有序可重复<br>有序: List集合中的元素有下标。从8开始，以1递增。<br>可重复:存储一个1，还可以再存储1.<br>2、List既然是collection接口的子接口，那么肯定ist接口有自己”特色”的方法:<br>以下只列出List接口特有的常用的方法:</p><ul><li>void add(int index， 0bject eLement)</li><li>object get(int index)</li><li>int index0f(Object o)</li><li>int lastIndexOf(object o)</li><li>object remove(int index)</li><li>object set(int index, object eLement)</li></ul><h2 id="9-ArrayList初始化容量及扩容"><a href="#9-ArrayList初始化容量及扩容" class="headerlink" title="9.ArrayList初始化容量及扩容"></a>9.ArrayList初始化容量及扩容</h2><p>1、默认初始化容量10（<strong>底层先创建了一个长度为0的数组，当添加第一个元素的时候，初始化容量为10</strong>）</p><p>2、集合底层是一个object[ ]数组。</p><p>3、构造方法:</p><p>​new ArrayList();</p><p>​new ArrayList(20);</p><p>4、ArrayList集合的扩容:<br>$$</p><blockquote><blockquote><p> 位运算符， 表示二进制右移<br>$$<br><strong>增长到原容量的1.5倍。</strong><strong>旧长度右移一位</strong><br><strong>ArrayList集合底层是数组，怎么优化?</strong><br>尽可能少的扩容。因为数组扩容效率比较低，<strong>建议在使用ArrayList集合的时候预估计元素的个数，给定一个初始化容量。</strong></p></blockquote></blockquote><p>5、数组优点:<br>检索效率比较高。(<strong>每个元素占用空间大小相同，内存地址是连续的，知道首元素内存地址然后知道下标，通过数学表达式计算出元素的内存地址，所以检索效率最高。</strong>)</p><p>6、数组缺点:<br>随机增删元素效率比较低。<br>另外数组无法存储大数据量。（<strong>很难找到一块非常巨大的连续的内存空间</strong>。)</p><p>7、向数组末尾添加元素，效率很高，不受影响。</p><p>8、面试官经常问的一个问题?<br>这么多的集合中，你用哪个集合最多?</p><p>答: ArrayList集合。<br>因为往数组末尾添加元素，效率不受影响。另外，我们检索&#x2F;查找某个元素的操作比较多。</p><h2 id="10-单向链表"><a href="#10-单向链表" class="headerlink" title="10.单向链表"></a>10.单向链表</h2><p><img src="/2022/09/21/%E9%9B%86%E5%90%88/7.png" alt="image-20221006171919238"></p><p>单链表中的节点。<br>节点是单向链表中基本的单元。每一个节点Node都有两个属性:<br>一个属性:是存储的数据。<br>另一个属性:是下一个节点的内存地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//节点对象</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">单链表中的节点。</span></span><br><span class="line"><span class="comment">节点是单向链表中基本的单元。每一个节点Node都有两个属性:</span></span><br><span class="line"><span class="comment">一个属性:是存储的数据。</span></span><br><span class="line"><span class="comment">另一个属性:是下一个节点的内存地址。*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储的数据</span></span><br><span class="line">    object element;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下一个节点的内存地址</span></span><br><span class="line">    Node next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Object data，Node next)</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//简单测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Link</span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//头节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">header</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向链表中添加元素的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(object data)</span>&#123;</span><br><span class="line">        <span class="comment">//创建一个新的节点对象</span></span><br><span class="line">        <span class="comment">//让之前单链表的末尾节点next指向新节点对象。</span></span><br><span class="line">        <span class="comment">//有可能这个元素是第一个，也可能是第二个，也可能是第三个。</span></span><br><span class="line">        <span class="keyword">if</span>(header == nu11)&#123;</span><br><span class="line">        <span class="comment">//说明还没有节点。</span></span><br><span class="line">        <span class="comment">//new一个新的节点对象，作为头节点对象。</span></span><br><span class="line">        <span class="comment">//这个时候的头节点既是一个头节点，又是一个末尾节点。</span></span><br><span class="line">            header = <span class="keyword">new</span> <span class="title class_">Node</span>(data,next: nu11);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//说明头不是空!</span></span><br><span class="line">            <span class="comment">//头节点已经存在了!</span></span><br><span class="line">            <span class="comment">//找出当前末尾节点，让当前末尾节点的next是新节点。</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">currentLastNode</span> <span class="operator">=</span> findLast();</span><br><span class="line">            currentLastNode.next = <span class="keyword">new</span> <span class="title class_">Node</span>(data，next: nu11);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *专门查找末尾节点的方法。 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">NodefindLast</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(node.next心== nu11) &#123;</span><br><span class="line">            <span class="comment">//如果一个节点的next是null</span></span><br><span class="line">            <span class="comment">//说明这个节点就是末尾节点。</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//程序能够到这里说明: node不是末尾节点。</span></span><br><span class="line">        <span class="keyword">return</span> findLast( node.next); <span class="comment">//递归算法</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//删除链表中某个数据的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(object obj)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改链表中某个数据的方法</span></span><br><span class="line">    pubiic <span class="keyword">void</span> <span class="title function_">modify</span><span class="params">(object newObj)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找链表中某个元素的方法。</span></span><br><span class="line">    pubiic <span class="type">int</span> <span class="title function_">find</span><span class="params">(object obj)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="链表的优点"><a href="#链表的优点" class="headerlink" title="链表的优点:"></a>链表的优点:</h4><p>由于<strong>链表上的元素在空间存储上内存地址不连续。</strong><br>所以随机增删元素的时候不会有大量元素位移，因此随机增删效率较高。</p><p>在以后的开发中，如果遇到随机增删集合中元素的业务比较多时，建议使用LinkedList。</p><h4 id="链表的缺点"><a href="#链表的缺点" class="headerlink" title="链表的缺点:"></a>链表的缺点:</h4><p>不能通过数学表达式计算被查找元素的内存地址，每一次查找都是从头节点开始逼历，直到找到为止。所以LinkedList集合检索&#x2F;查找的效率较低。<br>ArrayList :把检索发挥到极致。(（末尾添加元素效率还是很高的)</p><p>LinkedList :把随机增删发挥到极致。<br>加元素都是往末尾添加，所以ArrayList用的比LinkedList多。</p><h2 id="11-双向链表"><a href="#11-双向链表" class="headerlink" title="11.双向链表"></a>11.双向链表</h2><p><img src="/2022/09/21/%E9%9B%86%E5%90%88/8.png" alt="image-20221006172607849"></p><h2 id="12-Vector"><a href="#12-Vector" class="headerlink" title="12.Vector"></a>12.Vector</h2><p>1、底层也是一个数组。</p><p>2、初始化容量:10</p><p>3、怎么扩容的?<br>扩容之后是原容量的2倍。10–&gt;20 –&gt;40 –&gt; 80</p><p>4、ArrayList集合扩容特点:<br>ArrayList集合扩容是原容量1.5倍。</p><p>5,Vector中所有的方法都是线程同步的，都带有synchronized关键字，是线程安全的。效率比较低，使用较少了。</p><p>6、怎么将一个线程不安全的Arraylist集合转换威线程安全的呢?<br>    使用集合工具类:<br>            java. util.collections;</p><p>​java.util.collection是集合接口。</p><p>​java.util.collections是集合工具类。</p><h2 id="13-forEach"><a href="#13-forEach" class="headerlink" title="13.forEach"></a>13.forEach</h2><p>jdk5.0新特性</p><p>增强for ( foreach )</p><p><strong>以下是语法</strong></p><p>for(元秦类型变量名∶数组或集合){<br>        System.out.printLn(变量名);</p><p>​}</p><h4 id="缺点：没有下标"><a href="#缺点：没有下标" class="headerlink" title="缺点：没有下标"></a>缺点：没有下标</h4><p>在需要使用下标的循环中，不建议使用增强for循环。</p><h2 id="14-HashSet"><a href="#14-HashSet" class="headerlink" title="14.HashSet"></a>14.HashSet</h2><p>无序不可重复</p><h2 id="15-TreeSet"><a href="#15-TreeSet" class="headerlink" title="15.TreeSet"></a>15.TreeSet</h2><p>1、无序不可重复的，但是存储的元素可以自动按照大小顺序排序!称为:可排序集合。</p><p>2、无序:这里的无序指的是存进去的顺序和取出来的顺序不同。并且没有下标。</p><h2 id="16-Map接口常用方法"><a href="#16-Map接口常用方法" class="headerlink" title="16.Map接口常用方法"></a>16.Map接口常用方法</h2><p>java.util.Map接口中常用的方法∶</p><p>​1、<strong>Map和collection没有继承关系。</strong><br>​2、<strong>Map集合以key和value的方式存储数据:键值对</strong><br>**key和value都是引用数据类型。**<br>​key和value都是存储对象的内存地址。<br>​<strong>key起到主导的地位，value是key的一个附属品。</strong></p><p>​3、Map接口中常用方法:</p><ul><li><p>V  put(K key,V value)向Map集合中添加键值对</p></li><li><p>V get(Object key)通过key获取value</p></li><li><p>void clear()清空Map集合</p></li><li><p>boolean containsKey(object key)       判断Map中是否包含某个key</p></li><li><p>boolean containsValue(object value)判断Map中是否包含某个value </p></li><li><p>boolean isEmpty()         判断Map集合中元素个数是否为0</p></li><li><p>Set<K> keySet()获取Map集合所有的key (所有的键是一个set集合)</K></p></li><li><p>V   remove(object key)通过key删除键值对</p></li><li><p>int size(）获取Map集合中键值对的个数。</p></li><li><p>Collection<V> values(）获取Map集合中所有的value ，返回一个collection</V></p></li><li><p>Set&lt;Map.Entry&lt;K,V&gt;&gt;  entrySet(）将Map集合转换成Set集合</p></li></ul><p>将Map集合转换成set集合<br>假设现在有一个Map集合，如下所示:<br>map1集合对象</p><p>keyvalue</p><hr><p>1zhangsan<br>2lisi<br>3wangwu<br>4zhaoliu<br>Set set &#x3D; map1.entrySet( );</p><p>set集合对象</p><p>​1&#x3D;zhangsan【注意:Map集合通过entrySet()方法转换成的这个set集合，**Set集合中元素的类型是Map.Entry&lt;K,V&gt;**】</p><p>​2&#x3D;Lisi【<strong>Map.Entry和string一样，都是一种类型的名字，只不过Map.Entry是静态内部类，是Map中的静态内部类</strong>】</p><p>​3&#x3D;wangwu</p><p>​4&#x3D;zhaoliu</p><p><strong>注意：</strong>这种方式效率比较高，因为获取key和value都是亘接从node对象中获取的属性值。这种方式比较适合于大数据量。</p><p>遍历Set集合，取出每一个<strong>Map.Entry&lt;K,V&gt;（node）对象</strong></p><ul><li>迭代器</li><li>forEach</li><li><strong>相信不用我说了把，看下图，你懂的</strong></li></ul><p><img src="/2022/09/21/%E9%9B%86%E5%90%88/10.png" alt="image-20221006190346686"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//是Map中的静态内部类   例子</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="comment">//声明一个静态内部类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.print1n(<span class="string">&quot;静态内部类的m1方法执行&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//实例方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态内部类中的实例方法执行!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span> i</span><br><span class="line">    MyClass.InnerClass.m1();</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//创建静态内部类对象</span></span><br><span class="line">   MyClass.<span class="type">InnerClass</span> <span class="variable">mi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>.InnerClass();</span><br><span class="line">    mi.m2();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 可以把key和V单独<strong>全部</strong>拿出来</p><p><img src="/2022/09/21/%E9%9B%86%E5%90%88/9.png" alt="image-20221006190015271"></p><h2 id="17-哈希表"><a href="#17-哈希表" class="headerlink" title="17.哈希表"></a>17.哈希表</h2><p><img src="/2022/09/21/%E9%9B%86%E5%90%88/11.png" alt="image-20221006190846701"></p><p>1、HashMap集合底层是哈希表&#x2F;散列表的数据结构。</p><p>2、哈希表是一个怎样的数据结构呢?<br>哈希表是一个数组和单向链表的结合体。<br>数组∶在查询方面效率很高，随机增删方面效率很低。<br>单向链表:在随机增删方面效率较高，在查询方面效率很低。</p><p><strong>哈希表将以上的两种数据结构融合在一起，充分发挥它们各自的优点。</strong></p><p>3、HashMap集合底层的源代码∶</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&#123;</span><br><span class="line"><span class="comment">//HashMap底层实际上就是一个数组。(一维数组)</span></span><br><span class="line"></span><br><span class="line">Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态的内部类HashMap.Node</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> hash;<span class="comment">//哈希值（哈希值是key的hashCode()方法的执行结果。hash值通过哈希函数/算法，可以转换存储成数组的下标。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> K key;<span class="comment">//存储到map中的那个key</span></span><br><span class="line"></span><br><span class="line">V value;<span class="comment">//存储到map集合中的那个value</span></span><br><span class="line">Node&lt;K,V&gt; next;<span class="comment">//下一个节点的内存地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>哈希表&#x2F;散列表:一维数组，这个数组中每一个元素是一个单向链表。(数组和链表的结合体。)</strong></p><p>4、HashMap集合的key部分特点:<br>无序，不可重复。<br>为什么无序?因为不一定挂到哪个单向链表上。<br>不可重复是怎么保证的? equals方法来保证HashMap集合的key不可重复。如果key重复了，value会覆盖。<br>放在HashMap集合key部分的元素其实就是放到HashSet集合中了。<br>所以HashSet集合中的元素也需要同时重写hashCode( )+equals( )方法。</p><p>5、哈希表HashMap使用不当时无法发挥性能!<br>假设将所有的hashCode()方法返回值固定为某个值，那么会导致底层哈希表变成了纯单向链表。这种情况我们成为:散列分布不均匀。<br>什么是散列分布均匀?<br>假设有100个元素，10个单向链表，那么每个单向链表上有10个节点，这是最好的，是散列分布均匀的。<br>假设将所有的hashcode()方法返回值都设定为不一样的值，可以吗，有什么问题?<br>不行，因为这样的话导致底层哈希表就成为一维数组了，没有链表的概念了。也是散列分布不均匀。<br>散列分布均匀需要你重写hashcode()方法时有一定的技巧。</p><p>7、重点∶放在HashMap集合key部分的元素，以及放在HashSet集合中的元素，需要同时重写nashCode和equaLs方法。</p><p>8、HashMap集合的默认初始化容量是16，默认加载因子是0.75<br>这个默认加载因子是当HashMap集合底层数组的容量达到75%的时候，数组开始扩容。</p><p><strong>重点记住:</strong>HasnMap集合初始化容量必须是z的倍数.这也是宫方椎荐的这是因为达到散列均匀.为了提高HashMap集合的存取效率，丽必须的。</p><p><img src="/2022/09/21/%E9%9B%86%E5%90%88/12.png" alt="image-20221006192839988"></p><p><img src="/2022/09/21/%E9%9B%86%E5%90%88/13.png" alt="image-20221006200537157"></p><h2 id="18-补充一下hasCode方法"><a href="#18-补充一下hasCode方法" class="headerlink" title="18.补充一下hasCode方法"></a>18.补充一下hasCode方法</h2><p>hashCode方法:<br>在object中的hashCode方法是怎样的?<br>public native int hashCode ( ) ;<br>这个方法不是抽象方法，<strong>带有native关键字，底层调用C++程序。</strong><br>hashCode ()方法返回的是哈希码:<br>实际上就是一个java对象的内存地址，经过哈希算法，<strong>得出的一个值所以hashCode ()方法的执行结果可以等同看做一个java对象的内存地址</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">hashCode方法:</span></span><br><span class="line"><span class="comment">在object中的hashCode方法是怎样的?</span></span><br><span class="line"><span class="comment">public native int hashCode ( ) ;</span></span><br><span class="line"><span class="comment">这个方法不是抽象方法，带有native关键字，底层调用C++程序。</span></span><br><span class="line"><span class="comment">hashCode ()方法返回的是哈希码:</span></span><br><span class="line"><span class="comment">实际上就是一个java对象的内存地址，经过哈希算法，得出的一个值所以hashCode ()方法的执行结果可以等同看做一个java对象的内存地址。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test07</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(string[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>() ;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hashCodevalue</span> <span class="operator">=</span> o.hashCode ( ) ;</span><br><span class="line">        <span class="comment">//对象内存地址经过哈希算法转换的一个数字。可以等同看做内存地址</span></span><br><span class="line">        System. out.println(hashCodeValue) ; <span class="comment">//798154996</span></span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">mc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span> () ;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hashCodevalue2</span> <span class="operator">=</span> mc. hashCode () ;</span><br><span class="line">        System.out.println (hashCodevalue2) ; <span class="comment">//1392838282</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="19-HashMap-和HashTable的区别"><a href="#19-HashMap-和HashTable的区别" class="headerlink" title="19.HashMap 和HashTable的区别"></a>19.HashMap 和HashTable的区别</h2><p>1、Hashtable的key可以为nuLl吗?</p><ul><li><strong>HashtabLe的key和value都是不能为null的。</strong></li><li><strong>HashMap集合的key和vaLue都是可以为nuLl的。</strong></li></ul><p>2、<strong>Hashtable方法都带有synchronized :线程安全的</strong>。线程安全有其它的方案，这个Hashtable对线程的处理导致效率较低，使用较少了。</p><p>3、Hashtable和NHashMap一样，底层都是哈希表数据结构。Heshtable的初始化容量是11，默认加载因子是;0.75fHashtabLe的扩容是:原容量*2+1</p><h2 id="20-Properties"><a href="#20-Properties" class="headerlink" title="20.Properties"></a>20.Properties</h2><p>目前只需要掌握Properties属性类对象的相关方法即可。</p><p>Properties是一个Map集合，继承Hashtable , Properties的key和value都是String类型。</p><p>Properties被称为属性类对象。</p><p>Properties是线程安全的。</p><h2 id="21-TreeSet"><a href="#21-TreeSet" class="headerlink" title="21.TreeSet"></a>21.TreeSet</h2><p>1、TreeSet集合底层实际上是一个TreeMap</p><p>2、<strong>TreeMap集合底层是一个二叉树。</strong></p><p>3、<strong>放到TreeSet集合中的元素，等同于放到TreeMap集合key部分了。</strong></p><p>4、TreeSet集合中的元素:无序不可重复，但是可以按照元素的大小顺序自动排序。称为:可排序集合。</p><p>5、<strong>对自定义的类型来说，TreeSet可以排序吗?</strong><br>    以下程序中对于Person类型来说，无法排序。因为没有指定Person对象之间的比较规则。谁大谁小并没有说明啊。<br>    以下程序运行的时候出现了这个异常:<br>    java.Lang.CLasscastException :<br>    class com.bjpowernode.javase.colLection .Personcannot be cast to class java.Lang. Comparable<br>    出现这个异常的原因是:<br>    <strong>Person类没有实现java .Lang . Comparable接口。</strong></p><p><strong>故在TreeSet集合中的元素需要实现java.Lang . Comparable接口。</strong></p><p>并且实现compareTo方法。equals可以不写。</p><p>需要在这个方法中编写比较的逻辑，或者说比较的规则，按照什么进行比较!l &#x2F; k.compareTo(t.key )<br>拿着参数k和集合中的每一个k进行比较，返回值可能是&gt;0 &lt;0 &#x3D;0<br><strong>比较规则最终还是由程序员指定的∶例如按照年龄升序。或者按照年龄降序。</strong></p><p><strong>TreeSet集合中元素可排序的第二种方式:使用比较器的方式。</strong></p><p>TreeSet集合中元素可排序的第二种方式:使用比较器的方式。</p><p>最终的结论:<br>放到TreeSet或者TreeMap集合key部分的元素要想做到排序,包括两种方式:</p><ul><li>第一种:放在集合中的元素实现java .lang . Comparable接口。</li><li>第二种:在构造TreeSet或者TreeMap集合的时候给它传一个比较器对象。</li></ul><p>ComparabLe和Comparator怎么选择呢?</p><p>当比较规则不会发生改变的时候，或者说当比较规则只有1个的时候，建议实现comparable接口。如果比较规则有多个，并且需要多个比较规则之间频繁切换，建议使用Ccomparator接口。<br>comparator接的设计符合OCP原则。|</p><h2 id="22-二叉树"><a href="#22-二叉树" class="headerlink" title="22.二叉树"></a>22.二叉树</h2><p><img src="/2022/09/21/%E9%9B%86%E5%90%88/14.png" alt="image-20221006203637876"></p><h2 id="23-集合工具类"><a href="#23-集合工具类" class="headerlink" title="23.集合工具类"></a>23.集合工具类</h2><p>java.utiL.Collection集合接口<br>java.utiL.<strong>CoLlections</strong>集合工具类，方便集合的操作。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Collection </tag>
            
            <tag> Map </tag>
            
            <tag> 集合 </tag>
            
            <tag> List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务</title>
      <link href="/2022/09/20/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
      <url>/2022/09/20/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><h3 id="1-本地事务"><a href="#1-本地事务" class="headerlink" title="1.本地事务"></a>1.本地事务</h3><h5 id="事务特性（ACID）"><a href="#事务特性（ACID）" class="headerlink" title="事务特性（ACID）"></a>事务特性（ACID）</h5><p>原子性、一致性、隔离性和持久性</p><p>原子性：一系列的操作整体不可拆分，要么同时成功，要么同时失败</p><p>一致性：数据库总是从一个一致性的状态转换到另一个一致性的状态。事务的一致性决定了一个系统设计和实现的复杂度，也导致了事务的不同隔离级别。</p><p>事务可以不同程度的一致性：</p><ul><li>强一致性：读操作可以立即读到提交的更新操作。</li><li>弱一致性：提交的更新操作，不一定立即会被读操作读到，此种情况会存在一个不一致窗口，指的是读操作可以读到最新值的一段时间</li><li>最终一致性：是弱一致性的特例。事务更新一份数据，最终一致性保证在没有其他事务更新同样的值的话，最终所有的事务都会读到之前事务更新的最新值。如果没有错误发生，不一致窗口的大小依赖于：通信延迟，系统负载等。</li></ul><p>隔离性：并发事务之间互相影响的程度，比如一个事务会不会读取到另一个未提交的事务修改的数据</p><p>持久性：一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。持久性是个有点模糊的概念，因为实际上持久性也分很多不同的级别。有些持久性策略能够提供非常强的安全保障，而有些则未必。而且不可能有能做到100%的持久性保证策略。</p><p>在事务并发操作时，可能出现的问题有：</p><ul><li><p>脏读：事务A修改了一个数据，但未提交，事务B这时来读数据，读到A未提交的数据，称为脏读。</p><table><thead><tr><th>时间顺序</th><th>转账事务</th><th>取款事务</th></tr></thead><tbody><tr><td>1</td><td></td><td>开始事务</td></tr><tr><td>2</td><td>开始事务</td><td></td></tr><tr><td>3</td><td></td><td>查询账户余额为2000元</td></tr><tr><td>4</td><td></td><td>取款一千元，余额被更改为1000元</td></tr><tr><td>5</td><td></td><td></td></tr><tr><td>6</td><td>查询账户余额，查到1000元（脏读）</td><td></td></tr><tr><td>7</td><td></td><td>取款操作发生未知错误，事务回滚，余额变回2000元</td></tr><tr><td>8</td><td>转入2000元，余额被更改为3000元（脏读的1000元+ 2000元）</td><td></td></tr></tbody></table><table><thead><tr><th>备注</th><th>按照正确逻辑，此时余额应为4000元</th></tr></thead></table></li><li><p>不可重复读：在事务A中，需要多次读小明年龄20岁这一数据，事务尚未结束，此时事务B修改小明年龄为30岁，导致事务A第二次读取小明年龄为30岁数据不重复了，即系统不能够读取到重复的数据，称为不可重复读</p><table><thead><tr><th>时间顺序</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>1</td><td>开始事务</td><td></td></tr><tr><td>2</td><td>第一次查询，小明年龄为20岁</td><td></td></tr><tr><td>3</td><td></td><td>开始事务</td></tr><tr><td>4</td><td>其他操作</td><td></td></tr><tr><td>5</td><td></td><td>更改小明年龄为30岁</td></tr><tr><td>6</td><td></td><td>提交事务</td></tr><tr><td>7</td><td>第二次查询，小明年龄为30岁</td><td></td></tr></tbody></table><table><thead><tr><th>备注</th><th>按照正常逻辑，事务A前后读取到的数据应该一致，即小明年龄应该为20岁</th></tr></thead></table></li><li><p>幻读：事务A在执行统计操作，需要统计数据的总量，前一次查询数据总量后，此时事务B执行了新增或删除操作，这个时候事务A读取到的事务总量和之前统计的不一样，就像产生了幻觉一样，称为幻读</p><table><thead><tr><th align="left">时间顺序</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td align="left">1</td><td>开始事务</td><td></td></tr><tr><td align="left">2</td><td>第一次查询，数据总量为100条</td><td></td></tr><tr><td align="left">3</td><td></td><td>开始事务</td></tr><tr><td align="left">4</td><td>其他操作</td><td></td></tr><tr><td align="left">5</td><td></td><td>新增100条数据</td></tr><tr><td align="left">6</td><td></td><td>提交事务</td></tr><tr><td align="left">7</td><td>第二次查询，数据总量为200条</td><td></td></tr></tbody></table><table><thead><tr><th>备注</th><th>按照正常逻辑，事务A前后两次读取到的数据总量应该一致</th></tr></thead></table></li></ul><h5 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h5><ul><li>READ UNCOMMITTED（读未提交）：该隔离级别的事务会读到其它未提交事务的数据， 此现象也称之为脏读。</li><li>READ COMMITTED（ 读提交）：一个事务可以读取另一个已提交的事务， 多次读取会造成不一样的结果， 此现象称为不可重复读问题， Oracle 和 SQL Server 的默认隔离级别。</li><li>REPEATABLE READ（ 可重复读）：该隔离级别是 MySQL 默认的隔离级别， 在同一个事务里， select 的结果是事务开始时时间点的状态， 因此， 同样的 select 操作读到的结果会是一致的， 但是， 会有幻读现象。 MySQL的 InnoDB 引擎可以通过 next-key locks 机制（ 参考下文”行锁的算法”一节） 来避免幻读。</li><li>SERIALIZABLE（ 序列化）：在该隔离级别下事务都是串行顺序执行的， MySQL 数据库的 InnoDB 引擎会给读操作隐式加一把读共享锁， 从而避免了脏读、 不可重读复读和幻读问题</li></ul><h5 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h5><ul><li>PROPAGATION_REQUIRED： 如果当前没有事务， 就创建一个新事务， 如果当前存在事务，就加入该事务， 该设置是最常用的设置</li><li>PROPAGATION_SUPPORTS： 支持当前事务， 如果当前存在事务， 就加入该事务， 如果当前不存在事务， 就以非事务执行。</li><li>PROPAGATION_MANDATORY： 支持当前事务， 如果当前存在事务， 就加入该事务， 如果当前不存在事务， 就抛出异常。</li><li>PROPAGATION_REQUIRES_NEW： 创建新事务， 无论当前存不存在事务， 都创建新事务。</li><li>PROPAGATION_NOT_SUPPORTED： 以非事务方式执行操作， 如果当前存在事务， 就把当前事务挂起</li><li>PROPAGATION_NEVER： 以非事务方式执行， 如果当前存在事务， 则抛出异常。</li><li>PROPAGATION_NESTED： 如果当前存在事务， 则在嵌套事务内执行。 如果当前没有事务，则执行与PROPAGATION_REQUIRED 类似的操作。</li></ul><h3 id="2、本地事务在分布式下的问题"><a href="#2、本地事务在分布式下的问题" class="headerlink" title="2、本地事务在分布式下的问题"></a>2、本地事务在分布式下的问题</h3><p>业务描述： 在一个大事务下，需要本地创建订单，远程调用库存服务来查询库存和锁定库存，远程查询优惠信息，扣减积分。</p><p><img src="/2022/09/20/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20220919221259619.png" alt="image-20220919221259619"></p><h5 id="本地事务能够解决"><a href="#本地事务能够解决" class="headerlink" title="本地事务能够解决"></a>本地事务能够解决</h5><p>创建订单出现异常，本地事务回滚；</p><p>远程查询库存，或远程查积分出现异常，本地事务回滚；</p><h5 id="本地事务不能解决"><a href="#本地事务不能解决" class="headerlink" title="本地事务不能解决"></a>本地事务不能解决</h5><ol><li>远程服务假失败，创建订单成功，远程查询库存锁定库存成功，但是由于网络问题，导致没有远程库存服务返回出现异常，本地事务回滚，即订单回滚，但是，远程库存事务是执行成功了，并没有回滚，导致库存扣减成功，订单却没有创建。</li><li>创建订单成功，远程查询库存锁库存成功，但是远程查积分出错，回滚，导致返回发生异常，导致本地事务回滚，订单属于本地事务，回滚，但是库存事务不在本地，不能回滚，所以又导致了导致库存扣减成功，订单却没有创建。</li></ol><p>订单服务连接的是订单数据库，这是一个连接，库存服务连接的是库存数据库，这是一个新的连接，会员服务链接的是会员数据库，这也是一个新的连接。远程调用实际上是一个新的连接，会员服务发生异常，库存服务是感知不到的，已经执行成功的请求是不能回滚的。</p><p>远程服务假失败：远程服务其实成功了，由于网络故障等没有返回，导致：订单回滚，库存却扣减<br>远程服务执行完成，下面的其他方法出现问题，导致：已执行的远程请求，肯定不能回滚</p><p>本地事务只能控制住在同一个连接中的异常，在分布式系统中，A服务远程调用B服务，B服务远程调用C服务，C服务远程调用D服务，任何一个远程服务出现问题，已经成功执行的远程服务没办法通过Transactional来实现事务的回滚，除非这几个服务不是远程服务，操作的是同一个数据库，在同一个连接内。</p><p>本地事务在分布式系统下，只能控制住自己数据库的回滚，控制不了其他服务的数据库的回滚。分布式事务的问题：网络问题+分布式机器（数据库不是同一个）。</p><h3 id="3、分布式事务"><a href="#3、分布式事务" class="headerlink" title="3、分布式事务"></a>3、分布式事务</h3><h5 id="1、为什么有分布式事务？"><a href="#1、为什么有分布式事务？" class="headerlink" title="1、为什么有分布式事务？"></a>1、为什么有分布式事务？</h5><p>分布式系统经常出现的异常：机器宕机、 网络异常、 消息丢失、 消息乱序、 数据错误、 不可靠的 TCP、 存储数据丢失 。。。。。由于以上问题都会导致分布式系统下，某一个服务的状态不能被其他服务感知到。</p><p>分布式事务是企业集成中的一个技术难点， 也是每一个分布式系统架构中都会涉及到的一个东西， 特别是在微服务架构中， 几乎可以说是无法避免。</p><h5 id="2、CAP-定理"><a href="#2、CAP-定理" class="headerlink" title="2、CAP 定理"></a>2、CAP 定理</h5><p>CAP 原则又称 CAP 定理， 指的是在一个分布式系统中。</p><p>一致性 ：在分布式系统中的所有数据备份， 在同一时刻是否都有同样的值。<br>可用性 ：在集群中一部分节点故障后， 集群整体是否还能响应客户端的读写请求。<br>分区容错性 ：大多数分布式系统都分布在多个子网络。 每个子网络就叫做一个区 。分区容错的意思是， 区间通信可能失败。 比如， 一台服务器放在中国， 另一台服务器放在美国， 这就是两个区， 它们之间可能无法通信。</p><p>CAP 原则指的是， 这三个要素最多只能同时实现两点， 不可能三者兼顾。</p><p>一般来说， 分区容错无法避免， 因此CAP 的 P 总是成立。 CAP 定理告诉我们，剩下的 C 和 A 无法同时做到。</p><p>分布式系统中实现一致性的 raft 算法：<a href="http://thesecretlivesofdata.com/raft/">http://thesecretlivesofdata.com/raft/</a> （领导选举，日志复制）</p><h5 id="3、base理论"><a href="#3、base理论" class="headerlink" title="3、base理论"></a>3、base理论</h5><p>对于多数大型互联网应用的场景， 主机众多、 部署分散， 而且现在的集群规模越来越大， 所以节点故障、 网络故障是常态， 而且要保证服务可用性达到 99.99999%（N 个 9） ， 即保证P 和 A， 舍弃 C。</p><p>是对 CAP 理论的延伸， 思想是即使无法做到强一致性（CAP 的一致性就是强一致性） ， 但可以采用适当的采取弱一致性， 即最终一致性</p><p>① 基本可用（Basically Available）：</p><p>基本可用是指分布式系统在出现故障的时候， 允许损失部分可用性（例如响应时间、功能上的可用性） ， 允许损失部分可用性。 需要注意的是， 基本可用绝不等价于系统不可用。</p><p>响应时间上的损失： 正常情况下搜索引擎需要在 0.5 秒之内返回给用户相应的查询结果， 但由于出现故障（比如系统部分机房发生断电或断网故障） ， 查询结果的响应时间增加到了 1~2 秒。</p><p>功能上的损失： 购物网站在购物高峰（如双十一） 时， 为了保护系统的稳定性，部分消费者可能会被引导到一个降级页面。</p><p>② 软状态（ Soft State）:</p><p>软状态是指允许系统存在中间状态， 而该中间状态不会影响系统整体可用性。 分布式存储中一般一份数据会有多个副本， 允许不同副本同步的延时就是软状态的体现。 mysql replication 的异步复制也是一种体现。</p><p>③ 最终一致性（ Eventual Consistency）:</p><p>最终一致性是指系统中的所有数据副本经过一定时间后， 最终能够达到一致的状态。 弱一致性和强一致性相反， 最终一致性是弱一致性的一种特殊情况</p><p>从客户端角度， 多进程并发访问时， 更新过的数据在不同进程如何获取的不同策略， 决定了不同的一致性。 对于关系型数据库， 要求更新过的数据能被后续的访问都能看到， 这是强一致性。 如果能容忍后续的部分或者全部访问不到， 则是弱一致性。 如果经过一段时间后要求能访问到更新后的数据， 则是最终一致性 。</p><h5 id="4、分布式事务常见解决方案"><a href="#4、分布式事务常见解决方案" class="headerlink" title="4、分布式事务常见解决方案"></a>4、分布式事务常见解决方案</h5><p>1、2PC 模式</p><p>数据库支持的 2PC【 2 phase commit 二阶提交】 ， 又叫做 XA Transactions。其中， XA 是一个两阶段提交协议， 该协议分为以下两个阶段：<br>第一阶段： 事务协调器要求每个涉及到事务的数据库预提交(precommit)此操作， 并反映是否可以提交。<br>第二阶段： 事务协调器要求每个数据库提交数据。<br>其中， 如果有任何一个数据库否决此次提交， 那么所有数据库都会被要求回滚它们在此事务中的那部分信息 。</p><p>XA 协议比较简单， 而且一旦商业数据库实现了 XA 协议， 使用分布式事务的成本也比较低。<br>XA 性能不理想， 特别是在交易下单链路， 往往并发量很高， XA 无法满足高并发场景<br>XA 目前在商业数据库支持的比较理想， 在 mysql 数据库中支持的不太理想， mysql 的<br>XA 实现， 没有记录 prepare 阶段日志， 主备切换回导致主库与备库数据不一致。<br>许多 nosql 也没有支持 XA， 这让 XA 的应用场景变得非常狭隘。</p><p>2、柔性事务-TCC 事务补偿型方案</p><p>刚性事务： 遵循 ACID 原则， 强一致性。<br>柔性事务： 遵循 BASE 理论， 最终一致性；<br>与刚性事务不同， 柔性事务允许一定时间内， 不同节点的数据不一致， 但要求最终一致。</p><p>一阶段 prepare 行为： 调用 自定义 的 prepare 逻辑。<br>二阶段 commit 行为： 调用 自定义 的 commit 逻辑。<br>二阶段 rollback 行为： 调用 自定义 的 rollback 逻辑。<br>所谓 TCC 模式， 是指支持把 自定义 的分支事务纳入到全局事务的管理中。</p><p>3、柔性事务-最大努力通知型方案</p><p>按规律进行通知， 不保证数据一定能通知成功， 但会提供可查询操作接口进行核对。 这种方案主要用在与第三方系统通讯时， 比如： 调用微信或支付宝支付后的支付结果通知。 这种方案也是结合 MQ 进行实现， 例如： 通过 MQ 发送 http 请求， 设置最大通知次数。 达到通知次数后即不再通知。</p><p>案例： 银行通知、 商户通知等（ 各大交易业务平台间的商户通知： 多次通知、 查询校对、 对账文件） ，支付宝的支付成功异步回调</p><p>4、柔性事务-可靠消息+最终一致性方案（ 异步确保型）</p><p>实现： 业务处理服务在业务事务提交之前， 向实时消息服务请求发送消息， 实时消息服务只记录消息数据， 而不是真正的发送。 业务处理服务在业务事务提交之后， 向实时消息服务确认发送。 只有在得到确认发送指令后， 实时消息服务才会真正发送。</p><h3 id="4、分布式事务Seata"><a href="#4、分布式事务Seata" class="headerlink" title="4、分布式事务Seata"></a>4、分布式事务Seata</h3><p>Seata使用的是2PC模式</p><p>TC负责协调全局、TM用来控制整个大的事务、每个微服务中使用RM这个资源管理器来控制</p><p>① TM（大事务）首先会告诉TC，准备开启一个全局事务</p><p>② TM调用远程服务后，不论是成功还是失败，TC都知道</p><p>③ 假如一个小事务出现异常回滚了，那么之前成功的事务也要回滚</p><p><img src="/2022/09/20/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/1.png" alt="1"></p><h5 id="整合Seata"><a href="#整合Seata" class="headerlink" title="整合Seata"></a>整合Seata</h5><p>1、为每一个需要使用Seata的服务创建一个undo_log表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `undo_log` (</span><br><span class="line">  `id` bigint(20) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `branch_id` bigint(20) NOT NULL,</span><br><span class="line">  `xid` varchar(100) NOT NULL,</span><br><span class="line">  `context` varchar(128) NOT NULL,</span><br><span class="line">  `rollback_info` longblob NOT NULL,</span><br><span class="line">  `log_status` int(11) NOT NULL,</span><br><span class="line">  `log_created` datetime NOT NULL,</span><br><span class="line">  `log_modified` datetime NOT NULL,</span><br><span class="line">  `ext` varchar(100) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `ux_undo_log` (`xid`,`branch_id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><p>2、在每个需要使用Seata的微服务<code>spring-cloud-starter-alibaba-seata</code></p><p>3、安装Seata服务器（TC）<strong>注意：要与导入依赖版本对应</strong></p><p>4、在服务器文件目录下修改<code>registry.conf</code>，指明seata配置中心地址为nacos </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">registry &#123;</span><br><span class="line"></span><br><span class="line">  # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa </span><br><span class="line"></span><br><span class="line">  type = &quot;nacos&quot;</span><br><span class="line"></span><br><span class="line">  nacos &#123;</span><br><span class="line">    serverAddr = &quot;localhost:8848&quot;</span><br><span class="line">    namespace = &quot;public&quot;</span><br><span class="line">    cluster = &quot;default&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、为每个需要使用Seata的微服务注入DataSourceProxy数据源，因为Seata是通过代理数据源实现分支事务</p><p>6、每个需要用分布式事务的微服务都必须导入file.conf和registry.conf ,（gulimall-order和gulimall-ware）且 file.conf 的 service.vgroup_mapping 配置必须和spring.application.name一致</p><p>因为每个服务默认会使用 ${spring.application.name}-fescar-service-group作为服务名注册到 Seata Server上，如果和file.conf中的配置不一致，会提示 no available server to connect 错误</p><p>也可以通过配置 spring.cloud.alibaba.seata.tx-service-group 修改后缀，但是必须和file.conf 中的配置保持一致</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">service</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># vgroup-&gt;rgroup</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># vgroup_mapping.my_test_tx_group = &quot;default&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">vgroup_mapping.gulimall-order-fescar-service-group</span> <span class="string">=</span> <span class="string">&quot;default&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">service</span> &#123;  </span><br><span class="line"></span><br><span class="line"><span class="comment">#vgroup-&gt;rgroup  </span></span><br><span class="line"></span><br><span class="line"><span class="string">vgroup_mapping.gulimall-ware-fescar-service-group</span>  <span class="string">=</span> <span class="string">&quot;default&quot;</span> </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7、在大事务上添加注解<code>@GlobalTransactional</code>    <strong>不要忘了</strong></p><h3 id="5、柔性事务-可靠消息-最终一致性方案（-异步确保型）"><a href="#5、柔性事务-可靠消息-最终一致性方案（-异步确保型）" class="headerlink" title="5、柔性事务-可靠消息+最终一致性方案（ 异步确保型）"></a><strong>5、柔性事务-可靠消息+最终一致性方案（ 异步确保型）</strong></h3><p>Seata存在的问题： 使用了Seata主推的AT（Auto Transaction）模式，使用了各种锁，效率低，不适合高并发下使用。</p><p>所以在高并发下推荐使用——柔性事务-最大努力通知型方案 或 柔性事务-可靠消息+最终一致性方案（ 异步确保型）</p><p><img src="/2022/09/20/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/2.png" alt="2"></p><h4 id="RabbitMQ延时队列"><a href="#RabbitMQ延时队列" class="headerlink" title="RabbitMQ延时队列"></a>RabbitMQ延时队列</h4><p>场景：比如未付款订单，超过一定时间后，系统自动取消订单并释放占有物品。<br>常用解决方案：spring的 schedule 定时任务轮询数据库<br>缺点：消耗系统内存、增加了数据库的压力、存在较大的时间误差<br>解决：RabbitMQ的消息TTL和死信Exchange结合</p><p><img src="/2022/09/20/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/3.png" alt="3"></p><h4 id="消息和队列TTL（Time-To-Leave）"><a href="#消息和队列TTL（Time-To-Leave）" class="headerlink" title="消息和队列TTL（Time To Leave）"></a>消息和队列TTL（Time To Leave）</h4><ul><li>RabbitMQ可以对消息或队列设置TTL</li><li>死信：TTL清零，即消息过期了，称为死信</li><li>如果队列和消息都设置了TTL（过期时间），会取其中较小值</li><li>Dead Letter Exchange其实就是一种普通的exchange，和创建其他exchange没有两样。</li></ul><h4 id="延时队列实现方式："><a href="#延时队列实现方式：" class="headerlink" title="延时队列实现方式："></a>延时队列实现方式：</h4><p>方式一：设置队列过期时间（推荐）</p><p><img src="/2022/09/20/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/4.png" alt="4"></p><p>方式二：设置消息过期时间（存在问题，不推荐）</p><p><img src="/2022/09/20/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/5.png" alt="5"></p><p>简化：节省了一个交换机</p><p><img src="/2022/09/20/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/6.png" alt="6"></p><h4 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h4><p>采用方式一设置队列过期时间，重点在设置队列，其他与平时使用没有区别：只需给队列封装如下参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">** x-dead-letter-exchange: order-event-exchange       //队列过期后交给那个交换机  </span><br><span class="line">\* x-dead-letter-routing-key: order.release.order     //过期后交给指定交换机后，在交给队列所使用的路由键</span><br><span class="line">\* x-message-ttl: 60000*//过期时间</span><br></pre></td></tr></table></figure><h4 id="可靠消息"><a href="#可靠消息" class="headerlink" title="可靠消息"></a>可靠消息</h4><p>延时队列必须保证消息的可靠</p><p>1、如何保证消息可靠性-消息丢失</p><p>消息发送出去，由于网络问题没有抵达服务器<br>做好容错方法（try-catch），发送消息可能会网络失败，失败后要有重试机制，可记录到数据库，采用定期扫描重发的方式<br>做好日志记录，每个消息状态是否都被服务器收到都应该记录<br>做好定期重发，如果消息没有发送成功，定期去数据库扫描未成功的消息进行重发<br>消息抵达Broker，Broker要将消息写入磁盘（持久化）才算成功。此时Broker尚未持久化完成，宕机。<br>publisher也必须加入确认回调机制，确认成功的消息，修改数据库消息状态。<br>自动ACK的状态下。消费者收到消息，但没来得及消息然后宕机<br><strong>一定开启手动ACK</strong>，消费成功才移除，失败或者没来得及处理就noAck并重新入队。<br>2、消息重复</p><p>消息消费成功，事务已经提交，ack时，机器宕机。导致没有ack成功，Broker的消息重新由unack变为ready，并发送给其他消费者。<br>消息消费失败，由于重试机制，自动又将消息发送出去。<br>成功消费，ack时宕机，消息由unack变为ready，Broker又重新发送。<br>消费者的业务消费接口应该设计为幂等性的。比如扣库存有工作单的状态标志。<br>使用防重表（redis&#x2F;mysql），发送消息每一个都有业务的唯一标识，处理过就不用处理。<br>rabbitMQ的每一个消息都有redelivered字段，可以获取是否是被重新投递过来的，而不是第一次投递过来的。<br>3、消息积压</p><p>消费者宕机积压<br>消费者消费能力不足积压<br>发送者发送流量太大<br>上线更多的消费者，进行正常消费<br>上线专门的队列消费服务，将消息先批量取出来，记录数据库，离线慢慢处理</p>]]></content>
      
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> RabbitMQ </tag>
            
            <tag> Seata </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
