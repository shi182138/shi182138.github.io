<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>注解(一)</title>
      <link href="/2022/10/08/%E6%B3%A8%E8%A7%A3-%E4%B8%80/"/>
      <url>/2022/10/08/%E6%B3%A8%E8%A7%A3-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>注解，或者叫做注释，英文单词是:Annotation</p><p>注解Annotation是一种引用数据类型。编译之后也是生成xxx.class文件.</p><p>怎么自定义注解呢? 语法格式?</p><ul><li>[修饰符列表]  @interface  注解类型名 {</li><li>}</li></ul><p>注解怎么使用,，用在什么地方?</p><p>​注解使用时的语法格式是:</p><ul><li><p>@注解类型名</p></li><li><p>第二:注解可以出现在类上、属性上、方法上、变量上等….</p></li><li><p>注解还可以出现在注解上。</p></li><li><p>JDK内置了哪些注解呢?</p><ul><li><p>java. lang包下的注释类型:</p></li><li><p>掌握:</p></li><li><p>Deprecated用@Deprecated注释的程序元索，</p></li><li><p>不鼓励程序员使用这样的元素，通常是因为它很危险或存在更好的选择。</p></li><li><p>掌握:</p></li><li><p>Override表示一个方法声明打算重写超类中的另一个方法声明。</p></li><li><p>不用掌握:</p></li><li><p>Suppresswarnings指示应该在注释元素（以及包含在该注释元素中的所有程序元素)中取消显示指定的编译器警告。</p></li></ul></li></ul><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>什么是元注解?<br>用来标注”注解类型”的”注解”，称为元注解。常见的元注解有哪些?</p><ul><li>Target</li><li>Retention</li></ul><p>关于Target注解:<br>    这是一个元注解，用来标注注斛类型n的”注解”<br>    这个Target注解用来标注”被标注的注解”可以出现在哪些位置上。</p><p>@Target(ElementType.METHOD):表示”被标注的注解”只能出现在方法上.</p><p>@Target(value&#x3D;{CONSTRUCTOR，FIELD，LOCAL_VARIABLE，METHOD，PACKAGE，MODULE,PARAMETER，TYPE})</p><p>表示该注解可以出现在:<br>构造方法上<br>字段上<br>局部变量上方法上<br>类上…</p><p>关于Retention注解:</p><p>这是一个元注解，用来标注”注解类型”的”注解”</p><p>这个Retention注解用来标注”被标注的注解”最终保存在哪里。</p><p>@Retention(RetentionPolicy .SOURCE):表示该注解只被保留在java源文件中</p><p>@Retention(RetentionPolicy .CLASS):表示该注解被保存在class文件中。</p><p>@Retention(RetentionPolicy .RUNTIME):表示该注解被保存在class文件中，并且可以被反射机制所读取</p><h2 id="注解中定义属性"><a href="#注解中定义属性" class="headerlink" title="注解中定义属性"></a>注解中定义属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAnnotationTest</span> &#123;</span><br><span class="line"><span class="comment">//报错的原因:如果一个注解当中有属性，那么必须给属性赋值。（除非该属性使用default指定了默认值）</span></span><br><span class="line">    <span class="comment">/*@MyAnnotation</span></span><br><span class="line"><span class="comment">public void doSome()&#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//@MyAnnotation(属性名=属性值)</span></span><br><span class="line">    <span class="comment">//指定name属性的值就好了</span></span><br><span class="line">    <span class="meta">@MyAnnotation(name=&quot;zhangsan&quot;, color=&quot;红色&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyAnnotation</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *我们通常在注解当中可以定义属性，以下这个是MyAnnotation的name属性。</span></span><br><span class="line"><span class="comment">    *看着像1个方法，但实际上我们称之为属性nameo</span></span><br><span class="line"><span class="comment">    *@return</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    String <span class="title function_">name</span><span class="params">( )</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    颜色属性</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    string <span class="title function_">color</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    年龄属性</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">age</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">25</span>; <span class="comment">//属性指定默认值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="属性是value时可以省略"><a href="#属性是value时可以省略" class="headerlink" title="属性是value时可以省略"></a>属性是value时可以省略</h2><p>如果一个注解的属性的名字是value的话，<strong>并且只有一个属性的话，</strong>在使用的时候，该属性名可以省略。|</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAnnotationTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//报错原因:没有指定属性的值。</span></span><br><span class="line">    <span class="comment">/*@MyAnnotation</span></span><br><span class="line"><span class="comment">    public void dosome( )&#123;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="meta">@MyAnnotation(value = &quot;hehe&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@MyAnnotalpion( &quot;haha&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">do0ther</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    指定一个value属性。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="注解属性是一个数组"><a href="#注解属性是一个数组" class="headerlink" title="注解属性是一个数组"></a>注解属性是一个数组</h2><p>Retention的源代码<br>&#x2F;&#x2F;元注解<br>public @interface Retention {l<br>&#x2F;&#x2F;属性<br>RetentionPol1cy value () ;<br>}<br>RetentionPolioy的源代码:<br>public enum RetentionPolicy {<br>    SOURCE,<br>    CLASS,</p><p>​RUNTIME<br>}<br>Target的源代码</p><p><strong>如果数组中只有1个元素:大括号可以省略。</strong></p><p><strong>看看Retention，Target的源代码，你会发现使用的就是枚举和枚举数组</strong>，所以你懂的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        注解当中的属性可以是哪―种类型?</span></span><br><span class="line"><span class="comment">        属性的类型可以是:</span></span><br><span class="line"><span class="comment">        byte short int long float double boolean char String Class 枚举类型以及以上每一种的数组形式。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">value1</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    String <span class="title function_">value2</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>[ ] value3();</span><br><span class="line">    </span><br><span class="line">    string[] value4();</span><br><span class="line">    </span><br><span class="line">    Season <span class="title function_">value5</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    Season[ ] value6();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">parameterType</span>();</span><br><span class="line">    </span><br><span class="line">    Class[] parameterTypes();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//枚举</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Season</span> &#123;</span><br><span class="line">    SPRING,SUMMER,AUTUMN,WINTER;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> OtherAnnotation &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    年龄厨性</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">age</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    邮箱地址属性，支持多个</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    string[] email( );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    平季节数组,Season是枚举类翟</span></span><br><span class="line"><span class="comment">    <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    season[ ] seasonArray();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OtherAnnotationTest</span> &#123;</span><br><span class="line">    <span class="comment">//数组是大括号</span></span><br><span class="line">    <span class="meta">@otherAnnotation(age = 25,email = &#123; &quot;zhangsan@123.com&quot; , &quot;zhangsan@sohu.com&quot; &#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dosome</span><span class="params">()</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果数组中只有1个元素:大括号可以省略。</span></span><br><span class="line"><span class="meta">@OtherAnnotation(age = 25，email = &quot;zhangsan@123.com&quot;, seasonArray = &#123;Season.SPRING,Season.SUNMNER&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doother</span><span class="params">()</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="反射注解"><a href="#反射注解" class="headerlink" title="反射注解"></a>反射注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectAnnotation</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[ ] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//获取这个类</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">c</span> = class.forName(<span class="string">&quot;com.bjpowernode.java.annotation5.MyAnnotationTest&quot;</span>);</span><br><span class="line"><span class="comment">//判断类上面是否有@MyAnnotation</span></span><br><span class="line">        <span class="comment">//System.out.println(c.isAnnotationPresent(MyAnnotation.cLass)); //true </span></span><br><span class="line">        <span class="keyword">if</span>(c.isAnnotationPresent(MyAnnotation.c1ass))&#123;</span><br><span class="line">            <span class="comment">//获取该注解对象</span></span><br><span class="line">            <span class="type">MyAnnotation</span> <span class="variable">myAnnotation</span> <span class="operator">=</span> (MyAnnotation)c.getAnnotation(MyAnnotation.class);</span><br><span class="line">            <span class="comment">//System.out.println(&quot;类上面的注解对象”+ myAnnotation); //l@com.bjpowernode.java.</span></span><br><span class="line">            <span class="comment">//获取注解对象的属性怎么办﹖和调接口没区别。</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> myAnnotation.value();</span><br><span class="line">            system.out.println(value);</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="comment">//判断string类上面是否存在这个注解</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">stringClass</span> <span class="operator">=</span> class.forName( <span class="string">&quot;java.lang.String&quot;</span> );</span><br><span class="line">        System.out.println(stringClass.isAnnotationPresent(MyAnnotation.class)); <span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义注解</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//只允许该注解可以标注类、方法</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE，ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="comment">//希望这个注解可以被反射</span></span><br><span class="line"><span class="meta">@Retention</span> (RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">vaLue属性。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">String <span class="title function_">value</span><span class="params">( )</span> defau1t<span class="string">&quot;北京大兴区&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注解使用</span></span><br><span class="line"><span class="meta">@MyAnnotation(&quot;上海浦东区&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAnnotationTest</span> &#123;</span><br><span class="line">    <span class="comment">//@MyAnnotation</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//@MyAnnotation</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyAnnotationTest</span><span class="params">( )</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@MyAnnotation</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">( )</span>&#123;</span><br><span class="line">    <span class="comment">//@MyAnnotation</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="通过反射获取注解对象属性的值"><a href="#通过反射获取注解对象属性的值" class="headerlink" title="通过反射获取注解对象属性的值"></a>通过反射获取注解对象属性的值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义注解</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line"></span><br><span class="line">╱*</span><br><span class="line">username属性</span><br><span class="line">    */</span><br><span class="line">string <span class="title function_">username</span><span class="params">( )</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">password国性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    string <span class="title function_">password</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAnnotationTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyAnnotation(username = &quot;admin&quot;, password = &quot;456456&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dosome</span><span class="params">()</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[ ] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//获取MyAnnotationTest的doSome()方法上面的注解信息。</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> class.forName(<span class="string">&quot;com.bjpowernode,java.annotation6.MyAnnotationTest&quot;</span> );</span><br><span class="line">        <span class="comment">//获取doSome( )方法</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">doSomeMethod</span> <span class="operator">=</span> c.getDeclaredMethod( name: <span class="string">&quot;doSome&quot;</span>);</span><br><span class="line">        <span class="comment">//判断该方法上是否存在这个注解</span></span><br><span class="line">    <span class="keyword">if</span>( doSomeMethod.isAnnotationPresent(MyAnnotation.class)) &#123;</span><br><span class="line">    <span class="type">MyAnnotation</span> <span class="variable">myAnnotation</span> <span class="operator">=</span> doSomeMethod.getAnnotation(MyAnnotation.class);</span><br><span class="line">            System.out.println( myAnnotation.username( ));</span><br><span class="line">    System.out.println(myAnnotation.password());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="注解在开发中有什么用"><a href="#注解在开发中有什么用" class="headerlink" title="注解在开发中有什么用"></a>注解在开发中有什么用</h2><p>注解在程序当中相当于一种标记，如果有这个注解怎么办，没有这个注解怎么办</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个User类</span></span><br><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    string name;</span><br><span class="line">    </span><br><span class="line">    String password;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个注解</span></span><br><span class="line"><span class="comment">//表示这个注解只能出现在类上面</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="comment">//该注解可以被反射机制读取到</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Id &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这个注解@Id用来标注类，被标注的类中必须有一个int类型的id属性，没有就报异常。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//获取类</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">userClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com. bjpowernode.java.annotation7.User&quot;</span>);</span><br><span class="line">        <span class="comment">//判断类上是否存在Id注解</span></span><br><span class="line">        <span class="keyword">if</span>(userClass.isAnnotationPresent( Id.class)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当一个类上面有@Id注解的时候，要求类中必须存在int类型的id属性</span></span><br><span class="line">            <span class="comment">//如果没有int类型的id属性则报异常。</span></span><br><span class="line">            <span class="comment">//获取类的属性</span></span><br><span class="line">            Field[] fields = userClass.getDeclaredFields();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isok</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//给一个默认的标记</span></span><br><span class="line">            <span class="keyword">for</span>(Field field : fields)&#123;</span><br><span class="line">                <span class="keyword">if</span>( <span class="string">&quot;id&quot;</span>.equals(field.getName()) &amp;&amp; <span class="string">&quot;int&quot;</span>.equals(field.getType( ).getSimpleName()))&#123;</span><br><span class="line">                    <span class="comment">//表示这个类是合法的类。有@Id注解，则这个类中必须有int类型的id</span></span><br><span class="line">                    isOk = <span class="literal">true</span>;<span class="comment">//表示合法</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//判断是否合法</span></span><br><span class="line">            <span class="keyword">if</span>( !isOk)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">HasNotIdPropertyException</span>(<span class="string">&quot;被@Id注解标注的类中必须要有一个int类型的id属性!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HasNotIdPropertyException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HasNotIdPropertyException</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HasNotIdPropertyException</span><span class="params">(String s)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Annotation </tag>
            
            <tag> 注解 </tag>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射</title>
      <link href="/2022/10/08/%E5%8F%8D%E5%B0%84/"/>
      <url>/2022/10/08/%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h2 id="反射机制有什么用"><a href="#反射机制有什么用" class="headerlink" title="反射机制有什么用?"></a>反射机制有什么用?</h2><p>通过java语言中的反射机制<strong>可以操作字节码文件</strong>。</p><p>有<strong>点类似于黑客</strong>。(可以读和修改字节码文件。)</p><p>通过反射机制可以操作<strong>代码片段</strong>。(class文件。)</p><h2 id="反射机制的相关类在哪个包下"><a href="#反射机制的相关类在哪个包下" class="headerlink" title="反射机制的相关类在哪个包下?"></a>反射机制的相关类在哪个包下?</h2><p>java . lang . reflect.* ;</p><h2 id="反射机制相关的重要的类有哪些"><a href="#反射机制相关的重要的类有哪些" class="headerlink" title="反射机制相关的重要的类有哪些?"></a>反射机制相关的重要的类有哪些?</h2><p>java.lang.class: 代表整个字节码,代表一个类型–代表整个类</p><p>java.lang.reflect.Method:代表字节码中的方法字节码。–代表类中的方法</p><p>java.lang.reflect.Constructor:代表字节码中的构造方法字节码。–代表类中的构造方法</p><p>java. lang.reflect.Field:代表字节码中的属性字节码。  –代表类中的成员</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">java.lang.class:</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="comment">//Field</span></span><br><span class="line">    <span class="type">int</span> no;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//constructor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">user</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span> <span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Method</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNo</span> <span class="params">(<span class="type">int</span> no)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNo</span> <span class="params">( )</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取Class的三种方式"><a href="#获取Class的三种方式" class="headerlink" title="获取Class的三种方式"></a>获取Class的三种方式</h2><p>第一种</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">要操作一个类的字节码，需要首先获取到这个类的字节码，怎么获取java.Lang.CLass实例?</span></span><br><span class="line"><span class="comment">三种方式</span></span><br><span class="line"><span class="comment">    第一种: cLass c = CLass.forName(&quot;完整类名带包名&quot;);</span></span><br><span class="line"><span class="comment">    第二种:class c =对象.getCLass();</span></span><br><span class="line"><span class="comment">    第三种：Class c = 任何类型.class</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( string[ ] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        cLass.forName()</span></span><br><span class="line"><span class="comment">            1、静态方法</span></span><br><span class="line"><span class="comment">            2、方法的参数是一个字符串。</span></span><br><span class="line"><span class="comment">            3、字符串需要的是一个完整类名。</span></span><br><span class="line"><span class="comment">            4、完整类名必须带有包名。java.Lang包也不能省略。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">c2</span> = <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c1 = class.forName (<span class="string">&quot;java.lang.String&quot;</span>); <span class="comment">// c1代表string.class文件，或者说c1代表string类型</span></span><br><span class="line">            c2 = class.forName( <span class="string">&quot;java.util.Date&quot;</span>); <span class="comment">//c2代表Date类型</span></span><br><span class="line">            <span class="type">Class</span> <span class="variable">c3</span> <span class="operator">=</span> class.forName( <span class="string">&quot;java.lang.Integer&quot;</span>); <span class="comment">// c3代表Integer类型</span></span><br><span class="line">            <span class="type">Class</span> <span class="variable">c4</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.System&quot;</span>);  <span class="comment">//c4代表System类型</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (classNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//java中任何一个对象都有一个方法 : getClass()</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span> ;</span><br><span class="line"><span class="type">Class</span> <span class="variable">x</span> <span class="operator">=</span> s.getClass();<span class="comment">// x代表string.cLass字节码文件.x代表String类型。</span></span><br><span class="line">        System.out.println(c1 == x); <span class="comment">// true ( ==判断的是对象的内存地址。)</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">time</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>( ) ;</span><br><span class="line"><span class="type">Class</span> <span class="variable">y</span> <span class="operator">=</span> time.getClass();</span><br><span class="line">System.out.println(c2 = y);<span class="comment">// true (c2秘y两个变量中保存的内存地址都是一样的，都指向方法区中的字节码文件</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三种方式，java语言中任何一种类型，包括基本数据类型，它都有.cLass属性。</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">z</span> <span class="operator">=</span> String.class; <span class="comment">//z代表string类型</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">k</span> <span class="operator">=</span> Date.class;  <span class="comment">//k代表Date类型Class f = int.c1ass; l/ f代表int类型</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">e</span> <span class="operator">=</span> <span class="type">double</span>.class; <span class="comment">// e代表double类型</span></span><br><span class="line">        System.out.println(x == z); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2022/10/08/%E5%8F%8D%E5%B0%84/1.png" alt="image-20221005132905741"></p><h2 id="通过放射实例化对象"><a href="#通过放射实例化对象" class="headerlink" title="通过放射实例化对象"></a>通过放射实例化对象</h2><p>​通过cLass的newInstance()方法来实例化对象。<br>​    注意:newInstance()方法内部实际上调用了无参数构造方法，必须保证无参构造存在才可以。|</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">获取到cLass ，能干什么?</span></span><br><span class="line"><span class="comment">    通过cLass的newInstance()方法来实例化对象。</span></span><br><span class="line"><span class="comment">    注意:newInstance()方法内部实际上调用了无参数构造方法，必须保证无参构造存在才可以。|</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//这是不使用反射机制，创建对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>( );</span><br><span class="line">system.out.println(user);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过反射机制，获取CLass，通过cLass来实例化对象</span></span><br><span class="line">            <span class="keyword">class</span> <span class="title class_">c</span> = class.forName( <span class="string">&quot;com. bjpowernode.java.bean.User&quot;</span> );</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//newInstance(）这个方法会调用user这个类的无参数构造方法，完成对象的创建。</span></span><br><span class="line">            <span class="comment">//重点是:newInstance()调用的是无参构造，必须保证无参构造是存在的!</span></span><br><span class="line">            <span class="type">object</span> <span class="variable">obj</span> <span class="operator">=</span> c.newInstance();</span><br><span class="line">        System.out.println(obj); <span class="comment">//com.bjpowernode .java.bean.User@10f87f48</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (classNotFoundException e) &#123;</span><br><span class="line">        e.printstackTrace();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IllegalAccessException e)&#123;</span><br><span class="line">        e.printstackTrace();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">        e.printStackTrace( );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">         </span><br><span class="line">     &#125;</span><br><span class="line"> &#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="反射机制的灵活性"><a href="#反射机制的灵活性" class="headerlink" title="反射机制的灵活性"></a>反射机制的灵活性</h2><p>为什么要使用反射来创建对象？？？</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置文件</span></span><br><span class="line"><span class="attr">className</span>=<span class="string">com.bjpowernode.java.bean.User</span></span><br><span class="line"><span class="comment">#可以修改配置文件</span></span><br></pre></td></tr></table></figure><p>​–以下代码可以通过修改上面的配置文件，来创建不同的类对象</p><p>​如className&#x3D;java.util.date</p><p>​那么创建出来的对象就是date类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    验证反射机制的灵活性。</span></span><br><span class="line"><span class="comment">    java代码写一边，在不改变java源代码的基础之上，可以做到不同对象的实例化。</span></span><br><span class="line"><span class="comment">    非常之灵活（符合oCP开闭原则:对扩展开放，对修改关闭。)</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    后期我们学习的是高级框架，而工作过程中，也都是使用高级框架，包括: ssh ssm</span></span><br><span class="line"><span class="comment">    Spring SpringMVC MyBatisSpring Struts Hibernate...</span></span><br><span class="line"><span class="comment">    这些高级框架底层实现原理:部采用了反射机制。所以反射机制还是重要的。学会了反射机制有利于你理解剖析框架底层的源代码。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//这种方式代码就写死了。只能创建一个user类型的对象</span></span><br><span class="line">        <span class="comment">//User user = new User();</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//以下代码是灵活的，代码不需要改动，可以修改配置文件，配置文件修改之后，可以创建出不同的实例对象。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过Io流读取cLassinfo.properties文件</span></span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>( fileName: <span class="string">&quot;chapter25/classinfo.properties&quot;</span>);</span><br><span class="line">        <span class="comment">//创建属性类对象Map</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>(); <span class="comment">//key value都是string</span></span><br><span class="line">        <span class="comment">//加载</span></span><br><span class="line">        pro.load(reader);</span><br><span class="line">        <span class="comment">//关闭流</span></span><br><span class="line">        reader.close();</span><br><span class="line">        <span class="comment">//通过key获取vaLue</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> pro.getProperty ( <span class="string">&quot;className&quot;</span> );</span><br><span class="line">        System.out.println(className);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//通过反射机制实例化对象</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">c</span> = class.forName(className);</span><br><span class="line">        <span class="type">object</span> <span class="variable">obj</span> <span class="operator">=</span> c.newInstance();</span><br><span class="line">        System.out.println(obj);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="class-forName-发生了什么"><a href="#class-forName-发生了什么" class="headerlink" title="class.forName()发生了什么"></a>class.forName()发生了什么</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">研究一下 : cLass.forName()发生了什么?</span></span><br><span class="line"><span class="comment">记住，重点:</span></span><br><span class="line"><span class="comment">如果你只是希望―个类的静态代码块执行，其它代码一律不执行，你可以使用:</span></span><br><span class="line"><span class="comment">cLass.forName(&quot;完整类名&quot;);</span></span><br><span class="line"><span class="comment">这个方法的执行会导致类加载，类加载时，静态代码块执行。</span></span><br><span class="line"><span class="comment">    提示:1</span></span><br><span class="line"><span class="comment">    后面JDBC技术的时候我们还需要。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//class.forName( )这个方法的执行会导致:类加载。</span></span><br><span class="line">            Class.forName( <span class="string">&quot;com.bjpowernode.java.reflect.MyClass&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (classNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="comment">//静态代码块在类加载时执行，并且只执行一次。</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">System.out.print1n( <span class="string">&quot;MyClass类的静态代码块执行了!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="获取类路径下文件的绝对路径"><a href="#获取类路径下文件的绝对路径" class="headerlink" title="获取类路径下文件的绝对路径"></a>获取类路径下文件的绝对路径</h2><p>out才是真正的根路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">研究一下文件路径的问题。</span></span><br><span class="line"><span class="comment">怎么获取一个文件的绝对路径。以下讲解的这种方式是通用的。但前提是:文件需要在类路怪下。才能用这种方式。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AboutPath</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//这种方式的路径缺点是:移糙性差，在IDEA中默认的当前路径是project的根。</span></span><br><span class="line">    <span class="comment">//这个代码假设离开了IDEA，换到了其它位置，可能当前路径就不是project的根了，这时这个路径就无效了。</span></span><br><span class="line">    <span class="comment">//FileReader reader = new FileReader( &quot;chapter25/cLassinfo2.properties&quot;);</span></span><br><span class="line">    <span class="comment">//接下来说一种比较通用的一种路径。即使代码换位置了，这样编写仍然是通用的。</span></span><br><span class="line">    <span class="comment">//注意:使用以下通用方式的前提是:这个文件必须在类路径下。</span></span><br><span class="line"><span class="comment">//什么类路径下?方式在src下的都是类路径下。【记住它】</span></span><br><span class="line"><span class="comment">//src是类的根路径。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    解释:</span></span><br><span class="line"><span class="comment">    Thread .currentThread()当前线程对象</span></span><br><span class="line"><span class="comment">    getContextCLassLoader(）是线程对象的方法，可以获取到当前线程的类加载器对象。</span></span><br><span class="line"><span class="comment">    getResource()【获取资源】这是类加载器对象的方法，当前线程的类加载器默认从类的根路径下加载资源。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader()</span><br><span class="line">        .getResource( name: <span class="string">&quot;classinfo2.properties&quot;</span>).getPath();  <span class="comment">//这种方式获取文件绝对路径是通用的</span></span><br><span class="line"><span class="comment">//采用以上的代码可以拿到—个文件的绝对路释。</span></span><br><span class="line"><span class="comment">//c:/Users/Administrator/IdeaProjects/javase/out/production/chapter25/classinfo2.properties</span></span><br><span class="line">    System.out.print1n(path);</span><br><span class="line">    </span><br><span class="line">     <span class="type">String</span> <span class="variable">path2</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader()</span><br><span class="line">        .getResource( name: <span class="string">&quot;com/test/db.properties&quot;</span>).getPath();</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="以流的形式直接返回"><a href="#以流的形式直接返回" class="headerlink" title="以流的形式直接返回"></a>以流的形式直接返回</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args )</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//获取一个文件的绝对路径了! ! ! !!</span></span><br><span class="line">    <span class="comment">/*String path = Thread . currentThread( ) .getContextCLassLoader()</span></span><br><span class="line"><span class="comment">        .getResource( &quot;cLassinfo2.properties&quot; ).getPath( );</span></span><br><span class="line"><span class="comment">    FileReader reader = new FiLeReader(path);*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//直接以流的形式返回</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">reader</span> <span class="operator">=</span> Thread.currentThread( ).getContextClassLoader()</span><br><span class="line">.getResourceAsStream( name: <span class="string">&quot;classinfo2.properties&quot;</span>);</span><br><span class="line"><span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">pro.load(reader);</span><br><span class="line">reader.close();<span class="comment">//通过key获取value</span></span><br><span class="line"><span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> pro.getProperty( <span class="string">&quot;className&quot;</span> );</span><br><span class="line">System.out.print1n(className) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="资源绑定器"><a href="#资源绑定器" class="headerlink" title="资源绑定器"></a>资源绑定器</h2><p>一直在用，血统纯正</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java.util包下提供了一个资源绑定器，便于获取属性配置文件中的内容。使用以下这种方式的时候，属性配置文件xxx.properties必须放到类路径下。*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResourceBundleTest</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//资源绑定器，只能绑定xxx . properties文件。并且这个文件必须在类路径下。文件扩展名也必须是properties</span></span><br><span class="line">        <span class="comment">//并且在写路径的时候，路径后面的扩展名不能写。</span></span><br><span class="line">        <span class="comment">//ResourceBundle bundle = ResourceBundLe.getBundle(&quot;cLassinfo2&quot; ); //千万不能加 .properties!!!</span></span><br><span class="line">        <span class="type">ResourceBundle</span> <span class="variable">bundle</span> <span class="operator">=</span> ResourceBundle.getBundle( <span class="string">&quot; com/bjpowernode/java/ bean/db&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> bundle.getString( key: <span class="string">&quot;className&quot;</span>);</span><br><span class="line">        System.out.print1n(className) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>关于JDK中自带的类加载器:</p><h4 id="什么是类加载器"><a href="#什么是类加载器" class="headerlink" title="什么是类加载器?"></a>什么是类加载器?</h4><p>专门负责加载类的命令&#x2F;工具。<br>ClassLoader</p><h4 id="JDK中自带了3个类加载器"><a href="#JDK中自带了3个类加载器" class="headerlink" title="JDK中自带了3个类加载器"></a>JDK中自带了3个类加载器</h4><ul><li><p>启动类加载器</p></li><li><p>扩展类加教器</p></li><li><p>应用类加载器</p></li></ul><h4 id="假设有这样一段代码"><a href="#假设有这样一段代码" class="headerlink" title="假设有这样一段代码:"></a>假设有这样一段代码:</h4><p>string s - “ abc” ;<br>代码在开始执行之前，会将所需要类全部加载到M当中。通过类加载器加载，看到以上代码类加载器会找string.class文件，找到就加载，那么是怎么进行加载的呢?<br>首先通过”启动类加载器”加载。<br>注意:启动类加载器专门加载: c:\Program Files\Java\jdk1.8.0_101ljre</p><p><img src="/2022/10/08/%E5%8F%8D%E5%B0%84/3.png" alt="image-20221005154300031"></p><p>rt.jar中都是JDK最核心的类库。</p><p>如果通过”启动类加载器”加载不到的时候，</p><p>会通过扩展类加载器”加载。<br>注意:扩展类加载器专门加载: C:\Program Files\Java\jdk1.8.0_144\jre\lib\ext</p><p><img src="/2022/10/08/%E5%8F%8D%E5%B0%84/2.png" alt="image-20221005154231210"></p><p>如果”扩展类加载器”没有加载到，那么</p><p>会通过”应用类加载器”加载。</p><p>注意:应用类加载器专门加载: <strong>classpath</strong>中的类。</p><h4 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><p><strong>java中为了保证类加载的安全，</strong>使用了双亲委派机制.优先从启动类加载器中加载，这个称为’’父”<br>“父”无法加载到，再从扩展类加载器中加载，这个称为”母”。双亲委派。如果都加载不到，才会考虑从应用类加载器中加载。直到加载到为止。</p><p><strong>父不是代码上的继承关系</strong></p><h2 id="获取Field"><a href="#获取Field" class="headerlink" title="获取Field"></a>获取Field</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反射属性Field</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Field翻译为字段，其实就是属性/成员</span></span><br><span class="line"><span class="comment">// 4个Field，分别采用了不同的访问控制权限修饰符</span></span><br><span class="line">    <span class="keyword">private</span> String name;  <span class="comment">//Field对象</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> age; <span class="comment">//FieLd对象boolean sex;</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> no;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">MATH_PI</span> <span class="operator">=</span> <span class="number">3.1415926</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"><span class="comment">//获取整个类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">studentClass</span> = Class.forName( <span class="string">&quot;com.bjpowernode.java.bean.Student&quot;</span>);<span class="comment">//获取类中所有的Field</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//com. bjpowernode.java.bean.Student</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> studentClass.getName();</span><br><span class="line">    System.out.println(<span class="string">&quot;完整类名:“ + className);</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    String simpleName = studentClass.getSimpleName();</span></span><br><span class="line"><span class="string">    System.out.println(&quot;</span>简类名:“ + simpleName);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取类中所有的public修饰的Field</span></span><br><span class="line">Field[] fields = studentClass.getFields();</span><br><span class="line">System.out.println(fields.length);<span class="comment">//测试数组中只有1个元素//取出这个Field</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> fields[<span class="number">0</span>];<span class="comment">//取出这个Field它的名字</span></span><br><span class="line"><span class="type">String</span> <span class="variable">fieldName</span> <span class="operator">=</span> f.getName( );</span><br><span class="line">    System.out.print1n(fieldName);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取所有的Field</span></span><br><span class="line">Field[] fs = studentClass.getDeclaredFields( );</span><br><span class="line">    System.out.print1n(fs. length); <span class="comment">//4</span></span><br><span class="line">system.out.println( <span class="string">&quot;===============================&quot;</span>);</span><br><span class="line">    <span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">for</span>(Field field : fs) &#123;</span><br><span class="line"><span class="comment">//获取属性的修饰符列表</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> field.getNodifiers();<span class="comment">//返回的修饰符是一个数字，每个数字是修饰符的代号!! !</span></span><br><span class="line">        system.out.println(i);</span><br><span class="line"><span class="comment">//可以将这个代号”数字转换成“字符串吗?</span></span><br><span class="line"><span class="type">String</span> <span class="variable">modifierstring</span> <span class="operator">=</span> Modifier.tostring(i);</span><br><span class="line">        System.out.println(modifierstring);</span><br><span class="line"><span class="comment">//获取属性的类型</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">fieldType</span> <span class="operator">=</span> field.getType();</span><br><span class="line">        <span class="comment">//String fName = fieldType.getName( );</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fName</span> <span class="operator">=</span> fieldType.getsimpleName();</span><br><span class="line">        system.out.println(fName) ;</span><br><span class="line">        <span class="comment">//获取属性的名字</span></span><br><span class="line">        System.out.println(field.getName());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反编译Field"><a href="#反编译Field" class="headerlink" title="反编译Field"></a>反编译Field</h2><p>获取java代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//创建这个是为了拼接字符串。</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">studentClass</span> <span class="operator">=</span> Class.forName( <span class="string">&quot;com.bjpowernode.java.bean.Student&quot;</span> );</span><br><span class="line">        s.append(Modifier.toString(studentClass.getModifiers()) + <span class="string">&quot; c1ass &quot;</span> + studentClass.getSimpleName() + <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">        Field[] fields = studentclass.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span>(Field field : fields)&#123;</span><br><span class="line">            s.append(<span class="string">&quot;\t&quot;</span> );</span><br><span class="line">            sappend(Modifier.toString(field.getModifiers());</span><br><span class="line">s.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">s. append(field.getType().getSimpleName());</span><br><span class="line">s.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">s.append(field.getName( ));</span><br><span class="line">s.append(<span class="string">&quot; ; \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        s.append(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2022/10/08/%E5%8F%8D%E5%B0%84/4.png" alt="image-20221005171152766"></p><h2 id="通过反射机制访问对象属性"><a href="#通过反射机制访问对象属性" class="headerlink" title="通过反射机制访问对象属性"></a>通过反射机制访问对象属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*必须掌握:</span></span><br><span class="line"><span class="comment">怎么通过反射机制访问一个java对象的属性?</span></span><br><span class="line"><span class="comment">给属性赋值set</span></span><br><span class="line"><span class="comment">获取属性的值get*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest07</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//我们不使用反射机制，怎么去访问一个对象的属性呢?</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="comment">//给属性赋值</span></span><br><span class="line">        s.no = <span class="number">1111</span>;<span class="comment">//三要素:给s对象的no属性赋值1111</span></span><br><span class="line">        <span class="comment">//要素1 :对象s</span></span><br><span class="line">        <span class="comment">//要素2 :no属性</span></span><br><span class="line">        <span class="comment">//要素3:1111</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//读属性值</span></span><br><span class="line">        <span class="comment">//两个要素:获取s对象的no属性的值</span></span><br><span class="line">        system.out.println( s.no);</span><br><span class="line">        <span class="comment">//使用反射机制，怎么去访问一个对象的属性。( set get )</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">studentClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.bjpowernode.java.bean.Student&quot;</span> );</span><br><span class="line">        <span class="type">object</span> <span class="variable">obj</span> <span class="operator">=</span> studentClass.newInstance(); <span class="comment">// obj就是Student对象。（底层调用无参数构造方法)</span></span><br><span class="line">        <span class="comment">//获取no属性（根据属性的名称来获取Field )</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">noFiled</span> <span class="operator">=</span> studentClass.getDeclaredField( <span class="string">&quot;no&quot;</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        给obj对象(Student对象)的no属性赋值</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">            虽然使用了反射机制，但是三要素还是缺一不可:</span></span><br><span class="line"><span class="comment">            要素1 : obj对象</span></span><br><span class="line"><span class="comment">            要素2 :no属性要素3 :2222值</span></span><br><span class="line"><span class="comment">        注意:反射机制让代码复杂了，但是为了一个“灵活”，这也是值得的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        noFiled.set(obj，<span class="number">22222</span>);<span class="comment">//给obj对象的no属性赋值2222</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//读取属性的值</span></span><br><span class="line"><span class="comment">//两个要素:获取obj对象的no属性的值。</span></span><br><span class="line">        System.out.println(noFiled.get(obj));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//可以访问私有的属性吗?</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> studentClass.getDeclaredField( <span class="string">&quot;name&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//打破封装（反射机制的缺点:打破封装，可能会给不法分子留下机会!!! )</span></span><br><span class="line">        <span class="comment">//这样设置完之后，在外部也是可以访问private的。</span></span><br><span class="line">        nameField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        </span><br><span class="line"><span class="comment">//给name属性赋值</span></span><br><span class="line">        nameField.set(obj, <span class="string">&quot;jackson&quot;</span> );<span class="comment">//获取name属性的值</span></span><br><span class="line">        System.out.println( nameField.get(obj));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="可变长度参数"><a href="#可变长度参数" class="headerlink" title="可变长度参数"></a>可变长度参数</h2><p>可变长度参数</p><p>int. . . args这就是可变长度参数</p><p>语法是:类型…（注意:<strong>一定是3个点</strong>。)</p><p>1、可变长度参数要求的参数个数是:G~N个。</p><p>2、可变长度参数在参数列表中必须在最后一个位置上，而且可变长度参数只能有1个。</p><p>3、可变长度参数可以当做一个数组来看待</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    可变长度参数</span></span><br><span class="line"><span class="comment">    int. . . args这就是可变长度参数</span></span><br><span class="line"><span class="comment">    语法是:类型...（注意:一定是3个点。)</span></span><br><span class="line"><span class="comment">    1、可变长度参数要求的参数个数是:G~N个。</span></span><br><span class="line"><span class="comment">    2、可变长度参数在参数列表中必须在最后一个位置上，而且可变长度参数只能有1个。</span></span><br><span class="line"><span class="comment">    3、可变长度参数可以当做一个数组来看待</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArgsTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( string[] args)</span> &#123;</span><br><span class="line">        m( );</span><br><span class="line">        m( <span class="number">10</span>);</span><br><span class="line">        m(<span class="number">10</span>，<span class="number">20</span>);</span><br><span class="line">        <span class="comment">//编译报错</span></span><br><span class="line">        <span class="comment">// m ( &quot;abc&quot; );</span></span><br><span class="line">        m2( <span class="number">100</span>) ;</span><br><span class="line">        m2( <span class="number">200</span>, <span class="string">&quot;abe&quot;</span> );</span><br><span class="line">        m2( <span class="number">200</span>,<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span> );</span><br><span class="line">        m2( <span class="number">200</span>，<span class="string">&quot;abe&quot;</span>, <span class="string">&quot;def&quot;</span>, “xyz<span class="string">&quot; );</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        m3(&quot;</span>ab<span class="string">&quot;, &quot;</span>de<span class="string">&quot;, &quot;</span>kk<span class="string">&quot;, &quot;</span>ff<span class="string">&quot;);</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        String[ ] strs = &#123;&quot;</span>a<span class="string">&quot; , &quot;</span>b<span class="string">&quot;,&quot;</span>c<span class="string">&quot;&#125;;</span></span><br><span class="line"><span class="string">//也可以传1个数组</span></span><br><span class="line"><span class="string">        m3(strs);</span></span><br><span class="line"><span class="string">        //直接传1个数组</span></span><br><span class="line"><span class="string">        m3(new String[]&#123;&quot;</span>我<span class="string">&quot; , &quot;</span>是<span class="string">&quot;, &quot;</span>中<span class="string">&quot;, &quot;</span>国<span class="string">&quot;,&quot;</span>人<span class="string">&quot;&#125;);//没必要</span></span><br><span class="line"><span class="string">        m3( &quot;</span>我<span class="string">&quot;, &quot;</span>是<span class="string">&quot; ,&quot;</span>中<span class="string">&quot; , &quot;</span>国<span class="string">&quot;，&quot;</span>人<span class="string">&quot;);</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string">           </span></span><br><span class="line"><span class="string">public static void m(int. . . args)&#123;</span></span><br><span class="line"><span class="string">        System.out.print1n( &quot;</span>m方法执行了!<span class="string">&quot;);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">//public static void m2(int. .. args2, String. . . args1)&#123;&#125;</span></span><br><span class="line"><span class="string">           </span></span><br><span class="line"><span class="string">     //必须在最后，只能有1个。</span></span><br><span class="line"><span class="string">    public static void m2(int a, string. . . args1)&#123;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    public static void m3( String... args)&#123;</span></span><br><span class="line"><span class="string">        //args有length属性，说明args是一个数组!</span></span><br><span class="line"><span class="string">            //可以将可变长度参数当做一个数组来看。</span></span><br><span class="line"><span class="string">        for(int i = 0; i &lt; args.length; i++)&#123;</span></span><br><span class="line"><span class="string">            system.out.println(args[i]);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><h2 id="反射Method"><a href="#反射Method" class="headerlink" title="反射Method"></a>反射Method</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">用户业务类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*登录方法</span></span><br><span class="line"><span class="comment">*<span class="doctag">@param</span> name用户名</span></span><br><span class="line"><span class="comment">*<span class="doctag">@param</span> password密码</span></span><br><span class="line"><span class="comment">*<span class="doctag">@return</span> true表示登录成功，false表示登录失败!</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">login</span><span class="params">(String name, string password)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( <span class="string">&quot;admin&quot;</span>.equals(name) &amp;&amp; <span class="string">&quot;123&quot;</span>.equals(password))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">*退出系统的方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logout</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;系统已经安全退出!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest08</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//获取类了</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">userServiceClass</span> <span class="operator">=</span> Class.forName( <span class="string">&quot; com.bjpowernode.java.service.UserService&quot;</span>);</span><br><span class="line">        <span class="comment">//获取所有的Method (包括私有的!)</span></span><br><span class="line">        Method[]methods = userServiceClass.getDeclaredMethods();</span><br><span class="line">        <span class="comment">//System .out.printLn(methods.Length); // 2</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//遍历Method</span></span><br><span class="line">        <span class="keyword">for</span>(Method method : methods)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//获取修饰符列表</span></span><br><span class="line">System.out.println(Modifier.toString(method.getNodifiers()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取方法的返回值类型</span></span><br><span class="line">        system.out.println(method.getReturnType( ).getsimpleName());</span><br><span class="line">            <span class="comment">//获取方法名</span></span><br><span class="line">        system.out. println(method.getName( ));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//方法的修饰符列表（—个方法的参数可能会有多个。）</span></span><br><span class="line">Class[] parameterTypes = method.getParameterTypes();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">class</span> <span class="title class_">parameterType</span> : parameterTypes)&#123;</span><br><span class="line">System.out.println(parameterType.getsimpleName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="反编译Method"><a href="#反编译Method" class="headerlink" title="反编译Method"></a>反编译Method</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*了解一下，不需要掌握*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest09</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>() ;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">userServiceClass</span> <span class="operator">=</span> Class.forName( <span class="string">&quot;com.bjpowernode.java.service.UserService&quot;</span>);</span><br><span class="line">        s.append(Modifier.toString(userServiceClass.getModifiers()) + <span class="string">&quot;class&quot;</span> + userServiceClass.getSimpleName + <span class="string">&quot;&#123;&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        Method[ ] methods = userServiceClass.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span>(Method method : methods)&#123;</span><br><span class="line">            <span class="comment">//public boolean login(String name , String password)&#123;&#125;</span></span><br><span class="line">            s.append(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            s.append(Modifier.toString( method.getModifiers()));</span><br><span class="line">            s.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            s.append(method.getReturnType( ).getsimpleName());</span><br><span class="line">            s.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            s.append(method .getName( ));</span><br><span class="line">            s.append(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">            <span class="comment">//参数列表</span></span><br><span class="line">            Class[] parameterTypes = method.getParameterTypes();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">class</span> <span class="title class_">parameterType</span> : parameterTypes)&#123;</span><br><span class="line">s.append(parameterType.getsimpleName( ));</span><br><span class="line">                s.append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">&#125;            </span><br><span class="line">            </span><br><span class="line">            <span class="comment">//删除指定下标位置上的字符</span></span><br><span class="line"><span class="keyword">if</span>(parameterTypes.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                s.deleteCharAt(s.length() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            s.append(<span class="string">&quot;)&#123;&#125;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">            s.append(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">            system.out.println(s);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="反射机制调用方法"><a href="#反射机制调用方法" class="headerlink" title="反射机制调用方法"></a>反射机制调用方法</h2><h4 id="必须掌握"><a href="#必须掌握" class="headerlink" title="必须掌握"></a>必须掌握</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest10</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[ ] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//不使用反射机制，怎么调用方法</span></span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line">        <span class="comment">//调用方法</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            要素分析:</span></span><br><span class="line"><span class="comment">            要素1∶对象userService</span></span><br><span class="line"><span class="comment">            要素2: login方法名</span></span><br><span class="line"><span class="comment">            要素3:叉参列表</span></span><br><span class="line"><span class="comment">            要素4:返回值</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">loginSuccess</span> <span class="operator">=</span> userService.login( <span class="string">&quot;admin&quot;</span>，<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="comment">//System.out.printLn( LoginSuccess);</span></span><br><span class="line">        System.out.println(loginSuccess ?<span class="string">&quot;登录成功&quot;</span>:<span class="string">&quot;登录失败&quot;</span>);</span><br><span class="line">        <span class="comment">//使用反射机制来调用―个对象的方法该怎么做?</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">userServiceClass</span> <span class="operator">=</span> Class.forName( <span class="string">&quot; com.bjpowernode.java.service.UserService&quot;</span>);</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> userServiceClass.newInstance();</span><br><span class="line">        <span class="comment">//获取Method</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">loginMethod</span> <span class="operator">=</span> userServiceClass.getDeclaredMethod( <span class="string">&quot;login&quot;</span>,String.class,String.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Method loginMethod = userServiceCLass.getDecLaredMethod( &quot;Login&quot;, int.cLass);</span></span><br><span class="line">        <span class="comment">//调用方法</span></span><br><span class="line">        <span class="comment">//调用方法有几个要素?也需要4要素。</span></span><br><span class="line">        <span class="comment">//反射机制中最最最最最重要的一个方法，必须记住。</span></span><br><span class="line">        <span class="comment">//四要素:</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        loginMethod方法</span></span><br><span class="line"><span class="comment">        obj对象</span></span><br><span class="line"><span class="comment">        &quot;admin &quot; , &quot;123”实参</span></span><br><span class="line"><span class="comment">        retValue返回值</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">object</span> <span class="variable">retValue</span> <span class="operator">=</span> loginMethod.invoke(obj,...args: <span class="string">&quot;admin &quot;</span> , <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        System.out.println(retValue);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="反射Constructor"><a href="#反射Constructor" class="headerlink" title="反射Constructor"></a>反射Constructor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Vip</span> &#123;</span><br><span class="line"><span class="type">int</span> no;</span><br><span class="line">    String name;</span><br><span class="line">    String birth;</span><br><span class="line">    <span class="type">boolean</span> sex;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Vip</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Vip</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Vip</span><span class="params">(<span class="type">int</span> no，string name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Vip</span><span class="params">(<span class="type">int</span> no, String name, string birth)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.birth = birth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Vip</span><span class="params">(<span class="type">int</span> no，string name，String birth，<span class="type">boolean</span> sex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.birth = birth;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest11</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">Class</span> <span class="variable">vipClass</span> <span class="operator">=</span> class.forName( <span class="string">&quot;com.bjpowernode.java.bean.Vip&quot;</span> );</span><br><span class="line">    s.append(Modifier.toString(vipClass.getModifiers()));</span><br><span class="line">    s.append( <span class="string">&quot; class &quot;</span>);</span><br><span class="line">    s.append(vipclass.getSimpleName());</span><br><span class="line">    s.append( <span class="string">&quot;&#123;\n&quot;</span>);</span><br><span class="line">    <span class="comment">//拼接构造方法</span></span><br><span class="line">    Constructor[] constructors = vipClass.getDeclaredConstructors();</span><br><span class="line">    <span class="keyword">for</span>(Constructor constructor : constructors)&#123;</span><br><span class="line">    <span class="comment">// public vip(int no，String name，string birth， boolean sex) &#123;</span></span><br><span class="line">        s.append(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        s.append(Modifier.tostring( constructor.getModifiers()));</span><br><span class="line">        s.append(<span class="string">&quot; “);</span></span><br><span class="line"><span class="string">        s.append(vipClass.getsimpleName( ));</span></span><br><span class="line"><span class="string">        s.append( &quot;</span>(<span class="string">&quot;);</span></span><br><span class="line"><span class="string">//拼接参数</span></span><br><span class="line"><span class="string">class[] parameterTypes = constructor.getParameterTypes();</span></span><br><span class="line"><span class="string">for(Class parameterType : parameterTypes)&#123;</span></span><br><span class="line"><span class="string">        s.append( parameterType.getsimpleName());</span></span><br><span class="line"><span class="string">            s.append(&quot;</span> , <span class="string">&quot;);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        //删除最后下标位置上的字符</span></span><br><span class="line"><span class="string">        if(parameterTypes.length &gt; 0) &#123;</span></span><br><span class="line"><span class="string">s.deleteCharAt(s.length() - 1);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        s.append(&quot;</span>)&#123;&#125;\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">s.append(&quot;</span>&#125;<span class="string">&quot;);</span></span><br><span class="line"><span class="string">    System.out.println(s );</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="反射机制调用构造方法"><a href="#反射机制调用构造方法" class="headerlink" title="反射机制调用构造方法"></a>反射机制调用构造方法</h2><p>一般重要</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest12</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[ ] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"><span class="comment">//不使用反射机制怎么创建对象</span></span><br><span class="line"><span class="type">vip</span> <span class="variable">v1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vip</span>();</span><br><span class="line">        <span class="type">vip</span> <span class="variable">v2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vip</span>( <span class="number">110</span>，<span class="string">&quot;zhangsan&quot;</span>，<span class="string">&quot;2001-10-11&quot;</span>， <span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//使用反射机制怎么创建对象呢?</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> class.forName( <span class="string">&quot;com.bjpowernode.java.bean.Vip&quot;</span>); </span><br><span class="line">        <span class="comment">//调用无参数构造方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> c.newInstance();</span><br><span class="line">        <span class="comment">//调用有参数的构造方法怎么办?</span></span><br><span class="line">        <span class="comment">//第一步:先获取到这个有参数的构造方法</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">con</span> <span class="operator">=</span> c.getDeclaredConstructor(<span class="type">int</span>. class，String.class，String.class,<span class="type">boolean</span>.class);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第二步:调用构造方法new对象</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">object</span> <span class="variable">new0bj</span> <span class="operator">=</span> con.newInstance(<span class="number">110</span>，<span class="string">&quot;jackson&quot;</span>，<span class="string">&quot;1990-10-11&quot;</span>， <span class="literal">true</span>);</span><br><span class="line">        System.out. println(newObj);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取无参数构造方法</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">con2</span> <span class="operator">=</span> c.getDeclaredConstructor();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">newObj2</span> <span class="operator">=</span> con2.newInstance( );</span><br><span class="line">        System.out.println( newObj2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="反射获取父类和接口"><a href="#反射获取父类和接口" class="headerlink" title="反射获取父类和接口"></a>反射获取父类和接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">重点:给你一 类，怎么获取这个类的父类，已经实现了哪些接口?</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> c1ass ReflectTest13 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args )</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//String举例</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">stringClass</span> <span class="operator">=</span> class.forName( <span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line">        <span class="comment">//获取String的父类</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">superClass</span> <span class="operator">=</span> stringClass.getSuperclass();</span><br><span class="line">        System.out.println( superClass.getName( ));</span><br><span class="line">        <span class="comment">//获取String类实现的所有接口(一个类可以实现多个接口。)</span></span><br><span class="line">        Class[] interfaces = stringClass.getInterfaces( );</span><br><span class="line">        <span class="keyword">for</span>(Class in : interfaces)&#123;</span><br><span class="line">            System.out.println(in.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java基础 </tag>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>static</title>
      <link href="/2022/10/08/static/"/>
      <url>/2022/10/08/static/</url>
      
        <content type="html"><![CDATA[<h2 id="Static"><a href="#Static" class="headerlink" title="Static"></a>Static</h2><p>1、static翻译为”静态“</p><p>2、所有static修饰的都是类相关的，类级别的。</p><p>3、所有static修饰的，都是采用”类名.“的方式访问</p><p>4、static修饰的变量：静态变量</p><p>5、static修饰的方法：静态方法</p><p>变量的分类：</p><p>变量根据声明的位置进行划分：</p><p>​在方法体当中声明的变量叫做：局部变量。</p><p>​在方法体外声明的变量叫做：成员变量。</p><p>成员变量又可以分为：</p><p>​静态变量</p><p>​实例变量</p><h2 id="static代码块"><a href="#static代码块" class="headerlink" title="static代码块"></a>static代码块</h2><p>1、静态代码块在类加载是执行，并且在main方法之前执行，并且只执行一次</p><p>2、静态代码块有什么作用</p><p>第一：静态代码块不是那么常用</p><p>第二：静态代码块这种语法机制实际上是sun公司给我们java程序员的一个特殊时刻&#x2F;时机，这个时机叫做类加载时机</p><p>具体业务：</p><p>​项目经理说了：大家注意了，所有我们编写的程序中，只要是类加载了，请记录一下</p><p>类加载的日志信息（在几时几分几秒，那个类加载到<strong>JVM</strong>中）</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h4 id="静态变量在什么时候初始化？"><a href="#静态变量在什么时候初始化？" class="headerlink" title="静态变量在什么时候初始化？"></a>静态变量在什么时候初始化？</h4><p>类加载时初始化</p><h4 id="静态变量存储在哪里？"><a href="#静态变量存储在哪里？" class="headerlink" title="静态变量存储在哪里？"></a><strong>静态变量存储在哪里？</strong></h4><p>方法区</p><h4 id="静态代码块在什么时候执行？"><a href="#静态代码块在什么时候执行？" class="headerlink" title="静态代码块在什么时候执行？"></a>静态代码块在什么时候执行？</h4><p>类加载时执行</p>]]></content>
      
      
      
        <tags>
            
            <tag> 静态代码块 </tag>
            
            <tag> static </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程(一)</title>
      <link href="/2022/10/08/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%80/"/>
      <url>/2022/10/08/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是线程，什么是进程"><a href="#1-什么是线程，什么是进程" class="headerlink" title="1.什么是线程，什么是进程?"></a>1.什么是线程，什么是进程?</h2><p>进程是一个应用程序（<strong>一个进程是一个软件</strong>）</p><p>线程是一个进程中的执行场景&#x2F;执行单元</p><p>一个进程可以启动多个线程</p><p><strong>JVM是一个进程</strong></p><h2 id="2-对于JAVA来说，当在DOS命令窗口中输入：java-HellowWorld-回车之后"><a href="#2-对于JAVA来说，当在DOS命令窗口中输入：java-HellowWorld-回车之后" class="headerlink" title="2.对于JAVA来说，当在DOS命令窗口中输入：java HellowWorld 回车之后"></a>2.对于JAVA来说，当在DOS命令窗口中输入：java HellowWorld 回车之后</h2><p><strong>会先启动JVM，JVM就是一个进程。</strong></p><p>JVM再启动一主线程调用main()方法</p><p>同时再启动一个垃圾回收线程负责看护，回收垃圾。</p><p>最起码，现在Java程序当中至少有两个线程并发</p><p>一个是垃圾回收线程，一个是执行main()方法的主线程</p><h2 id="3-线程共享？"><a href="#3-线程共享？" class="headerlink" title="3.线程共享？"></a>3.线程共享？</h2><p>进程A和进程B独立不共享</p><p>线程A和线程B呢？</p><p>在java语言中</p><p>线程A和线程B，<strong>堆内存和方法区内存共享，</strong></p><p><strong>堆内存只有一块！！！</strong></p><p><strong>方法区只有一块！！！</strong></p><p><strong>堆内存和方法区只有一块！！！！</strong></p><p><strong>但是栈内存独立，一个线程一个栈</strong></p><p>假设启动10个线程，会有10个栈空间，每个栈和每个栈之间互不干扰，<strong>各自执行各的，这就是多线程并发</strong></p><p><strong>java中之所以有多线程，目的就是为了提高程序的处理效率</strong></p><h2 id="4-思考一个问题"><a href="#4-思考一个问题" class="headerlink" title="4.思考一个问题"></a>4.思考一个问题</h2><p>使用多线程机制之后，main方法结束，是不是有可能程序也不会结束。</p><p>main方法结束只是主线程结束了，<strong>主栈空了，其他的栈可能还在压栈弹栈</strong></p><h2 id="5-分析一个问题"><a href="#5-分析一个问题" class="headerlink" title="5.分析一个问题"></a>5.分析一个问题</h2><p>对于单核的CPU来说，真的可以做到真正的多线程并发吗？</p><p>什么是真正的多线程并发</p><p>t1执行t1</p><p>t2执行t2</p><p>t1不会影响t2，t2不会影响t1，这叫真正的多线程并发</p><p>对于多核CPU来说，真正的多线程并发是没有问题的</p><p>4核CPU表示同一个时间点上，可以真正的有4个进程并发执行</p><p>单核CPU表示只有一个大脑：</p><p>不能够做到真正的多线程并发，但是可以做到给人一种多线程并发的感觉。</p><p>电影院采用胶卷播放电影，一个胶卷一个胶卷播放速度达到一定程度之后，人类的眼睛产生了错觉，感觉是动画的。这说明人类的反应速度很慢，就像一根钢针扎到手上，到最终感觉到疼，这个过程是需要”很长的”时间的，在这个期间计算机可以进行亿万次的循环。所以计算机的执行速度很快。</p><h2 id="6-实现线程第一种"><a href="#6-实现线程第一种" class="headerlink" title="6.实现线程第一种"></a>6.实现线程第一种</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class MyThread extends Thread() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">    //这段代码运行在分支线程</span><br><span class="line">System.out.println(&quot;分支线程&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//程序永远自上而下</span><br><span class="line">public class ThreadTest02() &#123;</span><br><span class="line">    MyThread myThread = new MyThread();</span><br><span class="line">    myThread.start();</span><br><span class="line">    myThread.run();//不会启动线程，不会分配新的分支栈</span><br><span class="line">    //这段代码运行在主线程</span><br><span class="line">    System.out.println(&quot;主线程&quot;)</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>继承Thread</p><h2 id="7-start方法"><a href="#7-start方法" class="headerlink" title="7.start方法"></a>7.start方法</h2><p>start方法的作用是启动一个分支线程，在JVM中开辟一个新的栈空间，这段代码瞬间就结束了</p><p>这段代码的任务只是开启一个新的栈空间，只要新的栈空间开出来，start（）方法就结束了，线程就启动成功了</p><p><strong>启动成功的线程会自动调用run（）方法，并且run方法在分支栈的栈底部（压栈）</strong></p><p>run方法在分支栈的栈底部，main方法在主栈的底部，run和main是平级的</p><h2 id="8-实现线程第二种"><a href="#8-实现线程第二种" class="headerlink" title="8.实现线程第二种"></a>8.实现线程第二种</h2><p>继承Runnable接口</p><p>比较常用，因为：<strong>一个类实现了接口，它还可以区继承其他的类，更灵活</strong></p><h2 id="9-关于线程对象的生命周期"><a href="#9-关于线程对象的生命周期" class="headerlink" title="9.关于线程对象的生命周期"></a>9.关于线程对象的生命周期</h2><p><img src="/2022/10/08/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%80/1.png" alt="image-20221003165006794"></p><h2 id="10-获取线程名字"><a href="#10-获取线程名字" class="headerlink" title="10.获取线程名字"></a>10.获取线程名字</h2><p>thread.getName()    &#x2F;&#x2F;默认名字为thread-0，1，2，3…n</p><h2 id="11-修改线程名字"><a href="#11-修改线程名字" class="headerlink" title="11.修改线程名字"></a>11.修改线程名字</h2><p>thread.setName()</p><h2 id="12-获取当前线程对象"><a href="#12-获取当前线程对象" class="headerlink" title="12.获取当前线程对象"></a>12.获取当前线程对象</h2><p>Thread.currentThread()为静态方法</p><p>出现在run方法，谁执行run方法，当前线程就是谁</p><p>出现在main方法，当前线程就是main</p><h2 id="13-线程的sleep方法"><a href="#13-线程的sleep方法" class="headerlink" title="13.线程的sleep方法"></a>13.线程的sleep方法</h2><p>static void sleep(Long millis)</p><p>静态方法</p><p>参数是毫秒</p><p>作用:让当前线程进入休眠，进入“阻塞状态”，放弃占有CPU时间片，让给其它线程使用。</p><p>这行代码出现在A线程中，A线程就会进入休眠。</p><p>这行代码出现在B线程中，B线程就会进入休眠。</p><h2 id="14-子类不能抛出比父类更多的异常"><a href="#14-子类不能抛出比父类更多的异常" class="headerlink" title="14.子类不能抛出比父类更多的异常"></a>14.子类不能抛出比父类更多的异常</h2><p>&#x2F;&#x2F;重点: run()当中的异常不能throws ，只能try catch</p><p>&#x2F;&#x2F;因为run()方法在父类中没有抛出任何异常，子类不能比父类抛出更多的异常。</p><h2 id="15-终止线程的睡眠"><a href="#15-终止线程的睡眠" class="headerlink" title="15.终止线程的睡眠"></a>15.终止线程的睡眠</h2><p>&#x2F;&#x2F;终断t线程的睡眠（这种终断睡眠的方式伙靠了java的异常处理机制。)</p><p>thread.interrupt();</p><h2 id="16-强行终止线程的执行"><a href="#16-强行终止线程的执行" class="headerlink" title="16.强行终止线程的执行"></a>16.强行终止线程的执行</h2><p>thread.stop()    &#x2F;&#x2F;已过时，不建议使用</p><p>存在很大的缺点，容易丢失数据，<strong>因为是直接杀死线程</strong>，线程的没保存的数据会丢失</p><h2 id="17-合理终止一个线程的执行"><a href="#17-合理终止一个线程的执行" class="headerlink" title="17.合理终止一个线程的执行"></a>17.合理终止一个线程的执行</h2><p>判断，打标记，thread.run()</p><h2 id="18-关于线程的调度"><a href="#18-关于线程的调度" class="headerlink" title="18.关于线程的调度"></a>18.关于线程的调度</h2><p>常见的线程调度模型有哪些？</p><p>抢占式调度模型：</p><p>哪个线程的优先级比较高，抢到CPU时间片的概率就高一些&#x2F;多一些</p><p>java采用的就是抢占式调度模型</p><p>均分式调度模型</p><p>平均分配CPU时间片，每个线程占有的CPU时间片时间长度一样</p><p>平均分配，以且平等</p><p>有一些编程语言，线程调度模型采用的就是这种方式</p><h2 id="18-java中有哪些方法是和线程优先级有关的呢？"><a href="#18-java中有哪些方法是和线程优先级有关的呢？" class="headerlink" title="18.java中有哪些方法是和线程优先级有关的呢？"></a>18.java中有哪些方法是和线程优先级有关的呢？</h2><p>实例方法</p><p>void setPriority (int newPriority)设置线程的优先级</p><p>int getPriority ()获取线程优先级</p><p>最低优先级1</p><p>默认优先级是5最高优先级10</p><p>优先级比较高的获取cPu时间片可能会多一些。(但也不完全是，大概率是多的。)</p><h2 id="19-线程让位"><a href="#19-线程让位" class="headerlink" title="19.线程让位"></a>19.线程让位</h2><p>static void yield()让位方法</p><p>暂停当前正在执行的线程对象，并执行其他线程</p><p>yield()方法不是阻塞方法。让当前线程让位，让给其它线程使用。yield()方法的执行会让当前线程从”运行状态”回到“就绪状态”。注意:在回到就绪之后，有可能还会再次抢到。</p><h2 id="20-线程安全"><a href="#20-线程安全" class="headerlink" title="20.***线程安全"></a>20.***线程安全</h2><p>多线程并发环境下，数据安全问题</p><h4 id="为什么是重点？"><a href="#为什么是重点？" class="headerlink" title="为什么是重点？"></a>为什么是重点？</h4><p>以后在开发中，我们的项目都是运行在服务器当中，而服务器已经将线程的定义，线程对象的创建，线程的启动等，都已经实现完了。这些代码我们都不需要编马。</p><p>最重要的是:你要知道，你编写的程序需要放到一个多线程的环境下运行，你更需要关注的是这些数据</p><p>在多线程并发的环境下是否是安全的。(重点:*****)</p><h4 id="什么时候数据在多线程并发的环境下会存在安全问题呢"><a href="#什么时候数据在多线程并发的环境下会存在安全问题呢" class="headerlink" title="什么时候数据在多线程并发的环境下会存在安全问题呢?"></a>什么时候数据在多线程并发的环境下会存在安全问题呢?</h4><p><strong>三个条件:</strong><br><strong>条件1:多线程并发。</strong></p><p><strong>条件2:有共享数据。</strong><br><strong>条件3:共享薮据有修改的行为。</strong><br><strong>满足以上3个条件之后，就会存在线程安全问题。</strong></p><h4 id="怎么解决线程安全问题呢"><a href="#怎么解决线程安全问题呢" class="headerlink" title="怎么解决线程安全问题呢?"></a>怎么解决线程安全问题呢?</h4><p>当多线程并发的环境下，有共享数据，并且这个数据还会被修改，此时就存在线程安全问题,怎么解决这个问题?<br>线程排队执行。(不能并发).用排队执行解决线程安全问题。这种机制被称为:线程同步机制。<br>专业术语叫做:线程同步，实际上就是线程不能并发了，线程必须排队执行。<br>怎么解决线程安全问题呀?<br>使用”线程同步机制”。<br>线程同步就是线程排队了，线程排队了就会牺牲一部分效率，没办法，数据安全第一位，只有数据安全了，我们才可以谈效率。数据不安全，没有效率的事儿。</p><h4 id="说到线程同步这块，涉及到这两个专业术语"><a href="#说到线程同步这块，涉及到这两个专业术语" class="headerlink" title="说到线程同步这块，涉及到这两个专业术语:"></a>说到线程同步这块，涉及到这两个专业术语:</h4><p>异步编程模型:<br>线程t1和线程t2，各自执行各自的，t1不管t2，t2不管t1，谁也不需要等谁,这种编程模型叫做:异步编程模型。其实就是:多线程并发(效率较高。)<br><strong>异步就是并发。</strong><br>同步编程模型:<br>线程t1和线程t2，在线程t1执行的时候，必须等待t2线程执行结束,或者说在t2线程执行的时候，必须等待t1线程执行结束，两个线程之间发生了等待关系，这就是同步编程模型。<br>效率较低。线程排队执行。<br><strong>同步就是排队。</strong></p><h2 id="21-synchronization"><a href="#21-synchronization" class="headerlink" title="21.synchronization"></a>21.synchronization</h2><p><strong>synchronization()</strong></p><p>()中写什么?<br>那要看你想让哪些线程同步。<br>假设t1、t2、t3、t4、t5，有5个线程，<br>你只希望t1 t2 t3排队，t4 t5不需要排队。怎么办?你一定要在()中写一个t1 t2 t3共享的对象。而这个对象对于t4 t5来说不是共享的。<br>这里的共享对象是:账户对象。<br>账户对象是共享的，那么this就是账户对象吧!!!不一定是this ，<strong>这里只要是多线程共享的那个对象就行。</strong></p><p><strong>在java语言中，任何一个对象都有一把锁”，其实这把锁就是标记。(只是把它叫做锁。)100个对象，100把锁。1个对象1把锁。</strong><br>以下代码的执行原理?<br>1、假设t1和t2线程并发，开始执行以下代码的时候，肯定有一个先一个后。<br>2、假设t1先执行了，遇到了synchronized，这个时候自动找后面共享对象”的对象锁，找到之后，并占有这把锁，然后执行同步代码块中的程序，在程序执行过程中一亘都是占有这把锁的。疸到同步代码块代码结束，这把锁才会释放。<br>3、假设t1已经占有这把锁，此时t2也遇到synchronized关键字，也会去占有后面共享对象的这把锁，结果这把锁被t1占有，t2只能在同步代码块外面等待t1的结束，亘到t1把同步代码块执行结束了，t1会归还这把锁，此时t2终于等到这把锁，然后t2占有这把锁之后，进入同步代码块执行程序。<br>这样就达到了线程排队执行。<br>这里需要注意的是:这个共享对象一定要选好了。这个共享对象一定是你需要排队执行的这些线程对象所共享的。</p><p>实例变量。( Account对象是多线程共享的，Account对象中的实例变量obj也是共享的）</p><h2 id="22-Java中有三大变量"><a href="#22-Java中有三大变量" class="headerlink" title="22.***Java中有三大变量?"></a>22.***Java中有三大变量?</h2><p>实例变量:在堆中。<br>静态变量:在方法区。<br>局部变量:在栈中。<br>以上三大变量中:<br>局部都变量永远都不会存在线程安全问题。<br>因为局部变量不共享。(一个线程一个栈。)<br>局部变量在栈中。所以局部变量永远都不会共享。实例变量在堆中，维只有1个.<br>静态变量在方法区中,方法区只有1个。<br>堆和方法区都是多线程共享的，所以可能存在线程安全问题。</p><p>在实例方法上可以使用synchronized吗?可以的。<br>synchronized出现在实例方法上，一定锁的是this。没得挑。只能是this。不能是其他的对象了。<br>所以这种方式不灵活。<br>另外还有一个缺点: synchronized出现在实例方法上，表示整个方法体都需要同步，可能会无故扩大同步的范围，导致程序的执行效率降低。所以这种方式不常用。</p><p>synchronized使用在实例方法上有什么优点?<br>代码写的少了。节俭了。<br>如果共享的对象就是this ，并且需要同步的代码块是整个方法体，建议使用这种方式。</p><p>如果使用局部变量的话:建议使用:stringBuilder.<br>因为局部变量不存在线程安全问题。选择stringBuilder.stringBuffer效率比较低.<br>ArrayList是非线程安全的。veator是线程安全的。<br>HashMap Hashset是非线程安全的。Hashtable是线程安全的。</p><h2 id="23-synchronized有三种写法"><a href="#23-synchronized有三种写法" class="headerlink" title="23.synchronized有三种写法:"></a>23.synchronized有三种写法:</h2><p>第一种:同步代码块<br>灵活<br>synchronized(线程共享对象){<br>同步代码块;<br>}<br>第二种:在实例方法上使用synchronized<br>表示共享对象一定是this<br>并且同步代码块是整个方法体。<br>第三种:在静态方法上使用synchronized<br>表示找类锁。<br>类锁永远只有1把。<br>就算创建了100个对象，那类锁也只有一把。<br>对象锁:1个对象1把锁，100个对象100把锁-类锁:10o个对象,也可能只是1把类锁、</p><h2 id="面试题1"><a href="#面试题1" class="headerlink" title="面试题1"></a>面试题1</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">dosome</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println( <span class="string">&quot;doSome begin&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sLeep( millis: <span class="number">1080</span> * <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    System.out.println( <span class="string">&quot;doSome over&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    pubiic <span class="keyword">void</span> <span class="title function_">doother</span><span class="params">()</span>&#123;<span class="comment">//没有synchronized</span></span><br><span class="line">        System.out.println( <span class="string">&quot;doOther begin&quot;</span> );</span><br><span class="line">        System.out.println(<span class="string">&quot;doOther over&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>虽然一个对象只有一把锁，但只有被synchronization修饰需要这把锁</strong></p><h2 id="24-死锁"><a href="#24-死锁" class="headerlink" title="24.死锁"></a>24.死锁</h2><p>不用我多说吧</p><h2 id="25-聊一聊，我们以后开发中应该怎么解决线程安全问题"><a href="#25-聊一聊，我们以后开发中应该怎么解决线程安全问题" class="headerlink" title="25.聊一聊，我们以后开发中应该怎么解决线程安全问题?"></a>25.聊一聊，我们以后开发中应该怎么解决线程安全问题?</h2><p>是一上来就选择线程同步吗?synchronized<br>不是，synchronized会让程序的执行效率降低，用户体验不好。系统的用户吞吐量降低。用户体验差。在不得已的情况下再选择线程同步机制。<br>第一种方案:尽量使用局部变量代替”实例变量和静态变量”。<br>第二种方案:如果必须是实例变量，那么可以考虑创建多个对象，这样<br>实例变量的内存就不共享了。(一个线程对应1个对象，100个线程对应100个对象，对象不共享,就没有数据安全问题了。）<br>第三种方案:如果不能使用局部变量，对象也不能创建多个，这个时候就只能选择synchronized了。线程同步机制。</p><h2 id="26-线程这块还有那些内容呢-列举一下"><a href="#26-线程这块还有那些内容呢-列举一下" class="headerlink" title="26.线程这块还有那些内容呢?列举一下"></a>26.线程这块还有那些内容呢?列举一下</h2><ul><li>守护线程</li><li>定时器</li><li>实现线程的第三种方式: FutureTask方式，实现callable接口。(JDK8新特性。)</li><li>关于object类中的wait和notify方法。(生产者和消费者模式! )</li></ul><h2 id="27-守护线程"><a href="#27-守护线程" class="headerlink" title="27.守护线程"></a>27.守护线程</h2><p>java语言中线程分为两大类:<br>一类是:用户线程<br>一类是:守护线程(后台线程)<br>其中具有代表性的就是:垃圾回收线程(守护线程）-守护线程的特点:<br>一般守护线程是一个<strong>死循环</strong>，<strong>所有的用户线程只要结束，守护线程自动结束。</strong><br>注意:主线程main方法是一个用户线程。守护线程用在什么地方呢?<br>每天00:00的时候系统数据自动备份。<br>这个需要使用到定时器，并且我们可以将定时器设置为守护线程。一直在那里看着，没到00:00的时候就备份一次。所有的用户线程如果结束了，守护线程自动退出，没有必要进行数据备份了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest14</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BakDataThread</span>( );</span><br><span class="line">t.setName(<span class="string">&quot;备份数据的线程&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动线程之前，将线程设置为守护线程</span></span><br><span class="line">    t.setDaemon(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    t.start();</span><br><span class="line"><span class="comment">//主线程∶主线程是用户线程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        system.out.println(Thread.currentThread( ).getName( ) + <span class="string">&quot;---&gt;&quot;</span> + i);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>) ;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace( );</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BakDataThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//即使是死循环，但由于该线程是守护者，当用户线程结束，守护线程自动终止。|while(true)&#123;</span></span><br><span class="line">        system.out.println( Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + (++i))</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printstackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置守护线程方法</p><p><strong>thread.setDaemon()</strong></p><h2 id="28-定时器"><a href="#28-定时器" class="headerlink" title="28.定时器"></a>28.定时器</h2><p>定时器的作用:<br><strong>间隔特定的时间,执行特定的程序-</strong><br>每周要进行银行账户的总账操作。每天要进行数据的备份操作。<br>在实际的开发中，每隔多久执行一段特定的程序，这种需求是很常见的，那么在java中其实可以采用多种方式实现:<br>可以使用sleep方法，睡眠，设置睡眠时间，没到这个时间点醒来，执行任务。这种方式是最原始的定时器。(比较low)<br>在java的类库中已经写好了一个定时器: java.util.Timer，可以直接拿来用。不过，这种方式在目前的开发中也很少用，因为现在有很多高级框架都是支持定时任务的。<br>在实际的开发中，目前使用较多的是spring框架中提供的springTask框架这个框架只要进行简单的配置，就可以完成定时器的任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">timerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建定时器对象</span></span><br><span class="line">        <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">        <span class="comment">//Timer timer = new Timer(true); //守护线程的方式</span></span><br><span class="line">        <span class="comment">//指定定时任务</span></span><br><span class="line">        <span class="comment">//timer.schedule(定时任务，第一次执行时间，间隔多久执行一次);</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span> );</span><br><span class="line">        <span class="type">Date</span> <span class="variable">firstTime</span> <span class="operator">=</span> sdf.parse(<span class="string">&quot;202e-03-14 09:3e:ee&quot;</span>);</span><br><span class="line">        timer.schedule(<span class="keyword">new</span> <span class="title class_">LogTimerTask</span>() , firstTime，period: <span class="number">1000</span> *<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//编写一个定时任务类</span></span><br><span class="line"><span class="comment">//假设这是一个记录日志的定时任务</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogTimerTask</span> <span class="keyword">extends</span> <span class="title class_">TimerTask</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//编写你需要执行的任务就行了。</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">strTime</span> <span class="operator">=</span> sdf.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        system.out.println(strTime + <span class="string">&quot;:成功完成了一次数据备份!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用匿名内部类</p><h2 id="29-线程第三种实现方式（JDK8新特性）"><a href="#29-线程第三种实现方式（JDK8新特性）" class="headerlink" title="29.线程第三种实现方式（JDK8新特性）"></a>29.线程第三种实现方式（JDK8新特性）</h2><p>这种方式实现的线程可町以获取线程的返回值-<br>之前讲解的那两种方式是无法获取线程返回值的，<strong>因为run方法返回void.</strong><br>思考:<br>系统委派一个线程去执行一个任务，该线程执行完任务之后，可能会有一个执行结果，我们怎么能拿到这个执行结果呢?<br>使用第三种方式:实现callable接口方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest15</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[ ] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//第一步:创建一个未来任务类”对象。</span></span><br><span class="line">        <span class="comment">//参数非常重要，需要给一个CalLable接口实现类对象。</span></span><br><span class="line">        <span class="type">FutureTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(<span class="keyword">new</span> <span class="title class_">Callable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> 0bject <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123; <span class="comment">// call()方法就相当于run方法。只不过这个有返回值</span></span><br><span class="line">                <span class="comment">//线程执行一个任务，执行之后可能会有一个执行结果</span></span><br><span class="line">                <span class="comment">//模拟执行</span></span><br><span class="line">                System.out.println(<span class="string">&quot;ca11 method begin&quot;</span> );</span><br><span class="line">                Thread.sleep( <span class="number">1008</span>* <span class="number">10</span>) ;</span><br><span class="line">                System.out.println(<span class="string">&quot;call method end! &quot;</span> );</span><br><span class="line">                <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">                <span class="keyword">return</span> a+b;  <span class="comment">//自动装箱，300结果变成Integer</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">                </span><br><span class="line"><span class="comment">//创建线程对象</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">    <span class="comment">//启动线程</span></span><br><span class="line">    t.start( );</span><br><span class="line">    <span class="comment">//这里是main方法，这是在主线程中。</span></span><br><span class="line">    <span class="comment">//在主线程中，怎么获取t线程的返回结果?</span></span><br><span class="line"><span class="comment">//get()方法的执行会导致““当前线程阻塞”</span></span><br><span class="line"><span class="type">object</span> <span class="variable">obj</span> <span class="operator">=</span> task.get();</span><br><span class="line">    system.out.print1n(<span class="string">&quot;线程执行结果:&quot;</span> +obj);</span><br><span class="line">    <span class="comment">//main方法这里的程序要想执行必须等待get()方法的结束</span></span><br><span class="line">    <span class="comment">//而get()方法可能需要很久。因为get()方法是为了拿另一个线程的执行结果</span></span><br><span class="line"><span class="comment">//另一个线程执行是需要时间的。</span></span><br><span class="line">    System.out.print1n( <span class="string">&quot;hello wor1d! &quot;</span>);</span><br><span class="line">&#125;                                                                          </span><br></pre></td></tr></table></figure><ul><li>main方法这里的程序要想执行必须等待get()方法的结束</li><li>而get()方法可能需要很久。因为get()方法是为了拿另一个线程的执行结果</li><li>另一个线程执行是需要时间的。</li></ul><p>——    可以获取到线程的返回结果</p><p>——效率比较低，在获取t线程执行结果的时候，当前线程受阻塞，效率较低</p><h2 id="30-关于Object类中的wait和notify方法"><a href="#30-关于Object类中的wait和notify方法" class="headerlink" title="30.关于Object类中的wait和notify方法"></a>30.关于Object类中的wait和notify方法</h2><p>第一: <strong>wait和notify方法不是线程对象的方法，是java中任何一个java对象都有的方法，因为这两个方式是object类中自带的。</strong><br><strong>wait方法和notify方法不是通过线程对象调用，</strong>不是这样的: t.wait()，也不是这样的: t.notify()..不对。</p><p>第二: wait()方法作用?<br>object o &#x3D; new Object() ;</p><p>o. wait() ;<br>表示:<br>让正在o对象上活动的线程进入等待状态，无期限等待，直到被唤醒为止.<br>o.wait();方法的调用，会让”当前线程（正在o对象上活动的线程)”进入等待状态,l</p><p>第三: notify()方法作用?</p><p>object o &#x3D; new Object () ;</p><p>o.notify () ;<br>表示:<br>唤醒正在o对象上等待的线程。还有一个notifyAl1()方法:</p><p><strong>这个方法是唤醒o对象上处于等待的所有线程。</strong></p><img src="/2022/10/08/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%80/3.png" alt="image-20221004140839660" style="zoom:67%;"><img src="/2022/10/08/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%80/2.png" alt="image-20221004104504639" style="zoom:67%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、使用wait方法和notify方法实现(生产者和消费者模式”)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2、什么是“&quot;生产者和消费者模式”?</span></span><br><span class="line"><span class="comment">生产线程负责生产，消费线程负责消费。生产线程和消费线程要达到均衡。</span></span><br><span class="line"><span class="comment">这是一种特殊的业务需求，在这种特殊的情况下需要使用vait方法和notify方法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3、wait和notify方法不是线程对象的方法，是普通java对象都有的方法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4、wait方法和notify方法建立在线程同步的基础之上。因为多线程要同时操作一个仓库。有线程安全问题。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">5、wait方法作用: o.wait()让正在o对象上活动的线程t进入等待状态，并且释放掉t线程之前占有的o对象的锁。·</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">6、notify方法作用: o.notify()让正在o对象上等待的线程唤醒，只是通知，不会释放o对象上之前占有的锁。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">7、模拟这样一个需求:</span></span><br><span class="line"><span class="comment">仓库我们采用List集合。</span></span><br><span class="line"><span class="comment">List集合中假设只能存储1个元素。1个元素就表示仓库满了。</span></span><br><span class="line"><span class="comment">如果List集合中元素个数是e，就表示仓库空了。保证List集合中永远都是最多存储1个元素。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">必须做到这种效果:生产1个消费1个。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest16</span> &#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( string[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个仓库对象，共享的</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="comment">//创建两个线程</span></span><br><span class="line">        <span class="comment">//生产者线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Product</span>(list));</span><br><span class="line">        <span class="comment">//消费者线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer</span>(list));</span><br><span class="line">        </span><br><span class="line">        t1.setName(<span class="string">&quot;生产者线程&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;消费者线程&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产线程</span></span><br><span class="line">c1ass Producer imp1ements Runnable &#123;</span><br><span class="line">    <span class="comment">//仓库</span></span><br><span class="line">    <span class="keyword">private</span> List list; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Product</span><span class="params">(List list)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list = list;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">( )</span> &#123;</span><br><span class="line">        <span class="comment">//一直生产（使用死循环来模拟一直生产）</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//给仓库对象List加锁。</span></span><br><span class="line">            <span class="keyword">synchronized</span> (list)&#123;</span><br><span class="line">                <span class="keyword">if</span>(1ist.size() &gt; <span class="number">0</span>)&#123;<span class="comment">//大于0，说明仓库中已经有1个元素了。</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//当前线程进入等待状态，并且释放Producer之前占有的List集合的锁。</span></span><br><span class="line">                        list.wait();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//程序能够执行到这里说明仓库是空的，可以生产object obj = new Object();</span></span><br><span class="line">                list.add(obj);</span><br><span class="line">                System.out.println(Thread.currentThread( ) .getName() + <span class="string">&quot;---&gt;&quot;</span> + obj);</span><br><span class="line">                <span class="comment">//唤醒消费者进行消费</span></span><br><span class="line">                list.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> imp1ements Runnable &#123;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//仓库</span></span><br><span class="line">    <span class="keyword">private</span> List list; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(List list)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list = list;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">( )</span> &#123;</span><br><span class="line">    <span class="comment">//一直消费</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>( list.size() == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//仓库已经空了。</span></span><br><span class="line">                <span class="comment">//消费者线程等待，释放掉list集合的锁</span></span><br><span class="line">                    list.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedExceptioh e) &#123;</span><br><span class="line">                    e.printstackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//程序能够执行到此处说明仓库中有数据，进行消费。</span></span><br><span class="line">            <span class="type">object</span> <span class="variable">obj</span> <span class="operator">=</span> list.remove(<span class="number">0</span>);</span><br><span class="line">            System.out.println(Thread.currentThread( ).getName() + <span class="string">&quot;---&gt;&quot;</span> + obj);</span><br><span class="line">            <span class="comment">//唤醒生产者生产。</span></span><br><span class="line">            list.notify();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 高并发 </tag>
            
            <tag> 多线程 </tag>
            
            <tag> thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM(一)</title>
      <link href="/2022/10/08/JVM-%E4%B8%80/"/>
      <url>/2022/10/08/JVM-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="1、JVM基础"><a href="#1、JVM基础" class="headerlink" title="1、JVM基础"></a>1、JVM基础</h2><p><img src="/2022/10/08/JVM-%E4%B8%80/1.png" alt="image-20220925110713917"></p><p><img src="/2022/10/08/JVM-%E4%B8%80/2.png" alt="image-20220925110752227"></p><p><img src="/2022/10/08/JVM-%E4%B8%80/3.png" alt="image-20220925110822373"></p><p>——————–JVM与java无关，只与**.class**文件有关</p><p><strong>JVM是一种规范，它定义了java虚拟机应该执行什么，java虚拟机应该具备哪些模块，遇到哪些指令应该做什么等等</strong></p><p><img src="/2022/10/08/JVM-%E4%B8%80/4.png" alt="image-20220925111215847"></p><p>我们常用的是Hotspot：</p><p><img src="/2022/10/08/JVM-%E4%B8%80/5.png" alt="image-20220925113617889"></p><p>类编译，加载，初始化</p><p>类加载过程</p><p><img src="/2022/10/08/JVM-%E4%B8%80/6.png" alt="image-20220925130824497"></p><p>注意Bootstrap是C++实现的，调用**getClassLoader()**方法会返回空，因为Jave中没有一个class和她对应，所以会返回null</p><p>双亲委派：不是语法上的继承关系，即不是继承机制</p><p>为什么需要双亲委派机制：安全问题，防止自己写的<strong>java.lang.string</strong>覆盖原生的</p><p><img src="/2022/10/08/JVM-%E4%B8%80/7.png" alt="image-20220925132327032"></p><p>每个加载器都有自己的缓存</p><p><img src="/2022/10/08/JVM-%E4%B8%80/8.png" alt="image-20220925134458883"></p><p>对于没有依赖关系的两个变量初始化，CPU可能会进行指令重排，所以需要加Volatile：</p><h2 id="1-2-ClassFileFormat"><a href="#1-2-ClassFileFormat" class="headerlink" title="1.2 ClassFileFormat"></a>1.2 ClassFileFormat</h2><p><img src="/2022/10/08/JVM-%E4%B8%80/39.png" alt="image-20221004220136856"></p><ul><li>二进制字节流</li><li>数据类型： u1，u2，u4，u8和 _info(表类型)      <strong>u1一个字节（无符号） u2俩个字节（无符号）以此类推</strong></li></ul><p>​ –_info来源是hotspot源码中的写法</p><ul><li>查看16进制的ClassFile</li></ul><p>​–sublime &#x2F; notepad &#x2F;<br>​–IDEA插件-BinEd</p><p>​–<img src="/2022/10/08/JVM-%E4%B8%80/38.png" alt="image-20221004215735612" style="zoom:67%;"></p><ul><li>有很多可以观察ByteCode的方法</li></ul><p>​–iavap<br>​–JBE -可以直接修改<br>​–JClassLib - IDEA插件之一</p><p>​–<img src="/2022/10/08/JVM-%E4%B8%80/40.png" alt="image-20221004220452674" style="zoom:50%;"></p><ul><li><p>classfile构成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4magic;</span><br><span class="line">    u2minor_version;</span><br><span class="line">    u2major_version;</span><br><span class="line">    u2constant_poo1_count;//数组16，下标从1开始，0下标留着备用</span><br><span class="line">    cp_info constant_poo1[constant_poo1_count - 1];</span><br><span class="line">u2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="1-3对象头包括什么"><a href="#1-3对象头包括什么" class="headerlink" title="1.3对象头包括什么"></a>1.3对象头包括什么</h2><p><img src="/2022/10/08/JVM-%E4%B8%80/41.png" alt="image-20221004221345407"></p><ul><li><p>mark word</p><ul><li><p>锁信息</p></li><li><p>GC</p></li><li><p>identity HasCode（没有重写的HasCode）</p></li></ul></li></ul><h2 id="1-4对象定位"><a href="#1-4对象定位" class="headerlink" title="1.4对象定位"></a>1.4对象定位</h2><img src="/2022/10/08/JVM-%E4%B8%80/42.png" alt="image-20221005091628138"><h2 id="1-5对象怎么分配"><a href="#1-5对象怎么分配" class="headerlink" title="1.5对象怎么分配"></a>1.5对象怎么分配</h2><ul><li>优先存在栈上?（判断是否逃逸：没有引用指向她？）（<strong>不用GC，随着方法结束弹出栈，效率快，快</strong>） </li><li>老年代（大对象）</li><li>线程本地缓冲区（TLAB）</li></ul><p>​–ThreadLoacl  （TL）</p><p>​–AllocationBuffer（AB）</p><ul><li>伊甸区</li></ul><p>​–<strong>线程的小小空间</strong>，<strong>每个线程自己的TLAB</strong>（3个线程抢位置，谁抢到给谁分配，算法为碰撞指针，总而言之，JVM得协调，这样会消耗资源，<strong>与其这样，不如给每个线程一块小小空间（TLAB）</strong>）</p><ul><li><p>GC</p></li><li><p><strong>幸存区1，幸存区2，循环往复，直到年龄够大</strong></p></li><li><p>老年代</p></li><li><p>FullGC</p></li></ul><h2 id="1-6一个Object占多少字节"><a href="#1-6一个Object占多少字节" class="headerlink" title="1.6一个Object占多少字节"></a>1.6一个Object占多少字节</h2><ul><li><p>Object obj &#x3D; new Object();</p><ul><li>普通的对象new出来16个字节</li></ul></li><li><p>mark word  8个字节</p><ul><li>默认压缩情况下classPointer 4个字节</li></ul></li><li><p>对齐 4个字节</p></li></ul><h2 id="1-7对象创建过程"><a href="#1-7对象创建过程" class="headerlink" title="1.7对象创建过程"></a>1.7对象创建过程</h2><ul><li>第一步默认值</li><li>第二步初始值</li><li>第三步建立关联</li></ul><p><img src="/2022/10/08/JVM-%E4%B8%80/43.png" alt="image-20221005113805878"></p><h2 id="1-8单例模式"><a href="#1-8单例模式" class="headerlink" title="1.8单例模式"></a>1.8单例模式</h2><p><strong>提示：static private final</strong></p><p>饿汉式：二话不说现直接创建对象，类似悲观锁</p><p>懒汉式：类似按需加载DLC（双检锁）加 Volatile</p><ul><li>反例破坏单例</li><li>反序列化破坏单例</li><li>Unsafe破坏单例</li></ul><p>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Mgr06 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//业务逻辑代码省略</span></span><br><span class="line">    <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123; <span class="comment">//Double Check Lock</span></span><br><span class="line">    <span class="comment">//双重检查</span></span><br><span class="line">        <span class="keyword">synchronized</span> (Mgr06.class) &#123;</span><br><span class="line">            <span class="keyword">if</span>( INSTANCE == rhll) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(  <span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace( );</span><br><span class="line">                &#125;</span><br><span class="line">                INSTANCE = <span class="keyword">new</span> <span class="title class_">Mgr06</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h4><p>compare and swap(比较并交换)自旋锁，乐观锁</p><h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><p><img src="/2022/10/08/JVM-%E4%B8%80/44.png" alt="image-20221005112639267"></p><p>版本号解决，加一个版本号</p><h4 id="CPU乱序执行"><a href="#CPU乱序执行" class="headerlink" title="CPU乱序执行"></a>CPU乱序执行</h4><p><strong>CPU速度比内存快100倍</strong></p><p><strong>CPU（是CPU）指令乱序执行</strong></p><p>CPU在进行<strong>读等待的同时执行指令</strong>，是CPU乱序的，<strong>根源不是乱，而是提高效率</strong></p><p><img src="/2022/10/08/JVM-%E4%B8%80/45.png" alt="image-20221005105440655"></p><h2 id="1-9DCL和Volatile"><a href="#1-9DCL和Volatile" class="headerlink" title="1.9DCL和Volatile"></a>1.9DCL和Volatile</h2><p><img src="/2022/10/08/JVM-%E4%B8%80/46.png" alt="image-20221005114703529"></p><p><strong>new了一半，指令重排，先关联，构造还没调用，直接返回了（详情请看单例模式和对象new的过程）</strong></p><h2 id="2、GC"><a href="#2、GC" class="headerlink" title="2、GC"></a>2、GC</h2><h4 id="1-从本质谈起"><a href="#1-从本质谈起" class="headerlink" title="1.从本质谈起"></a>1.从本质谈起</h4><p><strong>QQ.exe</strong> —–&gt;操作系统load到内存——–&gt;<strong>形成进程，进程里包含一条一条指令</strong>——-&gt;CPU一条一条的拿数据执行（需要内存的辅助）</p><p><img src="/2022/10/08/JVM-%E4%B8%80/9.png" alt="image-20220928130451378"></p><h4 id="2-程序的栈（stack-frame）和堆"><a href="#2-程序的栈（stack-frame）和堆" class="headerlink" title="2.程序的栈（stack frame）和堆"></a>2.程序的栈（stack frame）和堆</h4><p><img src="/2022/10/08/JVM-%E4%B8%80/10.png" alt="image-20220929190541995"></p><p>栈的内存空间：自动管理（方法执行完自动弹出）</p><p>堆内存管理：多年的难题</p><h4 id="3-最难调试的Bug"><a href="#3-最难调试的Bug" class="headerlink" title="3.最难调试的Bug"></a>3.最难调试的Bug</h4><ul><li><p>野指针</p><p>–同一个对象，两个指针，另一个不知道还拿来用</p><p>–同一个指针不同位置</p><p>–不再指向任何对象的指针</p><p>–NullPointException</p><p>例如：</p><p><img src="/2022/10/08/JVM-%E4%B8%80/11.png" alt="image-20220929193002660"></p><p>图中m()方法把对象给干掉了，main方法中的O也指向了该对象，导致o指向空对象，更有甚者，这块内存又被别人给占了，那么o就会指向别人的对象（<strong>GO语言诞生：Google为了替代以前写过的C语言程序，C语言写程序写起来方便，快，但维护特别麻烦，Bug调试起来特别困难，所以开发Go语言，不在手工维护这些内存空间，而是和Java一样引入GC</strong>）</p></li><li><p>并发问题</p><p>–<strong>多线程访问同一块内存空间</strong></p></li></ul><p>为什么分层，分代，因为以整块内存只用一种算法怎么算都有毛病，所以需要分层，使用综合算法</p><h2 id="3、语言的发展历史"><a href="#3、语言的发展历史" class="headerlink" title="3、语言的发展历史"></a>3、语言的发展历史</h2><p><strong>向着Bug容易调试的方向发展</strong></p><ul><li><p>C&#x2F;C++</p><p>–手工管理内存：malloc等，free&#x2F; new delete（各种判断，各种麻烦的Bug）</p><p>–<strong>忘记删除忘记释放（memory leak    太多导致    out of memory） —————–最次调优——–重启</strong></p><img src="/2022/10/08/JVM-%E4%B8%80/12.png" alt="image-20220929203045722" style="zoom: 50%;"><p>–释放多次（鞭尸问题倒不是很大），产生极难调试的Bug，一个线程空间莫名奇妙的被另一个释放了。</p><img src="/2022/10/08/JVM-%E4%B8%80/13.png" alt="image-20220929203845762" style="zoom: 80%;"><p>–<strong>开发效率很低，运行速率很高</strong></p></li><li><p>Java，python，go</p><p>–方便内存管理的语言，问题还是存在，</p><p>–GC –Garbage Collection  （原来需要小心翼翼的管理，不能多删，不能误删，现在不需要，<strong>我们只管分配内存</strong>，不需要自己去维护删除这块，但是谁来帮我们管理删除这块？这就需要另起一个线程—-GC来帮我们管理，业务线程起来之后，还会启动许多线程，其中就包括GC）</p><p>如下图：不断分配内存，迟早爆炸</p><img src="/2022/10/08/JVM-%E4%B8%80/14.png" alt="image-20220929205519946" style="zoom: 67%;"><p>–大大降低程序员的门槛（空指针依然存在NullpointException，你懂的）</p><p>–<strong>效率降低（多开了线程，必然的）</strong></p><p>– JIT（Just IN TIME，重复，多次使用的代码保存到本地）只有一小段代码与C效率一样</p><p>–架构师思维（达成目的的工具，各有各的特点）</p></li><li><p>rust</p><p>–运行效率超高（asm C C++）</p><p>–<strong>不用手工管理内存（没有GC）</strong></p><p>–<strong>学习曲线巨高</strong>（ownership所有权）</p><p>一个变量有且只有一个值，即多个变量指向同一个内存这种现象不会发生，这就是所有权的概念（一夫一妻制）</p><p>–只要程序语法通过，就不会有Bug（语法非常特殊）（不是逻辑Bug）</p></li></ul><h2 id="4、Garbage-（什么是垃圾）"><a href="#4、Garbage-（什么是垃圾）" class="headerlink" title="4、Garbage?（什么是垃圾）"></a>4、Garbage?（什么是垃圾）</h2><p>什么是垃圾—————在运行过程中，没有任何引用指向他（对象）</p><img src="/2022/10/08/JVM-%E4%B8%80/15.png" alt="image-20220929212549906" style="zoom: 50%;"><h2 id="5、How-To-Find-Garbage-（如何定位垃圾）"><a href="#5、How-To-Find-Garbage-（如何定位垃圾）" class="headerlink" title="5、How To Find Garbage?（如何定位垃圾）"></a>5、How To Find Garbage?（如何定位垃圾）</h2><p>有两种方法</p><h5 id="第一种：reference-count（引用计数）"><a href="#第一种：reference-count（引用计数）" class="headerlink" title="第一种：reference count（引用计数）"></a>第一种：reference count（引用计数）</h5><img src="/2022/10/08/JVM-%E4%B8%80/16.png" alt="image-20220929213055291" style="zoom:50%;"><p><strong>如上图，一个引用消失，数字减一。</strong></p><p>缺点：循环引用： A-&gt;B,B-&gt;C,C-&gt;A  （<strong>一个个垃圾变成一坨垃圾！！！</strong>）</p><img src="/2022/10/08/JVM-%E4%B8%80/17.png" alt="image-20220929213329706" style="zoom:33%;"><h5 id="第二种：Root-Searching（根可达算法）"><a href="#第二种：Root-Searching（根可达算法）" class="headerlink" title="第二种：Root Searching（根可达算法）"></a>第二种：Root Searching（根可达算法）</h5><img src="/2022/10/08/JVM-%E4%B8%80/18.png" alt="image-20220929213634483" style="zoom: 33%;"><p><strong>顺着根找</strong>（什么是根？一般是main函数中的new，你懂的）</p><h2 id="6、Garbage-Algorithms（清除算法）"><a href="#6、Garbage-Algorithms（清除算法）" class="headerlink" title="6、Garbage Algorithms（清除算法）"></a>6、Garbage Algorithms（清除算法）</h2><ul><li>Mark Sweep（标记清除）</li><li>Copying（拷贝）</li><li>Mark-Compact（标记压缩）</li></ul><h4 id="1-Mark-Sweep（标记清除）"><a href="#1-Mark-Sweep（标记清除）" class="headerlink" title="1. Mark Sweep（标记清除）"></a>1. Mark Sweep（标记清除）</h4><img src="/2022/10/08/JVM-%E4%B8%80/19.png" alt="image-20220930083631352" style="zoom:50%;"><p>顺着根开始找，找的到的（有引用的）全都不是垃圾，<strong>找不到的全是垃圾</strong>，清除！！！</p><p>缺点：内存变得碎片化，如上图，东一片，西一片，这时候要是来了一片大内存分配下去，<strong>你会发现找不到内存分配</strong></p><h4 id="2-Copying（拷贝）"><a href="#2-Copying（拷贝）" class="headerlink" title="2. Copying（拷贝）"></a>2. Copying（拷贝）</h4><img src="/2022/10/08/JVM-%E4%B8%80/20.png" alt="image-20220930084206447" style="zoom:50%;"><p>将内存一分为二，设为内存A，内存B，内存A顺着根开始找，把找的到的（即不是垃圾的），<strong>排好序</strong>，复制到另一块内存B，清空内存A，</p><p><strong>效率也很高</strong></p><p>缺点：<strong>浪费内存</strong></p><h4 id="3-Mark-Compact（标记压缩）"><a href="#3-Mark-Compact（标记压缩）" class="headerlink" title="3. Mark-Compact（标记压缩）"></a>3. Mark-Compact（标记压缩）</h4><img src="/2022/10/08/JVM-%E4%B8%80/21.png" alt="image-20220930085025365" style="zoom:50%;"><p>在回收的时候，顺便排序，让内存是连续的，其余的内存都是可用的，如上图，</p><p>缺点：<strong>效率低！！！！</strong></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>三总算法都有毛病，当你把内存分成一整块的时候，不管是哪种算法都有毛病，<strong>所有GC非常聪明，他是对这三种算法进行综合运用，同时对内存进行了划分，三种算法的综合运用诞生了各种各样的垃圾回收器，每一种都有自己的特点</strong></p><h2 id="7、Garbage-Collectors（垃圾回收器）"><a href="#7、Garbage-Collectors（垃圾回收器）" class="headerlink" title="7、Garbage Collectors（垃圾回收器）"></a>7、Garbage Collectors（垃圾回收器）</h2><h4 id="1-总图"><a href="#1-总图" class="headerlink" title="1. 总图"></a>1. 总图</h4><img src="/2022/10/08/JVM-%E4%B8%80/22.png" alt="image-20220930090038852" style="zoom:50%;"><h4 id="2-GC的演化"><a href="#2-GC的演化" class="headerlink" title="2. GC的演化"></a>2. GC的演化</h4><p>随着内存大小的不断增大而演进</p><p>几兆——几十兆</p><p>​–Serial 单线程STW垃圾回收 年青代，老年代</p><p>几十兆——上百兆1G（房间变大了，只有妈妈一个人不够用）</p><p>​–parallel 并行多线程</p><p>几十个G</p><p>​–</p><p>​–内存越来越大，来多少人都不够，线程越多，效率越高？，不一定，又阈值，超过阈值，效率反而降低</p><p>​<strong>原因：CPU一个核同一时刻只能执行一个线程，16核16线程，1000个线程跑进来会进行排队，切换</strong></p><p>​<strong>执行你回儿，执行他一会儿，这个过程叫线程切换，线程切换也是需要消耗CPU资源的，线程切换所需的资源就超过了线程本身运行所需要的资源</strong></p><p>​–效率提不上去？——惊天地泣鬼神的<strong>Concurrent GC</strong>出现了  </p><h4 id="–Concurrent"><a href="#–Concurrent" class="headerlink" title="–Concurrent"></a>–Concurrent</h4><p>从线程的角度：</p><p>业务线程和GC线程同时运行，之前的是业务线程和GC只能跑一个，因为STW（stop-the-world）</p><p>业务线程永远有响应</p><p>产生各种麻烦的问题——一边制造垃圾，一边清理垃圾</p><h4 id="3-内存分代模型（前6种）"><a href="#3-内存分代模型（前6种）" class="headerlink" title="3. 内存分代模型（前6种）"></a>3. 内存分代模型（前6种）</h4><img src="/2022/10/08/JVM-%E4%B8%80/23.png" alt="image-20220930090825869" style="zoom:50%;"><p><strong>新生代：</strong>  </p><p>刚刚诞生的对象，年轻的，频繁被GC扫，</p><p><strong>老年代：</strong>GC扫描多次后都没有进行回收，说明是个老顽固，如果在扫描就是浪费资源，所以把它放到老年代，等到老年代内存满了，装不下了，就扫描一次老年代清掉没用的垃圾</p><p><strong>总结</strong>：<strong>综合算法的体现，新生代使用Copying算法，老年代使用Mark Sweep或者Mark-Compact又或者两者都使用</strong>，<strong>jdk1.8或者以前所采用的都是分代模型</strong></p><p>​–年轻代的Copying算法与上面的有点不一样，年轻代的Copying算法是根据工业实践的出来的结果，一般来说，一次年轻代的回收   称为min GC 或者 YGC，大概会回收90%的对象，剩下的只有10%，没必要分成两半，一般是</p><p>​8（eden）：1（survivor）：1（survivor）</p><p>例如：</p><p>​10个对象刚刚被创建出来，放在eden区，一次GC干掉了90%，还剩一个对象放在survivor1区，eden整体清空，第二次又创建了10个对象放在eden区，这时候会扫描eden区和survivor1区，又干掉90%，把存活下来的放在survivor2区，eden和survivor1区整体清空，第三次则存活下来的则是放在survivor1区，eden和survivor2区整体清空，如此循环往复。十分简单，当survivor装不下放入老年代，<strong>老年代满了FullGC</strong></p><p><strong>方法区：1.7之前永久代，1.8之后叫元空间，不管怎么变都叫方法区</strong></p><h5 id="Serial（在年青代工作）（单线程）"><a href="#Serial（在年青代工作）（单线程）" class="headerlink" title="Serial（在年青代工作）（单线程）"></a>Serial（在年青代工作）（单线程）</h5><p>你，你女盆友，你男盆友，哥三儿在房间里（年青代）扔纸团，扔到满了，这时候妈妈（GC）进来了，停止扔纸团（业务线程停止）不管做什么，什么姿势，都不许动了，这时候妈妈根查找清理没用的线团（垃圾）清完之后才能动，又继续玩，继续扔线团</p><img src="/2022/10/08/JVM-%E4%B8%80/24.png" alt="image-20220930102733438" style="zoom:50%;"><p><strong>停止这段时间称为——stop-the-world（STW）</strong></p><p>内存小，一个线程足矣</p><h5 id="Serial-Old（在老年代工作）"><a href="#Serial-Old（在老年代工作）" class="headerlink" title="Serial Old（在老年代工作）"></a>Serial Old（在老年代工作）</h5><p>在老年代也是如此，也是一个线程，只不过算法不一样</p><img src="/2022/10/08/JVM-%E4%B8%80/25.png" alt="image-20220930103021181" style="zoom:50%;"><h5 id="parallel-Scavenge（多线程，年青代）"><a href="#parallel-Scavenge（多线程，年青代）" class="headerlink" title="parallel Scavenge（多线程，年青代）"></a>parallel Scavenge（多线程，年青代）</h5><p><strong>1.8默认垃圾回收器</strong></p><p>还是哥三儿，不过这次房间（内存）满了，不止妈妈进来清扫，还有爷爷，姥姥，舅舅进来清扫（多线程）</p><h5 id="parallel-Old（多线程，老年代）"><a href="#parallel-Old（多线程，老年代）" class="headerlink" title="parallel Old（多线程，老年代）"></a>parallel Old（多线程，老年代）</h5><p>查看默认GC命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintCommandLineFlags -version</span><br></pre></td></tr></table></figure><p><img src="/2022/10/08/JVM-%E4%B8%80/26.png" alt="image-20220930104229448"></p><p>-XX:+UseParallelGC       &#x2F;&#x2F;意思是parallel Scavenge+parallel Old  组合</p><h5 id="开天辟地Concurrent的第一个垃圾回收器——CMS"><a href="#开天辟地Concurrent的第一个垃圾回收器——CMS" class="headerlink" title="开天辟地Concurrent的第一个垃圾回收器——CMS"></a>开天辟地Concurrent的第一个垃圾回收器——CMS</h5><p>CMS全称——concurrent mark sweep（并发的标记清除）（工作在老年代）</p><p>第一个Concurrent，像秦始皇，有天生的Bug</p><h5 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h5><img src="/2022/10/08/JVM-%E4%B8%80/27.png" alt="image-20220930115002678" style="zoom:33%;"><p>工作在年青代的<strong>多线程</strong>，与CMS打配合</p><p>​–为什么不用 parallel？</p><p>​enhancement 增强，是Parallel Scavenge的增强，为了配合CMS</p><h5 id="垃圾回收器CMS算法理论"><a href="#垃圾回收器CMS算法理论" class="headerlink" title="垃圾回收器CMS算法理论"></a>垃圾回收器CMS算法理论</h5><img src="/2022/10/08/JVM-%E4%B8%80/28.png" alt="image-20220930120311581" style="zoom:50%;"><p>底层角度：6个阶段</p><p>线程角度：4个阶段</p><p>线程角度：</p><ul><li><p>初始标记，找到根对象，只需找到跟对象，依然会STW，但是根对象相对较少，所以STW会很快</p></li><li><p>并发标记，业务线程继续，业务一边运行，GC一边工作（标记），一定会存在错标，</p><p>–错标主要有两种情况，垃圾变成不是垃圾，不是垃圾变成垃圾</p><p>–<strong>著名的三色标记算法发生在此阶段</strong></p></li><li><p>重新标记，修正过程，业务线程不能继续，都发生错误了，肯定不能继续，也会发生STW</p></li><li><p>并发清理</p></li></ul><h4 id="4-三色标记算法"><a href="#4-三色标记算法" class="headerlink" title="4. 三色标记算法"></a>4. 三色标记算法</h4><p>并发标记阶段，还没有清理，只是在标记，业务线程一边运行，GC一边找，GC就会问哥们儿是垃圾吗？哥们儿是垃圾吗？哥们儿是垃圾吗？因为线程会切换，同一个线程会隔一段时间运行隔一段时间运行，所以需要把状态保存下来，如上一次运行扫描到50%这个程度了，下次要在这个基础之上继续扫描，直到扫描完全部才算结束，然后才开始清理</p><p>小知识：线程的运行时间是由操作系统来进行调度的，他调度的时间片以及时间长都不是固定的，LinuxCPU内核采用的是CFS（完全公平算法）算法，<strong>所以必须要把标记到那里保存下来，怎么记录下来呢，采用的就是三色标记算法</strong></p><img src="/2022/10/08/JVM-%E4%B8%80/29.png" alt="image-20220930171816913" style="zoom:50%;"><p>黑色：孩子都扫描完，黑色</p><p>灰色：孩子未扫描完，灰色</p><p>白色：没用遍历到的节点，白色，枚举完还是白色，当垃圾清除</p><p>用两位来标记颜色（00 01 10 11），标记在对象上，放在mark word（详情看**.class文件解读**）上</p><p><strong>两个问题（详情CSDN三色标记）</strong></p><p>本应该是垃圾的对象被视为非垃圾（问题不大）</p><p>一个本不应该是垃圾的对象被视为垃圾（GG）</p><p>所以需要remark（重新标记阶段），必须从头扫一遍，STW非常漫长（慢啊啊啊A~A~~A），因此，没有任何一个JDK版本把它作为默认的垃圾回收器</p><p>漏标必然存在</p><p>三色只是一个扫描算法，普遍使用，错不在他，是CMS的Incremental Update有Bug，G1的STAB没Bug（？？？好用！！！），1.8之前没得选，想要并发的话，1.7诞生G1，可惜当时的G1不成熟</p><h4 id="5-内存不分代模型"><a href="#5-内存不分代模型" class="headerlink" title="5. 内存不分代模型"></a>5. 内存不分代模型</h4><h5 id="Epsilon："><a href="#Epsilon：" class="headerlink" title="Epsilon："></a>Epsilon：</h5><p>什么也不干垃圾回收器,开发JVM的人做DeBug用的</p><p>内存超级大，也用不了这么多内存，就什么也不干，等程序结束自己释放内存，效率极高（什么也不干Very Good）</p><h5 id="G1：目前主流"><a href="#G1：目前主流" class="headerlink" title="G1：目前主流"></a>G1：目前主流</h5><img src="/2022/10/08/JVM-%E4%B8%80/30.png" alt="image-20220930190521288" style="zoom:50%;"><p>摒弃了分代模型，因为随着内存越来越大，不管怎么采用并发玩一边，速度都玩不转，CMS固有的Bug，必须改进。</p><p>产生Region（分区算法），永远有空的内存可用，需要连续内存（Humongous），如何连不上开始整理</p><p>缺点：一次回收要把G1的年青代全部回收完，当你的年青代很大的时候，一次YGC的STW也需要很长时间</p><p>G1逻辑上是分代的，物理不分代</p><h5 id="ZGC（分页算法）"><a href="#ZGC（分页算法）" class="headerlink" title="ZGC（分页算法）"></a>ZGC（分页算法）</h5><p>因为G1的缺点，所以诞生了ZGC（分页算法），goLong的核心</p><p>​–支持TB级别（4T，据说以经扩展到16T）</p><p>​–最大GC停顿10ms</p><p>​–内存增大，停顿时间不长</p><p>​–throughPut不超过15%影响</p><p>​–SPECjbb 2015基准测试，128G堆内存，单纯GC停顿最大1.68ms，平均1.09ms</p><ul><li>Colored Point（颜色指针）太复杂以后研究</li><li>loadBarrier（读屏障）</li><li>SingleGeneration（不再分代）</li><li>内存大小固定，为2的倍数，1，2，4，8，16，32</li></ul><h5 id="Shenandoal"><a href="#Shenandoal" class="headerlink" title="Shenandoal"></a>Shenandoal</h5><p>开源，红帽提供，与ZGC类似，不分代</p><h2 id="8、什么是调优"><a href="#8、什么是调优" class="headerlink" title="8、什么是调优"></a>8、什么是调优</h2><p>为什么一个百万级的TPS系统会频繁GC</p><p>被问调优，一定要指明是那个垃圾回收器（GC）</p><p><strong>什么是调优？</strong></p><ul><li>根据内存进行JVM规划和预调优</li><li>优化运行JVM运行环境（慢，卡顿）（怎么才能定位一个系统的瓶颈？压测）</li><li>解决JVM运行过程中出现的各种问题（Memory Leak ）（OOM  out of memory）</li></ul><p>GC日志详解（<strong>之后补充</strong>）</p><p><strong>工业生产环境中，一个Java程序应该设置什么参数</strong></p><img src="/2022/10/08/JVM-%E4%B8%80/31.png" alt="image-20220930203711901" style="zoom:50%;"><p>JVM可能一个月才出一次问题，很难模拟</p><p>模拟银行或者互联网金融体系，风控（可信度—贷款，家里有矿，贷多一点）根据过去的情况，是否按时还款，有没有借贷不还的，取出用户信息计算出来的，套用风险控制模型计算出他的贷款额度，或者是否给他贷款</p><p>创建一个List，不断往里头扔对象，很快就内存溢出了（这个例子太简单）</p><p>一个方法每次从数据库拿出100条数据，放进任务列表里，起了一个线程池，定时执行任务，50个线程，固定频率拿出数据进行计算</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -Xms200M -Xms200M -XX:+PrintGC  com.......   //-Xms200M -Xms200M设置一样，防止内存抖动，防止内存涨来涨去，缩来//缩去</span><br><span class="line">//-XX:+PrintGC 输出GC日志</span><br></pre></td></tr></table></figure><p><img src="/2022/10/08/JVM-%E4%B8%80/32.png" alt="image-20220930211110355"></p><p>一个Java命令会启动一个Java虚拟机，两个则启动两个Java虚拟机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java//查询命令参数</span><br><span class="line">java -X//查询带X的非标参数</span><br><span class="line">java -XX:+PrintFlagsFinal -version   //查询所有参数的最终值，带XX的有700多个，我们用的只有几十个而已</span><br></pre></td></tr></table></figure><p>带XX的有700多个，我们用的<strong>只有几十个而已</strong></p><p>-X     非标参数，用来调优</p><p>-XX   真正的调优参数</p><h5 id="jps（java-process-系统里的Java进程）"><a href="#jps（java-process-系统里的Java进程）" class="headerlink" title="jps（java process 系统里的Java进程）"></a>jps（java process 系统里的Java进程）</h5><p><img src="/2022/10/08/JVM-%E4%B8%80/33.png" alt="image-20220930212903658"></p><p>两个进程 </p><ul><li>JPS本身</li><li>FullGC</li></ul><h5 id="jinfo-11800（进程名称）"><a href="#jinfo-11800（进程名称）" class="headerlink" title="jinfo   11800（进程名称）"></a>jinfo   11800（进程名称）</h5><h5 id="jstat（java的统计信息-或者-java的跟踪信息）"><a href="#jstat（java的统计信息-或者-java的跟踪信息）" class="headerlink" title="jstat（java的统计信息    或者  java的跟踪信息）"></a>jstat（java的统计信息    或者  java的跟踪信息）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jstat -gc 11800  // 加上进程号， 跟踪gc的信息</span><br><span class="line">jstat -gc 11800 500  //每500秒打印一次，后面有工具</span><br></pre></td></tr></table></figure><h5 id="jstack-（跟踪线程的）"><a href="#jstack-（跟踪线程的）" class="headerlink" title="jstack （跟踪线程的）"></a>jstack （跟踪线程的）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack 11800   //把11800所有线程列出来</span><br></pre></td></tr></table></figure><p><img src="/2022/10/08/JVM-%E4%B8%80/34.png" alt="image-20220930213944875"></p><ul><li>线程名字</li><li>线程编号</li><li>线程优先级</li><li>操作系统级别优先级</li><li>线程状态</li><li>线程的调用堆栈（即这个方法调用了那个方法，这个方法又调了哪个方法）</li></ul><p>如果很多个线程一直在waiting，可能是死锁</p><h5 id="top"><a href="#top" class="headerlink" title="top"></a>top</h5><p>显示当前系统里哪个进程占CPU、内存</p><h5 id="top-Hp-11800"><a href="#top-Hp-11800" class="headerlink" title="top -Hp 11800"></a>top -Hp 11800</h5><p>查看11800进程里的所有线程</p><h5 id="JVM的CPU爆了，怎么查"><a href="#JVM的CPU爆了，怎么查" class="headerlink" title="JVM的CPU爆了，怎么查"></a>JVM的CPU爆了，怎么查</h5><p>jvm占据很高CPU，怎么查&#x2F;追踪：top查进程信息，找出消耗高的，top -Hp 11800查线程信息找出是这个进程里哪个线程消耗高，</p><p>再使用jstack对比线程信息，找到该消耗高的线程（定位），会有两种情况：</p><p>第一种：该线程是VM线程，一般是GC，查看GC日志；</p><p>​–频繁GC？压力爆表如双十一</p><p>​–内存回收不掉，内存泄漏</p><p>第二种：业务线程。二话不说，查看他调用了什么方法</p><p><img src="/2022/10/08/JVM-%E4%B8%80/35.png" alt="image-20221001091752421"></p><p>频繁FullGC，200M内存回收完还是200M，内存被占满了</p><h5 id="jmap："><a href="#jmap：" class="headerlink" title="jmap："></a>jmap：</h5><p>—– 是谁在调用内存。</p><p>—–查看堆内存中对象占用情况，不同类的对象占用内存比重</p><p>——产生堆转储文件，把<strong>JVM</strong>导出来存到硬盘上，拿来分析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jmap -histo 11988   //查看当前进程所有类又多少个实例</span><br><span class="line">jmap -histo 11988 | head 20   //查看前20个</span><br></pre></td></tr></table></figure><p><strong>多运行几次，注意看哪些类的实例个数在不断增长，说明没有被回收</strong>，然后查业务逻辑</p><p>jmap会让整个JVM卡死，STW，把对象输出出来，生产环境肯定不能这么干</p><p><strong>可以在测试环境执行，复制一份到备份机上执行</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dumpa:format=b,file=20200912.hprof 11988 //把堆内存转储成文件，来对他进行分析</span><br></pre></td></tr></table></figure><p>把java的整个堆转成文件，在网下载图形工具进行分析，java自带了一个</p><p>往外到文件，依然会让JVM卡死</p><p>一定设置好启动参数</p><p>-XX:+HeapDumpOnOutOfMemoryError  &#x2F;&#x2F; 当内存爆了，自动生成堆转储文件，在使用工具分析</p><p>生成环境下，除了运维，不多开端口，若是远程连接，会导致不安全，且性能下降10%-15%</p><p>​–压测的时候查看</p><p>​–做了负载均衡，把出问题的机器摘出来，在分析</p><p>​–双十一之类，互联网连接特别多，使用tcp copy命令复制一份，一份给生产环境，一份给测试环境</p><h5 id="Arthas"><a href="#Arthas" class="headerlink" title="Arthas"></a>Arthas</h5><p><img src="/2022/10/08/JVM-%E4%B8%80/36.png" alt="image-20221002092318715"></p><p>查找所有Java进程</p><p>然后选择进行挂载，对他进行观察</p><p>影响系统进程，10%-15%</p><p><strong>替代之前所有命令，且直观</strong></p><h6 id="dashboard（仪表盘）"><a href="#dashboard（仪表盘）" class="headerlink" title="dashboard（仪表盘）"></a>dashboard（仪表盘）</h6><p><img src="/2022/10/08/JVM-%E4%B8%80/37.png" alt="image-20221002092622596"></p><p><strong>结合了前面所有命令，可以看到，这个进程里有哪些线程，哪些线程在吃CPU，且在最前面</strong></p><p>还包括堆内存占多少，非堆内存占多少，</p><h6 id="heap-dump"><a href="#heap-dump" class="headerlink" title="heap dump"></a>heap dump</h6><p>替代jmap</p><h6 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread -b  //直接找死锁，不像上面那么麻烦</span><br></pre></td></tr></table></figure><h6 id="jvm"><a href="#jvm" class="headerlink" title="jvm"></a>jvm</h6><p>与jinfo差不多</p><h6 id="trace"><a href="#trace" class="headerlink" title="trace"></a>trace</h6><p><strong>以上只是定位问题</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> .class </tag>
            
            <tag> GC </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合</title>
      <link href="/2022/09/21/%E9%9B%86%E5%90%88/"/>
      <url>/2022/09/21/%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="1-数组"><a href="#1-数组" class="headerlink" title="1. 数组"></a>1. 数组</h2><p>Array：</p><ol><li>Java语言中的数组是一种引用数据类型。不属于基本数据类型。数组的父类是Object。</li><li>数组实际上是一个容器，可以同时容纳多个元素。（数组是一个数据的集合）</li><li>数组可以存储基本数据类型，也可以存储引用数据类型的数据</li><li>数组因为是引用数据类型，所以数组对象是存储在堆内存当中的（数组是存储在堆中的）</li><li>数组当中如果存储的是<strong>Java对象</strong>的话，实际上存储的是对象的<strong>引用（内存地址）</strong>，数组中不能直接存储Java对象</li><li>数组一旦创建，在Java中规定，长度不可改变。（数组长度不可变）</li><li>所有数组对象都有Length属性（Java自带的），用来获取数组中的元素的个数。</li><li>Java中的数组要求数组中的元素的类型统一。比如int类型数组只能存储int类型，Person类型只能存储Person类型</li><li>数组在内存方面存储的时候，<strong>数组中的元素内存地址是连续的</strong>（存储的每一个元素都是有规则的挨着排列的）。内存地址连续这是数组存储元素的特点（特色），数组实际上是一种简单的数据结构。</li><li>所有的数组都是拿“第一个小方框的内存地址”作为整个数组对象的内存地址。</li><li>数组中每个元素都是有下标的，下标从零开始，以1递增。最后一个元素的下标是：length-1，下标非常重要，因为我们对数组中元素进行<strong>“存取”</strong>的时候，都需要通过下标来进行</li></ol><p>一维数组内存结构</p><p><img src="/2022/09/21/%E9%9B%86%E5%90%88/1.png" alt="1"></p><p>数组这种数据结构的优点和缺点是什么？</p><p>优点：查询&#x2F;查找&#x2F;检索某个下标上的元素时效率极高，可以说是查询效率最高的一种数据结构。</p><p>为什么检索效率高？</p><p>​第一：每一个元素的内存地址在空间存储上是连续的。</p><p>​第二： 每一个元素类型相同，所以占用空间的大小是一样的。</p><p>​第三： 知道一个元素的内存地址，下标，知道每一个元素占用的空间大小，<strong>所以通过一个数学表达式就可以计算出某个下标上的元素的内存地址，所以数组的检索效率是最高的。</strong></p><p>数组中存储100个元素与存储100万个元素，在元素查询&#x2F;检索方面效率是一样的，因为数组查找元素时不会一个一个的查找，而是通过数学表达式计算出来的（算出一个内存地址，直接定位）</p><p>缺点：</p><p>​第一：由于为了保证数组中每个元素的内存地址连续，所以在数组上随机删除或者增加元素的时候，效率较低，因为随机增删元素会涉及到后面元素统一向前或者向后位移的操作。</p><p>​<strong>第二：数组不能存储大数据量，为什么？</strong></p><p>因为很难在内存空间上找到一块特别大的连续的内存空间。</p><p>声明与定义一个一维数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">500</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] array1 = <span class="keyword">new</span> <span class="title class_">int</span>[] <span class="comment">//这里的5表示数组元素的个数</span></span><br></pre></td></tr></table></figure><p>ArrayIndexOutOfBoundsException：数组越界异常</p><h2 id="2-集合的概述"><a href="#2-集合的概述" class="headerlink" title="2. 集合的概述"></a>2. 集合的概述</h2><h3 id="什么是集合-有什么用"><a href="#什么是集合-有什么用" class="headerlink" title="什么是集合?有什么用?"></a>什么是集合?有什么用?</h3><p>数组其实就是一个集合。集合实际上就是一个容器。可以来容纳其它类型的数据。</p><p>集合为什么说在开发中使用较多?</p><ul><li>集合是一个容器，是一个载体，可以一次容纳多个对象。在实际开发中，假设连接数据库，数据库当中有10条记录，那么假设把这10条记录查询出来，在java程序中会将10条数据封装成10个java对象，然后将10个java对象放到某一个集合当中，将集合传到前端，然后遍历集合，将一个数据一个薮据展现出来。</li><li><strong>集合不能直接存储基本数据类型，另外集合也不能直接存储java对象，集合当中存储的都是java对象的内存地址</strong>。（或者说集合中存储的是引用。)<br>list.add ( 100) ; &#x2F;&#x2F;自动装箱Integer<br>注意:<br><strong>集合在java中本身是一个容器，是一个对象。集合中任何时候存储的都是出“引用”。</strong></li></ul><p>在java中每一个不同的集合，<strong>底层会对应不同的数据结构</strong>。往不同的集合中存储元素，等于将数据放到了不同的数据结构当中。什么是数据结构﹖数据存储的结构就是数据结构。不同的数据结构，数据存储方式不同。例如:<br>数组、二叉树、链表、哈希表…<br>以上这些都是常见的数据结构。</p><ul><li>你往集合c1中放数据，可能是放到数组上了.</li><li>你往集合c2中放数据，可能是放到二叉树上了-</li></ul><p>你使用不同的集合等同于使用了不同的数据结构。<br>你在java集合这一章节，你需要掌握的不是精通数据结构。java中已经将数据结构实现了，已经写好了这些常用的集合类，你只需要掌握怎么用?在什么情况下选择哪一种合适的集合去使用即可.</p><ul><li>new ArrayList() ;创建一个集合，底层是数组。</li><li>new LinkedList();创建一个集合对象，底层是链表.</li><li>new Treeset() ;创建一个集合对象,底层是二叉树。</li></ul><h2 id="3-集合继承结构图"><a href="#3-集合继承结构图" class="headerlink" title="3.集合继承结构图"></a>3.集合继承结构图</h2><p><img src="/2022/09/21/%E9%9B%86%E5%90%88/2.png" alt="image-20221006144926866"></p><p><img src="/2022/09/21/%E9%9B%86%E5%90%88/3.png" alt="image-20221006145242562"></p><h2 id="4-Map集合继承结构图"><a href="#4-Map集合继承结构图" class="headerlink" title="4.Map集合继承结构图"></a>4.Map集合继承结构图</h2><p><img src="/2022/09/21/%E9%9B%86%E5%90%88/4.png" alt="image-20221006145456889"></p><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p>总结(所有的实现类):,</p><ul><li><p>ArrayList:底层是数组。vLinkedList:底层是双向链表。,</p></li><li><p>Vector:底层是数组，线程安全的，效率较低，使用较少。v</p></li><li><p>HashSet:底层是HashMap，放到HashSet.集合中的元素等同于放到HashMap集合 key部分了。.</p></li><li><p>TreeSet:底层是TreeMap，放到TreeSet.集合中的元素等同于放到TreeMap集合 key部分了。</p></li><li><p>HashMap:底层是哈希表。,</p></li><li><p>Hashtable:底层也是哈希表，只不过线程安全的，效率较低，使用较少。</p></li><li><p>Properties:是线程安全的，并且 key和value只能存储字符串 String。</p></li><li><p>TreeMap:底层是二叉树。TreeMap集合的 key可以自动按照大小顺序排序。</p></li><li><p>List集合存储元素的特点:</p><ul><li><p>有序可重复</p></li><li><p>有序:存进去的顺序和取出的顺序相同，每一个元素都有下标。</p></li><li><p>可重复:存进去1，可以再存储一个1.</p></li></ul></li><li><p>set集合存储元素的特点:,</p><ul><li>无序不可重复</li><li>无序:存进去的顺序和取出的顺序不一定相同。另外set集合中元素没有下标。</li><li>不可重复:存进去1，不能再存储1了。</li></ul></li><li><p>SortedSet集合存储元素特点:</p><ul><li><p>首先是无序不可重复的，但是SortedSet集合中的元素是可排序的。</p></li><li><p>无序:存进去的顺序和取出的顺序不一定相同。另外 set集合中元素没有下标。</p></li><li><p>不可重复:存进去1，不能再存储1了。</p></li><li><p><strong>可排序:可以按照大小顺序排列。</strong></p></li></ul></li></ul><h2 id="5-Collection中常用的方法"><a href="#5-Collection中常用的方法" class="headerlink" title="5.Collection中常用的方法"></a>5.Collection中常用的方法</h2><p>集合.size()获取集合中元素的个数</p><p>集合.clear()清空集合</p><p>集合.add()向集合中添加元素</p><p>集合.remove()删除集合中的某个元素</p><p>集合.isEmpty判断该集合中元素个数是否为0</p><p>集合.toArray()调用这个方法可以把集合转换成数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1集合中能存放什么元素</span></span><br><span class="line"><span class="comment">没有使用&quot;泛型”之前，collection中可以存储object的所有子类型。使用了“泛型”之后，collection中只能存储某个具体的类型。</span></span><br><span class="line"><span class="comment">Collection中什么都能存，只要是object的子类型就行。（集合中不能亘接存储基本数据类型，也不能存java对象，只是存储java对象的内存地址。)</span></span><br><span class="line"><span class="comment">2、Collection中的常用方法</span></span><br><span class="line"><span class="comment">booLean add( object e)向集合中添加元素</span></span><br><span class="line"><span class="comment">int size()获取集合中元素的个数</span></span><br><span class="line"><span class="comment">void clear()清空集合</span></span><br><span class="line"><span class="comment">boolean contains(Object o)判断当前集合中是否包含元素o，包含返回true，不包含返回false</span></span><br><span class="line"><span class="comment">boolean remove( 0bject o)删除集合中的某个元素。</span></span><br><span class="line"><span class="comment">boolean isEmpty()判断该集合中元素的个数是否为e</span></span><br><span class="line"><span class="comment">object[] toArray()调用这个方法可以把集合转换成数组。【作为了解，使用不多。】</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个集合对象</span></span><br><span class="line">        <span class="comment">//Collection c = new Collection(); //接口是抽象的，无法实例化。</span></span><br><span class="line">        <span class="comment">//多态</span></span><br><span class="line">        <span class="type">Collection</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="comment">//测试collection接口中的常用方法</span></span><br><span class="line">        c.add(<span class="number">1200</span>);<span class="comment">//自动装箱(java5的新特性。),实际上是放进去了一个对象的内存地址。Integer x = new Integer(1200)</span></span><br><span class="line">        c.add(<span class="number">3.14</span>);<span class="comment">//自动装箱</span></span><br><span class="line">        c.add( <span class="keyword">new</span> <span class="title class_">object</span>());</span><br><span class="line">        c.add( <span class="keyword">new</span> <span class="title class_">student</span>());</span><br><span class="line">        c.add(<span class="literal">true</span>); <span class="comment">//自动装箱</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取集合中元素的个数</span></span><br><span class="line">System.out.println(<span class="string">&quot;集合中元素个数是:&quot;</span> + c.size());<span class="comment">// 5</span></span><br><span class="line"><span class="comment">//清空集合</span></span><br><span class="line">        c.clear( );</span><br><span class="line">        System.out.println(<span class="string">&quot;集合中元素个数是:&quot;</span> + c.size()); <span class="comment">// 0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//再向集合中添加元素</span></span><br><span class="line">        c.add(<span class="string">&quot;he1lo&quot;</span>); <span class="comment">//&quot;heLlo&quot;对象的内存地址放到了集合当中。</span></span><br><span class="line">        c.add( <span class="string">&quot;wor1d&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;浩克&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;绿巨人&quot;</span>);</span><br><span class="line">        c.add( <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//判断集合中是否包含&quot;绿巨人”</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> c.contains(<span class="string">&quot;绿巨人&quot;</span>);</span><br><span class="line">        System.out.print1n(flag); <span class="comment">//true</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag2</span> <span class="operator">=</span> c.contains(<span class="string">&quot;绿巨人2&quot;</span>);</span><br><span class="line">        System.out.println(flag2); <span class="comment">// false</span></span><br><span class="line">        system.out.println(c.contains(<span class="number">1</span>)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;集合中元素个数是:&quot;</span> + c.size());<span class="comment">// 5</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//删除集合中某个元素</span></span><br><span class="line">        c.remove(<span class="number">1</span>);</span><br><span class="line">        system.out.println(<span class="string">&quot;集合中元素个数是:&quot;</span> + c.size()); <span class="comment">// 4</span></span><br><span class="line">        <span class="comment">//判断集合是否为空（集合中是否存在元素)</span></span><br><span class="line">        system.out.println(c.isEmpty()); <span class="comment">//falsel</span></span><br><span class="line">        <span class="comment">//清空</span></span><br><span class="line">        c.clear( );</span><br><span class="line">        system.out.println(c.isEmpty()); <span class="comment">//true ( true表示集合中没有元素了!)</span></span><br><span class="line">        c.add( <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        c.add( <span class="string">&quot;def&quot;</span> ) ;</span><br><span class="line">        c.add( <span class="number">100</span>) ;</span><br><span class="line">        c.add( <span class="string">&quot;he11owor1d ! &quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//转换成数组</span></span><br><span class="line">        object[] objs =c.toArray();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; objs.length; i++)&#123;</span><br><span class="line">        <span class="comment">//逼历数组</span></span><br><span class="line">        <span class="type">object</span> <span class="variable">o</span> <span class="operator">=</span> objs[i];</span><br><span class="line">            System.out.println(o) ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-Collection集合迭代"><a href="#6-Collection集合迭代" class="headerlink" title="6.Collection集合迭代"></a>6.Collection集合迭代</h2><p><strong>&#x2F;&#x2F;注意:以</strong>下<strong>讲解的逼历方式&#x2F;迭代方式，是所有Collection通用的一种方式。</strong>**<br>        <strong>&#x2F;&#x2F;在Map集合中不能用。在所有的Collection以及子类中使用。</strong>**</p><p><strong>&#x2F;&#x2F;不管你当初存进去什么，取出来统一都是object。</strong></p><p>迭代器是通用的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//注意:以下讲解的逼历方式/迭代方式，是所有Collection通用的一种方式。</span></span><br><span class="line">        <span class="comment">//在Map集合中不能用。在所有的Collection以及子类中使用。</span></span><br><span class="line">        <span class="comment">//创建集合对象</span></span><br><span class="line">        <span class="type">Collection</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();<span class="comment">//后面的集合无所谓，主要是看前面的Collection接口，怎么遍历/迭代。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        c.add ( <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;def&quot;</span>);</span><br><span class="line">        c.add ( <span class="number">100</span>) ;</span><br><span class="line">        c.add( <span class="keyword">new</span> <span class="title class_">Object</span>( ));</span><br><span class="line">        <span class="comment">//对集合collection进行逼历/迭代</span></span><br><span class="line">        <span class="comment">//第一步:获取集合对象的迭代器对象</span></span><br><span class="line">        <span class="type">IteratorIterator</span> <span class="variable">it</span> <span class="operator">=</span> c.iterator();</span><br><span class="line">        <span class="comment">//第二步:通过以上获取的迭代器对象开始迭代/逼历集合。</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        以下两个方法是迭代器对象Iterator中的方法:</span></span><br><span class="line"><span class="comment">        boolean hasNext( )如果仍有元素可以迭代，则返回true</span></span><br><span class="line"><span class="comment">        oobject next( )返回迭代的下一个元素。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">boolean</span> <span class="variable">hasNext</span> <span class="operator">=</span> it.hasNext();</span><br><span class="line">        <span class="keyword">if</span>(hasNext) &#123;</span><br><span class="line">            <span class="comment">//不管你当初存进去什么，取出来统一都是object。</span></span><br><span class="line">            <span class="type">object</span> <span class="variable">obj</span> <span class="operator">=</span> it.next();</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2022/09/21/%E9%9B%86%E5%90%88/5.png" alt="image-20221006154204253"></p><h2 id="7-Contains方法解析"><a href="#7-Contains方法解析" class="headerlink" title="7.Contains方法解析"></a>7.Contains方法解析</h2><p><img src="/2022/09/21/%E9%9B%86%E5%90%88/6.png" alt="image-20221006163104159"></p><p><strong>contains方法里使用了equals方法，</strong>而equals比较的是内存地址，<strong>所以放在集合里的元素需要重写equals方法</strong></p><p>String里也重写了equals方法，so，你懂的，<strong>remove也是一样</strong></p><h2 id="8-List特有的方法"><a href="#8-List特有的方法" class="headerlink" title="8.List特有的方法"></a>8.List特有的方法</h2><p>1、List集合存储元素特点:有序可重复<br>有序: List集合中的元素有下标。从8开始，以1递增。<br>可重复:存储一个1，还可以再存储1.<br>2、List既然是collection接口的子接口，那么肯定ist接口有自己”特色”的方法:<br>以下只列出List接口特有的常用的方法:</p><ul><li>void add(int index， 0bject eLement)</li><li>object get(int index)</li><li>int index0f(Object o)</li><li>int lastIndexOf(object o)</li><li>object remove(int index)</li><li>object set(int index, object eLement)</li></ul><h2 id="9-ArrayList初始化容量及扩容"><a href="#9-ArrayList初始化容量及扩容" class="headerlink" title="9.ArrayList初始化容量及扩容"></a>9.ArrayList初始化容量及扩容</h2><p>1、默认初始化容量10（<strong>底层先创建了一个长度为0的数组，当添加第一个元素的时候，初始化容量为10</strong>）</p><p>2、集合底层是一个object[ ]数组。</p><p>3、构造方法:</p><p>​new ArrayList();</p><p>​new ArrayList(20);</p><p>4、ArrayList集合的扩容:<br>$$</p><blockquote><blockquote><p> 位运算符， 表示二进制右移<br>$$<br><strong>增长到原容量的1.5倍。</strong><strong>旧长度右移一位</strong><br><strong>ArrayList集合底层是数组，怎么优化?</strong><br>尽可能少的扩容。因为数组扩容效率比较低，<strong>建议在使用ArrayList集合的时候预估计元素的个数，给定一个初始化容量。</strong></p></blockquote></blockquote><p>5、数组优点:<br>检索效率比较高。(<strong>每个元素占用空间大小相同，内存地址是连续的，知道首元素内存地址然后知道下标，通过数学表达式计算出元素的内存地址，所以检索效率最高。</strong>)</p><p>6、数组缺点:<br>随机增删元素效率比较低。<br>另外数组无法存储大数据量。（<strong>很难找到一块非常巨大的连续的内存空间</strong>。)</p><p>7、向数组末尾添加元素，效率很高，不受影响。</p><p>8、面试官经常问的一个问题?<br>这么多的集合中，你用哪个集合最多?</p><p>答: ArrayList集合。<br>因为往数组末尾添加元素，效率不受影响。另外，我们检索&#x2F;查找某个元素的操作比较多。</p><h2 id="10-单向链表"><a href="#10-单向链表" class="headerlink" title="10.单向链表"></a>10.单向链表</h2><p><img src="/2022/09/21/%E9%9B%86%E5%90%88/7.png" alt="image-20221006171919238"></p><p>单链表中的节点。<br>节点是单向链表中基本的单元。每一个节点Node都有两个属性:<br>一个属性:是存储的数据。<br>另一个属性:是下一个节点的内存地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//节点对象</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">单链表中的节点。</span></span><br><span class="line"><span class="comment">节点是单向链表中基本的单元。每一个节点Node都有两个属性:</span></span><br><span class="line"><span class="comment">一个属性:是存储的数据。</span></span><br><span class="line"><span class="comment">另一个属性:是下一个节点的内存地址。*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储的数据</span></span><br><span class="line">    object element;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下一个节点的内存地址</span></span><br><span class="line">    Node next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Object data，Node next)</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//简单测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Link</span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//头节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">header</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向链表中添加元素的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(object data)</span>&#123;</span><br><span class="line">        <span class="comment">//创建一个新的节点对象</span></span><br><span class="line">        <span class="comment">//让之前单链表的末尾节点next指向新节点对象。</span></span><br><span class="line">        <span class="comment">//有可能这个元素是第一个，也可能是第二个，也可能是第三个。</span></span><br><span class="line">        <span class="keyword">if</span>(header == nu11)&#123;</span><br><span class="line">        <span class="comment">//说明还没有节点。</span></span><br><span class="line">        <span class="comment">//new一个新的节点对象，作为头节点对象。</span></span><br><span class="line">        <span class="comment">//这个时候的头节点既是一个头节点，又是一个末尾节点。</span></span><br><span class="line">            header = <span class="keyword">new</span> <span class="title class_">Node</span>(data,next: nu11);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//说明头不是空!</span></span><br><span class="line">            <span class="comment">//头节点已经存在了!</span></span><br><span class="line">            <span class="comment">//找出当前末尾节点，让当前末尾节点的next是新节点。</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">currentLastNode</span> <span class="operator">=</span> findLast();</span><br><span class="line">            currentLastNode.next = <span class="keyword">new</span> <span class="title class_">Node</span>(data，next: nu11);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *专门查找末尾节点的方法。 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">NodefindLast</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(node.next心== nu11) &#123;</span><br><span class="line">            <span class="comment">//如果一个节点的next是null</span></span><br><span class="line">            <span class="comment">//说明这个节点就是末尾节点。</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//程序能够到这里说明: node不是末尾节点。</span></span><br><span class="line">        <span class="keyword">return</span> findLast( node.next); <span class="comment">//递归算法</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//删除链表中某个数据的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(object obj)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改链表中某个数据的方法</span></span><br><span class="line">    pubiic <span class="keyword">void</span> <span class="title function_">modify</span><span class="params">(object newObj)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找链表中某个元素的方法。</span></span><br><span class="line">    pubiic <span class="type">int</span> <span class="title function_">find</span><span class="params">(object obj)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="链表的优点"><a href="#链表的优点" class="headerlink" title="链表的优点:"></a>链表的优点:</h4><p>由于<strong>链表上的元素在空间存储上内存地址不连续。</strong><br>所以随机增删元素的时候不会有大量元素位移，因此随机增删效率较高。</p><p>在以后的开发中，如果遇到随机增删集合中元素的业务比较多时，建议使用LinkedList。</p><h4 id="链表的缺点"><a href="#链表的缺点" class="headerlink" title="链表的缺点:"></a>链表的缺点:</h4><p>不能通过数学表达式计算被查找元素的内存地址，每一次查找都是从头节点开始逼历，直到找到为止。所以LinkedList集合检索&#x2F;查找的效率较低。<br>ArrayList :把检索发挥到极致。(（末尾添加元素效率还是很高的)</p><p>LinkedList :把随机增删发挥到极致。<br>加元素都是往末尾添加，所以ArrayList用的比LinkedList多。</p><h2 id="11-双向链表"><a href="#11-双向链表" class="headerlink" title="11.双向链表"></a>11.双向链表</h2><p><img src="/2022/09/21/%E9%9B%86%E5%90%88/8.png" alt="image-20221006172607849"></p><h2 id="12-Vector"><a href="#12-Vector" class="headerlink" title="12.Vector"></a>12.Vector</h2><p>1、底层也是一个数组。</p><p>2、初始化容量:10</p><p>3、怎么扩容的?<br>扩容之后是原容量的2倍。10–&gt;20 –&gt;40 –&gt; 80</p><p>4、ArrayList集合扩容特点:<br>ArrayList集合扩容是原容量1.5倍。</p><p>5,Vector中所有的方法都是线程同步的，都带有synchronized关键字，是线程安全的。效率比较低，使用较少了。</p><p>6、怎么将一个线程不安全的Arraylist集合转换威线程安全的呢?<br>    使用集合工具类:<br>            java. util.collections;</p><p>​java.util.collection是集合接口。</p><p>​java.util.collections是集合工具类。</p><h2 id="13-forEach"><a href="#13-forEach" class="headerlink" title="13.forEach"></a>13.forEach</h2><p>jdk5.0新特性</p><p>增强for ( foreach )</p><p><strong>以下是语法</strong></p><p>for(元秦类型变量名∶数组或集合){<br>        System.out.printLn(变量名);</p><p>​}</p><h4 id="缺点：没有下标"><a href="#缺点：没有下标" class="headerlink" title="缺点：没有下标"></a>缺点：没有下标</h4><p>在需要使用下标的循环中，不建议使用增强for循环。</p><h2 id="14-HashSet"><a href="#14-HashSet" class="headerlink" title="14.HashSet"></a>14.HashSet</h2><p>无序不可重复</p><h2 id="15-TreeSet"><a href="#15-TreeSet" class="headerlink" title="15.TreeSet"></a>15.TreeSet</h2><p>1、无序不可重复的，但是存储的元素可以自动按照大小顺序排序!称为:可排序集合。</p><p>2、无序:这里的无序指的是存进去的顺序和取出来的顺序不同。并且没有下标。</p><h2 id="16-Map接口常用方法"><a href="#16-Map接口常用方法" class="headerlink" title="16.Map接口常用方法"></a>16.Map接口常用方法</h2><p>java.util.Map接口中常用的方法∶</p><p>​1、<strong>Map和collection没有继承关系。</strong><br>​2、<strong>Map集合以key和value的方式存储数据:键值对</strong><br>**key和value都是引用数据类型。**<br>​key和value都是存储对象的内存地址。<br>​<strong>key起到主导的地位，value是key的一个附属品。</strong></p><p>​3、Map接口中常用方法:</p><ul><li><p>V  put(K key,V value)向Map集合中添加键值对</p></li><li><p>V get(Object key)通过key获取value</p></li><li><p>void clear()清空Map集合</p></li><li><p>boolean containsKey(object key)       判断Map中是否包含某个key</p></li><li><p>boolean containsValue(object value)判断Map中是否包含某个value </p></li><li><p>boolean isEmpty()         判断Map集合中元素个数是否为0</p></li><li><p>Set<K> keySet()获取Map集合所有的key (所有的键是一个set集合)</K></p></li><li><p>V   remove(object key)通过key删除键值对</p></li><li><p>int size(）获取Map集合中键值对的个数。</p></li><li><p>Collection<V> values(）获取Map集合中所有的value ，返回一个collection</V></p></li><li><p>Set&lt;Map.Entry&lt;K,V&gt;&gt;  entrySet(）将Map集合转换成Set集合</p></li></ul><p>将Map集合转换成set集合<br>假设现在有一个Map集合，如下所示:<br>map1集合对象</p><p>keyvalue</p><hr><p>1zhangsan<br>2lisi<br>3wangwu<br>4zhaoliu<br>Set set &#x3D; map1.entrySet( );</p><p>set集合对象</p><p>​1&#x3D;zhangsan【注意:Map集合通过entrySet()方法转换成的这个set集合，**Set集合中元素的类型是Map.Entry&lt;K,V&gt;**】</p><p>​2&#x3D;Lisi【<strong>Map.Entry和string一样，都是一种类型的名字，只不过Map.Entry是静态内部类，是Map中的静态内部类</strong>】</p><p>​3&#x3D;wangwu</p><p>​4&#x3D;zhaoliu</p><p><strong>注意：</strong>这种方式效率比较高，因为获取key和value都是亘接从node对象中获取的属性值。这种方式比较适合于大数据量。</p><p>遍历Set集合，取出每一个<strong>Map.Entry&lt;K,V&gt;（node）对象</strong></p><ul><li>迭代器</li><li>forEach</li><li><strong>相信不用我说了把，看下图，你懂的</strong></li></ul><p><img src="/2022/09/21/%E9%9B%86%E5%90%88/10.png" alt="image-20221006190346686"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//是Map中的静态内部类   例子</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="comment">//声明一个静态内部类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.print1n(<span class="string">&quot;静态内部类的m1方法执行&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//实例方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态内部类中的实例方法执行!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span> i</span><br><span class="line">    MyClass.InnerClass.m1();</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//创建静态内部类对象</span></span><br><span class="line">   MyClass.<span class="type">InnerClass</span> <span class="variable">mi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>.InnerClass();</span><br><span class="line">    mi.m2();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 可以把key和V单独<strong>全部</strong>拿出来</p><p><img src="/2022/09/21/%E9%9B%86%E5%90%88/9.png" alt="image-20221006190015271"></p><h2 id="17-哈希表"><a href="#17-哈希表" class="headerlink" title="17.哈希表"></a>17.哈希表</h2><p><img src="/2022/09/21/%E9%9B%86%E5%90%88/11.png" alt="image-20221006190846701"></p><p>1、HashMap集合底层是哈希表&#x2F;散列表的数据结构。</p><p>2、哈希表是一个怎样的数据结构呢?<br>哈希表是一个数组和单向链表的结合体。<br>数组∶在查询方面效率很高，随机增删方面效率很低。<br>单向链表:在随机增删方面效率较高，在查询方面效率很低。</p><p><strong>哈希表将以上的两种数据结构融合在一起，充分发挥它们各自的优点。</strong></p><p>3、HashMap集合底层的源代码∶</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&#123;</span><br><span class="line"><span class="comment">//HashMap底层实际上就是一个数组。(一维数组)</span></span><br><span class="line"></span><br><span class="line">Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态的内部类HashMap.Node</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> hash;<span class="comment">//哈希值（哈希值是key的hashCode()方法的执行结果。hash值通过哈希函数/算法，可以转换存储成数组的下标。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> K key;<span class="comment">//存储到map中的那个key</span></span><br><span class="line"></span><br><span class="line">V value;<span class="comment">//存储到map集合中的那个value</span></span><br><span class="line">Node&lt;K,V&gt; next;<span class="comment">//下一个节点的内存地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>哈希表&#x2F;散列表:一维数组，这个数组中每一个元素是一个单向链表。(数组和链表的结合体。)</strong></p><p>4、HashMap集合的key部分特点:<br>无序，不可重复。<br>为什么无序?因为不一定挂到哪个单向链表上。<br>不可重复是怎么保证的? equals方法来保证HashMap集合的key不可重复。如果key重复了，value会覆盖。<br>放在HashMap集合key部分的元素其实就是放到HashSet集合中了。<br>所以HashSet集合中的元素也需要同时重写hashCode( )+equals( )方法。</p><p>5、哈希表HashMap使用不当时无法发挥性能!<br>假设将所有的hashCode()方法返回值固定为某个值，那么会导致底层哈希表变成了纯单向链表。这种情况我们成为:散列分布不均匀。<br>什么是散列分布均匀?<br>假设有100个元素，10个单向链表，那么每个单向链表上有10个节点，这是最好的，是散列分布均匀的。<br>假设将所有的hashcode()方法返回值都设定为不一样的值，可以吗，有什么问题?<br>不行，因为这样的话导致底层哈希表就成为一维数组了，没有链表的概念了。也是散列分布不均匀。<br>散列分布均匀需要你重写hashcode()方法时有一定的技巧。</p><p>7、重点∶放在HashMap集合key部分的元素，以及放在HashSet集合中的元素，需要同时重写nashCode和equaLs方法。</p><p>8、HashMap集合的默认初始化容量是16，默认加载因子是0.75<br>这个默认加载因子是当HashMap集合底层数组的容量达到75%的时候，数组开始扩容。</p><p><strong>重点记住:</strong>HasnMap集合初始化容量必须是z的倍数.这也是宫方椎荐的这是因为达到散列均匀.为了提高HashMap集合的存取效率，丽必须的。</p><p><img src="/2022/09/21/%E9%9B%86%E5%90%88/12.png" alt="image-20221006192839988"></p><p><img src="/2022/09/21/%E9%9B%86%E5%90%88/13.png" alt="image-20221006200537157"></p><h2 id="18-补充一下hasCode方法"><a href="#18-补充一下hasCode方法" class="headerlink" title="18.补充一下hasCode方法"></a>18.补充一下hasCode方法</h2><p>hashCode方法:<br>在object中的hashCode方法是怎样的?<br>public native int hashCode ( ) ;<br>这个方法不是抽象方法，<strong>带有native关键字，底层调用C++程序。</strong><br>hashCode ()方法返回的是哈希码:<br>实际上就是一个java对象的内存地址，经过哈希算法，<strong>得出的一个值所以hashCode ()方法的执行结果可以等同看做一个java对象的内存地址</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">hashCode方法:</span></span><br><span class="line"><span class="comment">在object中的hashCode方法是怎样的?</span></span><br><span class="line"><span class="comment">public native int hashCode ( ) ;</span></span><br><span class="line"><span class="comment">这个方法不是抽象方法，带有native关键字，底层调用C++程序。</span></span><br><span class="line"><span class="comment">hashCode ()方法返回的是哈希码:</span></span><br><span class="line"><span class="comment">实际上就是一个java对象的内存地址，经过哈希算法，得出的一个值所以hashCode ()方法的执行结果可以等同看做一个java对象的内存地址。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test07</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(string[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>() ;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hashCodevalue</span> <span class="operator">=</span> o.hashCode ( ) ;</span><br><span class="line">        <span class="comment">//对象内存地址经过哈希算法转换的一个数字。可以等同看做内存地址</span></span><br><span class="line">        System. out.println(hashCodeValue) ; <span class="comment">//798154996</span></span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">mc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span> () ;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hashCodevalue2</span> <span class="operator">=</span> mc. hashCode () ;</span><br><span class="line">        System.out.println (hashCodevalue2) ; <span class="comment">//1392838282</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="19-HashMap-和HashTable的区别"><a href="#19-HashMap-和HashTable的区别" class="headerlink" title="19.HashMap 和HashTable的区别"></a>19.HashMap 和HashTable的区别</h2><p>1、Hashtable的key可以为nuLl吗?</p><ul><li><strong>HashtabLe的key和value都是不能为null的。</strong></li><li><strong>HashMap集合的key和vaLue都是可以为nuLl的。</strong></li></ul><p>2、<strong>Hashtable方法都带有synchronized :线程安全的</strong>。线程安全有其它的方案，这个Hashtable对线程的处理导致效率较低，使用较少了。</p><p>3、Hashtable和NHashMap一样，底层都是哈希表数据结构。Heshtable的初始化容量是11，默认加载因子是;0.75fHashtabLe的扩容是:原容量*2+1</p><h2 id="20-Properties"><a href="#20-Properties" class="headerlink" title="20.Properties"></a>20.Properties</h2><p>目前只需要掌握Properties属性类对象的相关方法即可。</p><p>Properties是一个Map集合，继承Hashtable , Properties的key和value都是String类型。</p><p>Properties被称为属性类对象。</p><p>Properties是线程安全的。</p><h2 id="21-TreeSet"><a href="#21-TreeSet" class="headerlink" title="21.TreeSet"></a>21.TreeSet</h2><p>1、TreeSet集合底层实际上是一个TreeMap</p><p>2、<strong>TreeMap集合底层是一个二叉树。</strong></p><p>3、<strong>放到TreeSet集合中的元素，等同于放到TreeMap集合key部分了。</strong></p><p>4、TreeSet集合中的元素:无序不可重复，但是可以按照元素的大小顺序自动排序。称为:可排序集合。</p><p>5、<strong>对自定义的类型来说，TreeSet可以排序吗?</strong><br>    以下程序中对于Person类型来说，无法排序。因为没有指定Person对象之间的比较规则。谁大谁小并没有说明啊。<br>    以下程序运行的时候出现了这个异常:<br>    java.Lang.CLasscastException :<br>    class com.bjpowernode.javase.colLection .Personcannot be cast to class java.Lang. Comparable<br>    出现这个异常的原因是:<br>    <strong>Person类没有实现java .Lang . Comparable接口。</strong></p><p><strong>故在TreeSet集合中的元素需要实现java.Lang . Comparable接口。</strong></p><p>并且实现compareTo方法。equals可以不写。</p><p>需要在这个方法中编写比较的逻辑，或者说比较的规则，按照什么进行比较!l &#x2F; k.compareTo(t.key )<br>拿着参数k和集合中的每一个k进行比较，返回值可能是&gt;0 &lt;0 &#x3D;0<br><strong>比较规则最终还是由程序员指定的∶例如按照年龄升序。或者按照年龄降序。</strong></p><p><strong>TreeSet集合中元素可排序的第二种方式:使用比较器的方式。</strong></p><p>TreeSet集合中元素可排序的第二种方式:使用比较器的方式。</p><p>最终的结论:<br>放到TreeSet或者TreeMap集合key部分的元素要想做到排序,包括两种方式:</p><ul><li>第一种:放在集合中的元素实现java .lang . Comparable接口。</li><li>第二种:在构造TreeSet或者TreeMap集合的时候给它传一个比较器对象。</li></ul><p>ComparabLe和Comparator怎么选择呢?</p><p>当比较规则不会发生改变的时候，或者说当比较规则只有1个的时候，建议实现comparable接口。如果比较规则有多个，并且需要多个比较规则之间频繁切换，建议使用Ccomparator接口。<br>comparator接的设计符合OCP原则。|</p><h2 id="22-二叉树"><a href="#22-二叉树" class="headerlink" title="22.二叉树"></a>22.二叉树</h2><p><img src="/2022/09/21/%E9%9B%86%E5%90%88/14.png" alt="image-20221006203637876"></p><h2 id="23-集合工具类"><a href="#23-集合工具类" class="headerlink" title="23.集合工具类"></a>23.集合工具类</h2><p>java.utiL.Collection集合接口<br>java.utiL.<strong>CoLlections</strong>集合工具类，方便集合的操作。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Collection </tag>
            
            <tag> Map </tag>
            
            <tag> 集合 </tag>
            
            <tag> List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务</title>
      <link href="/2022/09/20/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
      <url>/2022/09/20/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><h3 id="1-本地事务"><a href="#1-本地事务" class="headerlink" title="1.本地事务"></a>1.本地事务</h3><h5 id="事务特性（ACID）"><a href="#事务特性（ACID）" class="headerlink" title="事务特性（ACID）"></a>事务特性（ACID）</h5><p>原子性、一致性、隔离性和持久性</p><p>原子性：一系列的操作整体不可拆分，要么同时成功，要么同时失败</p><p>一致性：数据库总是从一个一致性的状态转换到另一个一致性的状态。事务的一致性决定了一个系统设计和实现的复杂度，也导致了事务的不同隔离级别。</p><p>事务可以不同程度的一致性：</p><ul><li>强一致性：读操作可以立即读到提交的更新操作。</li><li>弱一致性：提交的更新操作，不一定立即会被读操作读到，此种情况会存在一个不一致窗口，指的是读操作可以读到最新值的一段时间</li><li>最终一致性：是弱一致性的特例。事务更新一份数据，最终一致性保证在没有其他事务更新同样的值的话，最终所有的事务都会读到之前事务更新的最新值。如果没有错误发生，不一致窗口的大小依赖于：通信延迟，系统负载等。</li></ul><p>隔离性：并发事务之间互相影响的程度，比如一个事务会不会读取到另一个未提交的事务修改的数据</p><p>持久性：一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。持久性是个有点模糊的概念，因为实际上持久性也分很多不同的级别。有些持久性策略能够提供非常强的安全保障，而有些则未必。而且不可能有能做到100%的持久性保证策略。</p><p>在事务并发操作时，可能出现的问题有：</p><ul><li><p>脏读：事务A修改了一个数据，但未提交，事务B这时来读数据，读到A未提交的数据，称为脏读。</p><table><thead><tr><th>时间顺序</th><th>转账事务</th><th>取款事务</th></tr></thead><tbody><tr><td>1</td><td></td><td>开始事务</td></tr><tr><td>2</td><td>开始事务</td><td></td></tr><tr><td>3</td><td></td><td>查询账户余额为2000元</td></tr><tr><td>4</td><td></td><td>取款一千元，余额被更改为1000元</td></tr><tr><td>5</td><td></td><td></td></tr><tr><td>6</td><td>查询账户余额，查到1000元（脏读）</td><td></td></tr><tr><td>7</td><td></td><td>取款操作发生未知错误，事务回滚，余额变回2000元</td></tr><tr><td>8</td><td>转入2000元，余额被更改为3000元（脏读的1000元+ 2000元）</td><td></td></tr></tbody></table><table><thead><tr><th>备注</th><th>按照正确逻辑，此时余额应为4000元</th></tr></thead></table></li><li><p>不可重复读：在事务A中，需要多次读小明年龄20岁这一数据，事务尚未结束，此时事务B修改小明年龄为30岁，导致事务A第二次读取小明年龄为30岁数据不重复了，即系统不能够读取到重复的数据，称为不可重复读</p><table><thead><tr><th>时间顺序</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>1</td><td>开始事务</td><td></td></tr><tr><td>2</td><td>第一次查询，小明年龄为20岁</td><td></td></tr><tr><td>3</td><td></td><td>开始事务</td></tr><tr><td>4</td><td>其他操作</td><td></td></tr><tr><td>5</td><td></td><td>更改小明年龄为30岁</td></tr><tr><td>6</td><td></td><td>提交事务</td></tr><tr><td>7</td><td>第二次查询，小明年龄为30岁</td><td></td></tr></tbody></table><table><thead><tr><th>备注</th><th>按照正常逻辑，事务A前后读取到的数据应该一致，即小明年龄应该为20岁</th></tr></thead></table></li><li><p>幻读：事务A在执行统计操作，需要统计数据的总量，前一次查询数据总量后，此时事务B执行了新增或删除操作，这个时候事务A读取到的事务总量和之前统计的不一样，就像产生了幻觉一样，称为幻读</p><table><thead><tr><th align="left">时间顺序</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td align="left">1</td><td>开始事务</td><td></td></tr><tr><td align="left">2</td><td>第一次查询，数据总量为100条</td><td></td></tr><tr><td align="left">3</td><td></td><td>开始事务</td></tr><tr><td align="left">4</td><td>其他操作</td><td></td></tr><tr><td align="left">5</td><td></td><td>新增100条数据</td></tr><tr><td align="left">6</td><td></td><td>提交事务</td></tr><tr><td align="left">7</td><td>第二次查询，数据总量为200条</td><td></td></tr></tbody></table><table><thead><tr><th>备注</th><th>按照正常逻辑，事务A前后两次读取到的数据总量应该一致</th></tr></thead></table></li></ul><h5 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h5><ul><li>READ UNCOMMITTED（读未提交）：该隔离级别的事务会读到其它未提交事务的数据， 此现象也称之为脏读。</li><li>READ COMMITTED（ 读提交）：一个事务可以读取另一个已提交的事务， 多次读取会造成不一样的结果， 此现象称为不可重复读问题， Oracle 和 SQL Server 的默认隔离级别。</li><li>REPEATABLE READ（ 可重复读）：该隔离级别是 MySQL 默认的隔离级别， 在同一个事务里， select 的结果是事务开始时时间点的状态， 因此， 同样的 select 操作读到的结果会是一致的， 但是， 会有幻读现象。 MySQL的 InnoDB 引擎可以通过 next-key locks 机制（ 参考下文”行锁的算法”一节） 来避免幻读。</li><li>SERIALIZABLE（ 序列化）：在该隔离级别下事务都是串行顺序执行的， MySQL 数据库的 InnoDB 引擎会给读操作隐式加一把读共享锁， 从而避免了脏读、 不可重读复读和幻读问题</li></ul><h5 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h5><ul><li>PROPAGATION_REQUIRED： 如果当前没有事务， 就创建一个新事务， 如果当前存在事务，就加入该事务， 该设置是最常用的设置</li><li>PROPAGATION_SUPPORTS： 支持当前事务， 如果当前存在事务， 就加入该事务， 如果当前不存在事务， 就以非事务执行。</li><li>PROPAGATION_MANDATORY： 支持当前事务， 如果当前存在事务， 就加入该事务， 如果当前不存在事务， 就抛出异常。</li><li>PROPAGATION_REQUIRES_NEW： 创建新事务， 无论当前存不存在事务， 都创建新事务。</li><li>PROPAGATION_NOT_SUPPORTED： 以非事务方式执行操作， 如果当前存在事务， 就把当前事务挂起</li><li>PROPAGATION_NEVER： 以非事务方式执行， 如果当前存在事务， 则抛出异常。</li><li>PROPAGATION_NESTED： 如果当前存在事务， 则在嵌套事务内执行。 如果当前没有事务，则执行与PROPAGATION_REQUIRED 类似的操作。</li></ul><h3 id="2、本地事务在分布式下的问题"><a href="#2、本地事务在分布式下的问题" class="headerlink" title="2、本地事务在分布式下的问题"></a>2、本地事务在分布式下的问题</h3><p>业务描述： 在一个大事务下，需要本地创建订单，远程调用库存服务来查询库存和锁定库存，远程查询优惠信息，扣减积分。</p><p><img src="/2022/09/20/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20220919221259619.png" alt="image-20220919221259619"></p><h5 id="本地事务能够解决"><a href="#本地事务能够解决" class="headerlink" title="本地事务能够解决"></a>本地事务能够解决</h5><p>创建订单出现异常，本地事务回滚；</p><p>远程查询库存，或远程查积分出现异常，本地事务回滚；</p><h5 id="本地事务不能解决"><a href="#本地事务不能解决" class="headerlink" title="本地事务不能解决"></a>本地事务不能解决</h5><ol><li>远程服务假失败，创建订单成功，远程查询库存锁定库存成功，但是由于网络问题，导致没有远程库存服务返回出现异常，本地事务回滚，即订单回滚，但是，远程库存事务是执行成功了，并没有回滚，导致库存扣减成功，订单却没有创建。</li><li>创建订单成功，远程查询库存锁库存成功，但是远程查积分出错，回滚，导致返回发生异常，导致本地事务回滚，订单属于本地事务，回滚，但是库存事务不在本地，不能回滚，所以又导致了导致库存扣减成功，订单却没有创建。</li></ol><p>订单服务连接的是订单数据库，这是一个连接，库存服务连接的是库存数据库，这是一个新的连接，会员服务链接的是会员数据库，这也是一个新的连接。远程调用实际上是一个新的连接，会员服务发生异常，库存服务是感知不到的，已经执行成功的请求是不能回滚的。</p><p>远程服务假失败：远程服务其实成功了，由于网络故障等没有返回，导致：订单回滚，库存却扣减<br>远程服务执行完成，下面的其他方法出现问题，导致：已执行的远程请求，肯定不能回滚</p><p>本地事务只能控制住在同一个连接中的异常，在分布式系统中，A服务远程调用B服务，B服务远程调用C服务，C服务远程调用D服务，任何一个远程服务出现问题，已经成功执行的远程服务没办法通过Transactional来实现事务的回滚，除非这几个服务不是远程服务，操作的是同一个数据库，在同一个连接内。</p><p>本地事务在分布式系统下，只能控制住自己数据库的回滚，控制不了其他服务的数据库的回滚。分布式事务的问题：网络问题+分布式机器（数据库不是同一个）。</p><h3 id="3、分布式事务"><a href="#3、分布式事务" class="headerlink" title="3、分布式事务"></a>3、分布式事务</h3><h5 id="1、为什么有分布式事务？"><a href="#1、为什么有分布式事务？" class="headerlink" title="1、为什么有分布式事务？"></a>1、为什么有分布式事务？</h5><p>分布式系统经常出现的异常：机器宕机、 网络异常、 消息丢失、 消息乱序、 数据错误、 不可靠的 TCP、 存储数据丢失 。。。。。由于以上问题都会导致分布式系统下，某一个服务的状态不能被其他服务感知到。</p><p>分布式事务是企业集成中的一个技术难点， 也是每一个分布式系统架构中都会涉及到的一个东西， 特别是在微服务架构中， 几乎可以说是无法避免。</p><h5 id="2、CAP-定理"><a href="#2、CAP-定理" class="headerlink" title="2、CAP 定理"></a>2、CAP 定理</h5><p>CAP 原则又称 CAP 定理， 指的是在一个分布式系统中。</p><p>一致性 ：在分布式系统中的所有数据备份， 在同一时刻是否都有同样的值。<br>可用性 ：在集群中一部分节点故障后， 集群整体是否还能响应客户端的读写请求。<br>分区容错性 ：大多数分布式系统都分布在多个子网络。 每个子网络就叫做一个区 。分区容错的意思是， 区间通信可能失败。 比如， 一台服务器放在中国， 另一台服务器放在美国， 这就是两个区， 它们之间可能无法通信。</p><p>CAP 原则指的是， 这三个要素最多只能同时实现两点， 不可能三者兼顾。</p><p>一般来说， 分区容错无法避免， 因此CAP 的 P 总是成立。 CAP 定理告诉我们，剩下的 C 和 A 无法同时做到。</p><p>分布式系统中实现一致性的 raft 算法：<a href="http://thesecretlivesofdata.com/raft/">http://thesecretlivesofdata.com/raft/</a> （领导选举，日志复制）</p><h5 id="3、base理论"><a href="#3、base理论" class="headerlink" title="3、base理论"></a>3、base理论</h5><p>对于多数大型互联网应用的场景， 主机众多、 部署分散， 而且现在的集群规模越来越大， 所以节点故障、 网络故障是常态， 而且要保证服务可用性达到 99.99999%（N 个 9） ， 即保证P 和 A， 舍弃 C。</p><p>是对 CAP 理论的延伸， 思想是即使无法做到强一致性（CAP 的一致性就是强一致性） ， 但可以采用适当的采取弱一致性， 即最终一致性</p><p>① 基本可用（Basically Available）：</p><p>基本可用是指分布式系统在出现故障的时候， 允许损失部分可用性（例如响应时间、功能上的可用性） ， 允许损失部分可用性。 需要注意的是， 基本可用绝不等价于系统不可用。</p><p>响应时间上的损失： 正常情况下搜索引擎需要在 0.5 秒之内返回给用户相应的查询结果， 但由于出现故障（比如系统部分机房发生断电或断网故障） ， 查询结果的响应时间增加到了 1~2 秒。</p><p>功能上的损失： 购物网站在购物高峰（如双十一） 时， 为了保护系统的稳定性，部分消费者可能会被引导到一个降级页面。</p><p>② 软状态（ Soft State）:</p><p>软状态是指允许系统存在中间状态， 而该中间状态不会影响系统整体可用性。 分布式存储中一般一份数据会有多个副本， 允许不同副本同步的延时就是软状态的体现。 mysql replication 的异步复制也是一种体现。</p><p>③ 最终一致性（ Eventual Consistency）:</p><p>最终一致性是指系统中的所有数据副本经过一定时间后， 最终能够达到一致的状态。 弱一致性和强一致性相反， 最终一致性是弱一致性的一种特殊情况</p><p>从客户端角度， 多进程并发访问时， 更新过的数据在不同进程如何获取的不同策略， 决定了不同的一致性。 对于关系型数据库， 要求更新过的数据能被后续的访问都能看到， 这是强一致性。 如果能容忍后续的部分或者全部访问不到， 则是弱一致性。 如果经过一段时间后要求能访问到更新后的数据， 则是最终一致性 。</p><h5 id="4、分布式事务常见解决方案"><a href="#4、分布式事务常见解决方案" class="headerlink" title="4、分布式事务常见解决方案"></a>4、分布式事务常见解决方案</h5><p>1、2PC 模式</p><p>数据库支持的 2PC【 2 phase commit 二阶提交】 ， 又叫做 XA Transactions。其中， XA 是一个两阶段提交协议， 该协议分为以下两个阶段：<br>第一阶段： 事务协调器要求每个涉及到事务的数据库预提交(precommit)此操作， 并反映是否可以提交。<br>第二阶段： 事务协调器要求每个数据库提交数据。<br>其中， 如果有任何一个数据库否决此次提交， 那么所有数据库都会被要求回滚它们在此事务中的那部分信息 。</p><p>XA 协议比较简单， 而且一旦商业数据库实现了 XA 协议， 使用分布式事务的成本也比较低。<br>XA 性能不理想， 特别是在交易下单链路， 往往并发量很高， XA 无法满足高并发场景<br>XA 目前在商业数据库支持的比较理想， 在 mysql 数据库中支持的不太理想， mysql 的<br>XA 实现， 没有记录 prepare 阶段日志， 主备切换回导致主库与备库数据不一致。<br>许多 nosql 也没有支持 XA， 这让 XA 的应用场景变得非常狭隘。</p><p>2、柔性事务-TCC 事务补偿型方案</p><p>刚性事务： 遵循 ACID 原则， 强一致性。<br>柔性事务： 遵循 BASE 理论， 最终一致性；<br>与刚性事务不同， 柔性事务允许一定时间内， 不同节点的数据不一致， 但要求最终一致。</p><p>一阶段 prepare 行为： 调用 自定义 的 prepare 逻辑。<br>二阶段 commit 行为： 调用 自定义 的 commit 逻辑。<br>二阶段 rollback 行为： 调用 自定义 的 rollback 逻辑。<br>所谓 TCC 模式， 是指支持把 自定义 的分支事务纳入到全局事务的管理中。</p><p>3、柔性事务-最大努力通知型方案</p><p>按规律进行通知， 不保证数据一定能通知成功， 但会提供可查询操作接口进行核对。 这种方案主要用在与第三方系统通讯时， 比如： 调用微信或支付宝支付后的支付结果通知。 这种方案也是结合 MQ 进行实现， 例如： 通过 MQ 发送 http 请求， 设置最大通知次数。 达到通知次数后即不再通知。</p><p>案例： 银行通知、 商户通知等（ 各大交易业务平台间的商户通知： 多次通知、 查询校对、 对账文件） ，支付宝的支付成功异步回调</p><p>4、柔性事务-可靠消息+最终一致性方案（ 异步确保型）</p><p>实现： 业务处理服务在业务事务提交之前， 向实时消息服务请求发送消息， 实时消息服务只记录消息数据， 而不是真正的发送。 业务处理服务在业务事务提交之后， 向实时消息服务确认发送。 只有在得到确认发送指令后， 实时消息服务才会真正发送。</p><h3 id="4、分布式事务Seata"><a href="#4、分布式事务Seata" class="headerlink" title="4、分布式事务Seata"></a>4、分布式事务Seata</h3><p>Seata使用的是2PC模式</p><p>TC负责协调全局、TM用来控制整个大的事务、每个微服务中使用RM这个资源管理器来控制</p><p>① TM（大事务）首先会告诉TC，准备开启一个全局事务</p><p>② TM调用远程服务后，不论是成功还是失败，TC都知道</p><p>③ 假如一个小事务出现异常回滚了，那么之前成功的事务也要回滚</p><p><img src="/2022/09/20/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/1.png" alt="1"></p><h5 id="整合Seata"><a href="#整合Seata" class="headerlink" title="整合Seata"></a>整合Seata</h5><p>1、为每一个需要使用Seata的服务创建一个undo_log表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `undo_log` (</span><br><span class="line">  `id` bigint(20) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `branch_id` bigint(20) NOT NULL,</span><br><span class="line">  `xid` varchar(100) NOT NULL,</span><br><span class="line">  `context` varchar(128) NOT NULL,</span><br><span class="line">  `rollback_info` longblob NOT NULL,</span><br><span class="line">  `log_status` int(11) NOT NULL,</span><br><span class="line">  `log_created` datetime NOT NULL,</span><br><span class="line">  `log_modified` datetime NOT NULL,</span><br><span class="line">  `ext` varchar(100) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `ux_undo_log` (`xid`,`branch_id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><p>2、在每个需要使用Seata的微服务<code>spring-cloud-starter-alibaba-seata</code></p><p>3、安装Seata服务器（TC）<strong>注意：要与导入依赖版本对应</strong></p><p>4、在服务器文件目录下修改<code>registry.conf</code>，指明seata配置中心地址为nacos </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">registry &#123;</span><br><span class="line"></span><br><span class="line">  # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa </span><br><span class="line"></span><br><span class="line">  type = &quot;nacos&quot;</span><br><span class="line"></span><br><span class="line">  nacos &#123;</span><br><span class="line">    serverAddr = &quot;localhost:8848&quot;</span><br><span class="line">    namespace = &quot;public&quot;</span><br><span class="line">    cluster = &quot;default&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、为每个需要使用Seata的微服务注入DataSourceProxy数据源，因为Seata是通过代理数据源实现分支事务</p><p>6、每个需要用分布式事务的微服务都必须导入file.conf和registry.conf ,（gulimall-order和gulimall-ware）且 file.conf 的 service.vgroup_mapping 配置必须和spring.application.name一致</p><p>因为每个服务默认会使用 ${spring.application.name}-fescar-service-group作为服务名注册到 Seata Server上，如果和file.conf中的配置不一致，会提示 no available server to connect 错误</p><p>也可以通过配置 spring.cloud.alibaba.seata.tx-service-group 修改后缀，但是必须和file.conf 中的配置保持一致</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">service</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># vgroup-&gt;rgroup</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># vgroup_mapping.my_test_tx_group = &quot;default&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">vgroup_mapping.gulimall-order-fescar-service-group</span> <span class="string">=</span> <span class="string">&quot;default&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">service</span> &#123;  </span><br><span class="line"></span><br><span class="line"><span class="comment">#vgroup-&gt;rgroup  </span></span><br><span class="line"></span><br><span class="line"><span class="string">vgroup_mapping.gulimall-ware-fescar-service-group</span>  <span class="string">=</span> <span class="string">&quot;default&quot;</span> </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7、在大事务上添加注解<code>@GlobalTransactional</code>    <strong>不要忘了</strong></p><h3 id="5、柔性事务-可靠消息-最终一致性方案（-异步确保型）"><a href="#5、柔性事务-可靠消息-最终一致性方案（-异步确保型）" class="headerlink" title="5、柔性事务-可靠消息+最终一致性方案（ 异步确保型）"></a><strong>5、柔性事务-可靠消息+最终一致性方案（ 异步确保型）</strong></h3><p>Seata存在的问题： 使用了Seata主推的AT（Auto Transaction）模式，使用了各种锁，效率低，不适合高并发下使用。</p><p>所以在高并发下推荐使用——柔性事务-最大努力通知型方案 或 柔性事务-可靠消息+最终一致性方案（ 异步确保型）</p><p><img src="/2022/09/20/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/2.png" alt="2"></p><h4 id="RabbitMQ延时队列"><a href="#RabbitMQ延时队列" class="headerlink" title="RabbitMQ延时队列"></a>RabbitMQ延时队列</h4><p>场景：比如未付款订单，超过一定时间后，系统自动取消订单并释放占有物品。<br>常用解决方案：spring的 schedule 定时任务轮询数据库<br>缺点：消耗系统内存、增加了数据库的压力、存在较大的时间误差<br>解决：RabbitMQ的消息TTL和死信Exchange结合</p><p><img src="/2022/09/20/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/3.png" alt="3"></p><h4 id="消息和队列TTL（Time-To-Leave）"><a href="#消息和队列TTL（Time-To-Leave）" class="headerlink" title="消息和队列TTL（Time To Leave）"></a>消息和队列TTL（Time To Leave）</h4><ul><li>RabbitMQ可以对消息或队列设置TTL</li><li>死信：TTL清零，即消息过期了，称为死信</li><li>如果队列和消息都设置了TTL（过期时间），会取其中较小值</li><li>Dead Letter Exchange其实就是一种普通的exchange，和创建其他exchange没有两样。</li></ul><h4 id="延时队列实现方式："><a href="#延时队列实现方式：" class="headerlink" title="延时队列实现方式："></a>延时队列实现方式：</h4><p>方式一：设置队列过期时间（推荐）</p><p><img src="/2022/09/20/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/4.png" alt="4"></p><p>方式二：设置消息过期时间（存在问题，不推荐）</p><p><img src="/2022/09/20/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/5.png" alt="5"></p><p>简化：节省了一个交换机</p><p><img src="/2022/09/20/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/6.png" alt="6"></p><h4 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h4><p>采用方式一设置队列过期时间，重点在设置队列，其他与平时使用没有区别：只需给队列封装如下参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">** x-dead-letter-exchange: order-event-exchange       //队列过期后交给那个交换机  </span><br><span class="line">\* x-dead-letter-routing-key: order.release.order     //过期后交给指定交换机后，在交给队列所使用的路由键</span><br><span class="line">\* x-message-ttl: 60000*//过期时间</span><br></pre></td></tr></table></figure><h4 id="可靠消息"><a href="#可靠消息" class="headerlink" title="可靠消息"></a>可靠消息</h4><p>延时队列必须保证消息的可靠</p><p>1、如何保证消息可靠性-消息丢失</p><p>消息发送出去，由于网络问题没有抵达服务器<br>做好容错方法（try-catch），发送消息可能会网络失败，失败后要有重试机制，可记录到数据库，采用定期扫描重发的方式<br>做好日志记录，每个消息状态是否都被服务器收到都应该记录<br>做好定期重发，如果消息没有发送成功，定期去数据库扫描未成功的消息进行重发<br>消息抵达Broker，Broker要将消息写入磁盘（持久化）才算成功。此时Broker尚未持久化完成，宕机。<br>publisher也必须加入确认回调机制，确认成功的消息，修改数据库消息状态。<br>自动ACK的状态下。消费者收到消息，但没来得及消息然后宕机<br><strong>一定开启手动ACK</strong>，消费成功才移除，失败或者没来得及处理就noAck并重新入队。<br>2、消息重复</p><p>消息消费成功，事务已经提交，ack时，机器宕机。导致没有ack成功，Broker的消息重新由unack变为ready，并发送给其他消费者。<br>消息消费失败，由于重试机制，自动又将消息发送出去。<br>成功消费，ack时宕机，消息由unack变为ready，Broker又重新发送。<br>消费者的业务消费接口应该设计为幂等性的。比如扣库存有工作单的状态标志。<br>使用防重表（redis&#x2F;mysql），发送消息每一个都有业务的唯一标识，处理过就不用处理。<br>rabbitMQ的每一个消息都有redelivered字段，可以获取是否是被重新投递过来的，而不是第一次投递过来的。<br>3、消息积压</p><p>消费者宕机积压<br>消费者消费能力不足积压<br>发送者发送流量太大<br>上线更多的消费者，进行正常消费<br>上线专门的队列消费服务，将消息先批量取出来，记录数据库，离线慢慢处理</p>]]></content>
      
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> RabbitMQ </tag>
            
            <tag> Seata </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
