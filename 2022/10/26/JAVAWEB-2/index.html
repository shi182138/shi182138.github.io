<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>JAVAWEB(2) | Barry</title><meta name="keywords" content="JAVAWEB"><meta name="author" content="Barry"><meta name="copyright" content="Barry"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JAVAWEB">
<meta property="og:type" content="article">
<meta property="og:title" content="JAVAWEB(2)">
<meta property="og:url" content="http://example.com/2022/10/26/JAVAWEB-2/index.html">
<meta property="og:site_name" content="Barry">
<meta property="og:description" content="JAVAWEB">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://w.wallhaven.cc/full/d6/wallhaven-d65dxg.jpg">
<meta property="article:published_time" content="2022-10-26T02:04:19.000Z">
<meta property="article:modified_time" content="2022-10-26T02:40:04.659Z">
<meta property="article:author" content="Barry">
<meta property="article:tag" content="JAVAWEB">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://w.wallhaven.cc/full/d6/wallhaven-d65dxg.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/10/26/JAVAWEB-2/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JAVAWEB(2)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-10-26 10:40:04'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/myfile/1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/myfile/test.html"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://w.wallhaven.cc/full/d6/wallhaven-d65dxg.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Barry</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/myfile/test.html"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JAVAWEB(2)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-10-26T02:04:19.000Z" title="发表于 2022-10-26 10:04:19">2022-10-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-10-26T02:40:04.659Z" title="更新于 2022-10-26 10:40:04">2022-10-26</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JAVAWEB(2)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><h3 id="Servlet对象的生命周期"><a href="#Servlet对象的生命周期" class="headerlink" title="Servlet对象的生命周期"></a>Servlet对象的生命周期</h3><ul>
<li><p>什么是Servlet对象生命周期?</p>
<ul>
<li>Servlet对象什么时候被创建。</li>
<li>Servlet对象什么时候被销毁。</li>
<li>Servlet对象创建了几个?</li>
<li>Servlet对象的生命周期表示:一个Servlet对象从出生在最后的死亡，整个过程是怎样的。</li>
</ul>
</li>
<li><p>Servlet对象是由谁来维护的?</p>
<ul>
<li>Servlet对象的创建，对象上方法的调用，对象最终的销毁，Javaweb程序员是无权干预的。</li>
<li>Servlet对象的生命周期是由Tomcat服务器(WEB Server）全权负责的。</li>
<li>Tomcat服务器通常我们又称为:WEB容器。(这个叫法你要知道【WEB Container】)</li>
<li>WEB容器来管理Servlet对象的死活。</li>
</ul>
</li>
<li><p>思考:我们自己new的Servlet对象受WEB容器的管理吗?</p>
<ul>
<li>我们自己new的Servlet对象是不受WEB容器管理的。</li>
<li>WEB容器创建的Servlet对象，这些Servlet对象都会被放到一个集合当中(HashMap)，只有放到这个HashMap集合中的Servlet才能够被WEB容器管理，自己new的Servlet对象不会被WEB容器管理。(自己new的Servlet对象不在容器当中)</li>
<li><strong>web容器底层应该有一个HashMap这样的集合，在这个集合当中存储了Servlet对象和请求路径之间的关系</strong></li>
<li><img src="/2022/10/26/JAVAWEB-2/10.png" alt="image-20221022204604844"></li>
</ul>
</li>
<li><p>研究:服务器在启动的Servlet对象有没有被创建出来(默认情况下)?</p>
<ul>
<li>在Servlet中<strong>提供一个无参数的构造方法</strong>，<strong>启动服务器的时候看看构造方法是否执行。</strong></li>
<li>经过测试得出结论:默认情况下，服务器在启动的时候Servlet对象并不会被实例化。</li>
<li>这个设计是合理的。用户没有发送请求之前，如果提前创建出来所有的Servlet对象，必然是耗费内存的，并且创建出来的Servlet如果一直没有用户访问，显然这个Servlet对象是一个废物，没必要先创建。</li>
</ul>
</li>
<li><p>怎么让服务器启动的时候创建Servlet对象呢?</p>
<ul>
<li><p>在servlet标签中添加<load-on-startup>子标签，在该子标签中填写整数，越小的整数优先级越高。</load-on-startup></p>
</li>
<li><p>&#96;&#96;&#96;xml<br><load-on-startup><load-on-startup></load-on-startup></load-on-startup></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- Servlet对象生命周期</span><br><span class="line"></span><br><span class="line">- 默认情况下服务器启动的时候AServlet对象并没有被实例化。</span><br><span class="line"></span><br><span class="line">- 用户发送第一次请求的时候，控制台输出了以下内容:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>AServlet无参数构造方法执行了<br>Aservlet ‘s init method execute!<br>AServlet ‘s service method execute!</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 根据以上输出内容得出结论:</span><br><span class="line"></span><br><span class="line">  - 用户在发送第一次请求的时候Serlet对象被实例化(AServlet的构造方法被执行了。并且执行的是无参数构造方法。)</span><br><span class="line">  - AServlet对象被创建出来之后，Tomcat服务器马上调用了AServlet对象的init方法。(init方法在执行的时候，AServlet对象</span><br><span class="line">    已经存在了。已经被创建出来了。)</span><br><span class="line">  - 用户发送第一次请求的时候，init方法执行之后，Tomcat服务器马上调用ASerMlet对象的service方法。</span><br><span class="line"></span><br><span class="line">- 用户继续发送第二次请求，控制台输出了以下内容:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>AServlet ‘s service method execute!</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 根据以上输出结果得知，用户在发送第二次，或者第三次，或者第四次请求的时候，Servlet对象并没有新建，还是使用之前创建好的Servlet对象，直接调用该Servlet对象的service方法，这说明:</span><br><span class="line"></span><br><span class="line">  - 第一:Serlet对象是单例的（(单实例的。但是要注意:Serdlet对象是单实例的，但是Servlet类并不符合单例模式。我们称之为假单例。之所以单例是因为Servlet对象的创建我们iavaweb程序员管不着，这个对象的创建只能是Tomcat来说了算，Tomcat只创建了一个，所以导致了单例，但是属于假单例。真单例模式，构造方法是私有化的。)</span><br><span class="line">  - 第二∶无参数构造方法、init方法只在第一次用户发送请求的时候执行。也就是说无参数构造方法只执行一次。init方法也只被Tomcat服务器调用一次。</span><br><span class="line">  - 第三∶只要用户发送一次请求: service方法必然会被Tomcat服务器调用一次。发送100次请求，service方法会被调用100次。</span><br><span class="line"></span><br><span class="line">- 关闭服务器的时候，控制台输出了以下内容:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>AServlet ‘s service destroy method execute!</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 通过以上输出内容，可以得出以下结论:</span><br><span class="line"></span><br><span class="line">  - Servlet的destroy方法只被Tomcat服务器调用一次。</span><br><span class="line">  - destroy方法是在什么时候被调用的?</span><br><span class="line">    - 在服务器关闭的时候。</span><br><span class="line">    - 因为服务器关闭的时候要销毁AServlet对象的内存。</span><br><span class="line">    - 服务器在销毁AServlet对象内存之前，Tomcat服务器会自动调用ASerlet对象的destroy方法。</span><br><span class="line">  - 请问: destroy方法调用的时候，对象销毁了还是没有销毁呢?</span><br><span class="line">    - destroy方法执行的时候AServlet对象还在，没有被销毁。destroy方法执行结束之后，AServlet对象的内存才会被Tomcat释放。</span><br><span class="line"></span><br><span class="line">- Servlet对象更像一个人的一生:</span><br><span class="line"></span><br><span class="line">  - Servlet的无参数构造方法执行:标志着你出生了。</span><br><span class="line">  - Servlet对象的init方法的执行:标志着你正在接受教育。</span><br><span class="line">  - Servlet对象的service方法的执行:标志着你已经开始工作了，已经开始为人类提供服务了。</span><br><span class="line">  - Servlet对象的destroy方法的执行:标志着临终。有什么遗言，抓紧的。要不然，来不及了。</span><br><span class="line"></span><br><span class="line">- 关于Servlet类中方法的调用次数?</span><br><span class="line"></span><br><span class="line">  - 构造方法只执行一次。</span><br><span class="line">  - init方法只执行一次。</span><br><span class="line">  - service方法:用户发送一次请求则执行一次，发送N次请求则执行N次。- </span><br><span class="line">  - destroy方法只执行一次。</span><br><span class="line"></span><br><span class="line">- 当我们Servlet类中编写一个有参数的构造方法，如果没有手动编写无参数构造方法会出现什么问题?</span><br><span class="line"></span><br><span class="line">  - 报错了:500错误。</span><br><span class="line">  - 注意:500是一个HTTP协议的错误状态码。</span><br><span class="line">  - 500一般情况下是因为服务器端的Java程序出现了异常。(服务器端的错误都是500错误:服务器内部错误。)</span><br><span class="line">  - 如果没有无参数的构造方法，会导致出现500错误，无法实例化Servlet对象。</span><br><span class="line">  - 所以，一定要注意:在Servlet开发当中，不建议程序员来定义构造方法，因为定义不当，一不小心就会导致无法实例化Servlet对象。</span><br><span class="line"></span><br><span class="line">- 思考: Servlet的无参数构造方法是在对象第一次创建的时候执行，并且只执行一次。init方法也是在对象第一次创建的时候执行，并且只执行一次。那么这个无参数构造方法可以代替掉init方法吗?</span><br><span class="line"></span><br><span class="line">  - 不能。</span><br><span class="line">  - Servlet规范中有要求，作为jiavaweb程序员，编写Servlet类的时候，不建议手动编写构造方法，因为编写构造方法，很容易让无参数构造方法消失，这个操作可能会导致Servlet对象无法实例化。所以init方法是有存在的必要的。</span><br><span class="line"></span><br><span class="line">- init. service、destroy方法中使用最多的是哪个方法?</span><br><span class="line"></span><br><span class="line">  - 使用最多就是service方法，service方法是一定要实现的，因为service方法是处理用户请求的核心方法。</span><br><span class="line">  - 什么时候使用init方法呢?</span><br><span class="line">    - init方法很少用。</span><br><span class="line">    - 通常在init方法当中做初始化操作，并且这个初始化操作只需要执行一次。例如:初始化数据库连接池，初始化线程池....</span><br><span class="line"></span><br><span class="line">- 什么时候使用destroy方法呢?</span><br><span class="line"></span><br><span class="line">  - destroy方法也很少用。</span><br><span class="line">  - 通常在destroy方法当中，进行资源的关闭。马上对象要被销毁了，还有什么没有关闭的，抓紧时间关闭资源。还有什么资源没保存的.抓鉴时间保存一下。</span><br><span class="line"></span><br><span class="line">- 我们编写一个Servlet类直接实现Servlet接口有什么缺点?</span><br><span class="line"></span><br><span class="line">  - 我们只需要service方法，其他方法大部分情况下是不需要使用的。代码很丑陋。</span><br><span class="line"></span><br><span class="line">- 适配器设计模式Adapter</span><br><span class="line"></span><br><span class="line">  - 手机直接插到22OM的电压上，手机直接就报废了。怎么办?可以找一个充电器。这个充电器就是一个适配器。手机连接适配</span><br><span class="line">    器。适配器连接220V的电压。这样问题就解决了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### GenericServlet（重点）</span><br><span class="line"></span><br><span class="line">- 编写一个GenericServlet类，这个类是一个抽象类，其中有一个抽象方法service。</span><br><span class="line"></span><br><span class="line">  - GenericServlet实现Servlet接口。</span><br><span class="line">  - GenericServlet是一个适配器。</span><br><span class="line">  - 以后编写的所有Servlet类继承GenericServlet，重写service方法即可。</span><br><span class="line"></span><br><span class="line">- 思考: GenericServlet类是否需要改造一下?怎么改造?更利于子类程序的编写?</span><br><span class="line"></span><br><span class="line">  - 思考第一个问题:我提供了一个GenericServlet之后，init方法还会执行吗?</span><br><span class="line">  - 还会执行。会执行GenericServlet类中的init方法。</span><br><span class="line"></span><br><span class="line">- 思考第二个问题:init方法是谁调用的?</span><br><span class="line"></span><br><span class="line">  - Tomcat服务器调用的。</span><br><span class="line"></span><br><span class="line">- 思考第三个问题:init方法中的ServletConfig对象是谁创建的?是谁传过来的?</span><br><span class="line"></span><br><span class="line">  - 都是Tomcat千的。</span><br><span class="line">  - Tomcat服务器先创建了ServletConfig对象，然后调用init方法，将ServletConfig对象传给了init方法。</span><br><span class="line"></span><br><span class="line">- 思考—下Tomcat服务器伪代码:</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    public class Tomcat &#123;</span><br><span class="line">        public static void main(String[] args) &#123;</span><br><span class="line">            // .....</span><br><span class="line">            //Tomcat服务器伪代码</span><br><span class="line">            //创建LoginServlet对象〈通过反射机制，调用无参数构造方法来实例化LoginServlet对象)</span><br><span class="line">            Class clazz = Class.forName(&quot; com.bjpowernode.javaweb.servlet.Loginservlet&quot;);</span><br><span class="line">            Object obj = clazz.newInstance();</span><br><span class="line">    </span><br><span class="line">            //向下转型</span><br><span class="line">            Servlet servlet = (servlet) obj;</span><br><span class="line">    </span><br><span class="line">            //创建servletconfig对象</span><br><span class="line">            //Tomcat服务器负责将servletconfig对象实例化出来。</span><br><span class="line">            //多态(Tomcat服务器完全实现了servlet规范)</span><br><span class="line">            Servletconfig servletConfig = new org.apache.catalina.core.StandardwrapperFacade();</span><br><span class="line">    </span><br><span class="line">            //调用servlet的init方法</span><br><span class="line">            servlet.init(servletconfig);</span><br><span class="line">            </span><br><span class="line">            //调用servlet的service方法</span><br><span class="line">            // ....</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient		//不参与序列化，序列化版本号</span><br></pre></td></tr></table></figure>





<h3 id="ServletConfig（重点）-局部"><a href="#ServletConfig（重点）-局部" class="headerlink" title="ServletConfig（重点）(局部)"></a>ServletConfig（重点）(局部)</h3><p>适配器</p>
<ul>
<li><p>什么是ServletConfig?</p>
<ul>
<li>Servlet对象的配置信息对象。</li>
<li>ServletConfig对象中封装了<servlet></servlet>标签中的配置信息。(web.xml文件中servlet的配置信息)</li>
</ul>
</li>
<li><p><strong>一个Servlet对应一个ServletConfig对象。</strong></p>
</li>
<li><p>Serlet对象是Tomcat服务器创建，并且ServletConfig对象也是Tomcat服务器创建。并且默认情况下，他们都是在用户发送第一次请求的时候创建。</p>
</li>
<li><p>Tomcat服务器调用Servlet对象的init方法的时候需要传一个ServletConfig对象的参数给init方法。</p>
</li>
<li><p>ServletConfig接口的实现类是Tomcat服务器给实现的。(Tomcat服务器说的就是WEB服务器。)</p>
</li>
<li><p>ServletConfig接口有哪些常用的方法?</p>
<ul>
<li><pre><code class="java">public String getInitParameter(String name);//通过初始化参数的name获取value
public Enumeration&lt;String&gt; getInitParameterNames();//获取所有的初始化参数的name
public ServletContext getServletcontext();// 获取servletcontext对象
public String getServ1etName();//获取servlet的name

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 以上方法在Servlet类当中，都可以使用this去调用。因为GenericServlet实现了ServletConfig接口。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### ServletContext（重点）（全局）</span><br><span class="line"></span><br><span class="line">- 一个Servlet对象对应一个ServletConfig。100个Servlet对象则对应100个ServletConfig对象。</span><br><span class="line"></span><br><span class="line">- 只要在同一个webapp当中，只要在同一个应用当中，所有的Serlet对象都是共享同一个ServletContext对象的。</span><br><span class="line"></span><br><span class="line">- ServletContext对象在服务器启动阶段创建，在服务器关闭的时候销毁。这就是ServletContext对象的生命周期。ServletContext对象是应用级对象。</span><br><span class="line"></span><br><span class="line">- Tomcat服务器中有一个webapps，这个webapps下可以存放webapp，可以存放多个webapp，假设有100个webapp，那么就有100个ServletContext对象。但是，总之，一个应用，一个webapp肯定是只有一个ServletContext对象。</span><br><span class="line"></span><br><span class="line">- ServletContext被称为Servlet上下文对象。(Serulet对象的四周环境对象。)</span><br><span class="line"></span><br><span class="line">- —个ServletContext对象通常对应的是一个web.xml文件。</span><br><span class="line"></span><br><span class="line">- ServletContext对应显示生活中的什么例子呢?</span><br><span class="line"></span><br><span class="line">  - 一个教室里有多个学生，那么每一个学生就是一个Serulet，这些学生都在同一个教室当中，那么我们可以把这个教室叫做ServletContext对象。那么也就是说放在这个ServletContext对象（环境）当中的数据，在同一个教室当中，物品都是共享的。比如:教室中有一个空调，所有的学生都可以操作。可见，空调是共享的。因为空调放在教室当中。教室就是ServletContext对象。</span><br><span class="line"></span><br><span class="line">- ServletContext是一个接口，Tomcat服务器对ServletContext接口进行了实现。</span><br><span class="line"></span><br><span class="line">  - ServletContext对象的创建也是Tomcat服务器来完成的。启动webapp的时候创建的。</span><br><span class="line"></span><br><span class="line">- ServletContext接口中有哪些常用的方法?</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    public String getInitparameter(String name);//通过初始化参数的name获取value</span><br><span class="line">    public Enumeration&lt;String getInitParamet erNames();//获取所有的初始化参数的name</span><br><span class="line">    </span><br><span class="line">    </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><pre><code class="xml">&lt;!--以上两个方法是ServletContext对象的方法，这个方法获取的是什么信息?是以下的配置信息--&gt;
&lt;context-param&gt;
    &lt;param-name&gt;pagesize&lt;/param-name&gt;
    &lt;param-value&gt;10&lt;/param-value&gt;
&lt;/context-param&gt;
&lt;context-param&gt;
    &lt;param-name&gt;startIndex&lt;/param-name&gt;
    &lt;param-value&gt;0&lt;/param-value&gt;
&lt;/context-param&gt;
&lt;!--注意:以上的配置信息属于应用级的配置信息，一般一个项目中共享的配置信息会放到以上的标签当中。--&gt;
&lt;!--如果你的配置信息只是想给某一个servlet作为参考，那么你配置到servlet标签当中即可，使用servletconfig对象来获取。--&gt;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  //获取应用的根路径〈非常重要〉，因为在java源代码当中有一些地方可能会需要应用的相路径，这个方法可以动态获取应用的根路径</span><br><span class="line">  //在java源码当中，不要将应用的根路径写死，因为你永远都不知道这个应用在最终部署的时候，起一个什么名字。</span><br><span class="line">  public String getContextpath();</span><br><span class="line">  // 	String contextPath = application. getContextPath();</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><pre><code class="java">//获取文件的绝对路径(真实路径)
public String getRealPath(String path);


<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  //通过servletcontext对象也是可以记录日志的public void log(string message);</span><br><span class="line">  public void log(String message，Throwable t);</span><br><span class="line">  //这些日志信息记录到哪里了?</span><br><span class="line">  //localhost.2021-11-05.1og</span><br><span class="line">  </span><br><span class="line">  //Tomcat服务器的1ogs目录下都有哪些日志文件?</span><br><span class="line">  //catalina.2021-11-05.1og服务器端的java程序运行的控制台信息。</span><br><span class="line">  //localhost.2021-11-05.log ServletContext对象的log方法记录的日志信息存储到这个文件中。 //localhost_access_log.2021-11-05.txt访问日志</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>&#96;&#96;&#96;java<br>&#x2F;&#x2F;servletcontext对象还有另一个名字:应用域（后面还有其他域，例如:请求域、会话域)</p>
<p>&#x2F;&#x2F;如果所有的用户共享一份数据，并且这个数据很少的被修改，并且这个数据量很少，可以将这些数据放到ServletContext这个应用域中</p>
<p>&#x2F;&#x2F;为什么是所有用戾共享的数据?不是共享的没有意义。因为ServletContext这个对象只有一个。只有共享的数据放进去才有意义。</p>
<p>&#x2F;&#x2F;为什么数据量要小?	因为数据量比较大的话，太占用堆内存，并且这个对象的生命周期比较长，服务器关闭的时候，这个对象才会被销毁。大数据量会影响服务器的性能。占用内存较小的数据量可以考虑放进去。</p>
<p>&#x2F;&#x2F;为什么这些共享数据很少的修改,或者说几乎不修改?<br>&#x2F;&#x2F;所有用户共享的数据，如果涉及到修改操作，必然会存在线程并发所带来的安全问题。所以放在ServletContext对象中的数据一般都是只读的。</p>
<p>&#x2F;&#x2F;数据量小、所有用户共享、又不修改，这样的数据放到ServletContext这个应用域当中，会大大提升效率。因为应用域相当于一个缓存，放到缓存中的数据，下次在用的时候，不需要从数据库中再次获取，大大提升执行效率。</p>
<p>&#x2F;&#x2F;存(怎么向servletContext应用域中存数据)<br>public void setAttribute(String name，Object value);	&#x2F;&#x2F;map.put(k, v)<br>&#x2F;&#x2F;取(怎么从servletContext应用域中取数据〉<br>public Object getAttribute(String name);	&#x2F;&#x2F;map.get(k)<br>&#x2F;&#x2F;删(怎么删除servletContext应用域中的数据&gt;<br>public void removeAttribute(String name);	&#x2F;&#x2F;map.remove(k)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 注意:以后我们编写Serlet类的时候，实际上是不会去直接继承(GenericServlet类的，因为我们是B/S结构的系统，这种系统是基于HTTP超文本传输协议的，在Servlet规范当中，提供了一个类叫做HttpServlet，它是专门为HTTP协议准备的一个Servlet类。我们编写的Servlet类要继承HttpServlet。(HttpServlet是HTTP协议专用的。)使用HttpServlet处理HTTP协议更便捷。但是你需要直到它的继承结构:</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    jakarta.servlet.servlet（接口〉【爷爷】</span><br><span class="line">    jakarta.servlet.Genericservlet implements servlet（抽象类）【儿子】</span><br><span class="line">    jakarta.servlet.http.HttpServlet extends Genericservlet（抽象类〉【孙子】</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    我们以后编写的servlet要继承Httpservlet类。</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>大家到目前为止都接触过哪些缓存机制了?</p>
<ul>
<li>堆内存当中的字符串常量池。<ul>
<li>“abc”先在字符串常星池中查找，如果有，直接拿来用。如果没有则新建，然后再放入字符串常量池。</li>
</ul>
</li>
<li>堆内存当中的整数型常量池。<ul>
<li>[-128~127]一共256个Integer类型的引用，放在整数型常量池中。没有超出这个范围的话，直接从常量池中取。</li>
</ul>
</li>
<li>连接池(Connection Cache)<ul>
<li>这里所说的连接池中的连接是java语言连接数据库的连接对象: java.sql.Connection对象。</li>
<li>JVM是一个进程。MySQL数据库是一个进程。进程和进程之间建立连接，打开通道是很费劲的。是很耗费资源的。怎么办?可以提前先创建好N个Connection连接对象，将连接对象放到一个集合当中，我们把这个放有Connection对象的集合称为连接池。每一次用户连接的时候不需要再新建连接对象，省去了新建的环节，直接从连接池中获取连接对象，大大提升访问效率。</li>
<li>连接池</li>
<li>最小连接数</li>
<li>最大连接数</li>
<li>连接池可以提高用户的访问效率。当然也可以保证数据库的安全性。|</li>
</ul>
</li>
<li>线程池<ul>
<li>Tomcat服务器本身就是支持多线程的。</li>
<li>Tomcat服务器是在用户发送一次请求，就新建一个Thread线程对象吗?<ul>
<li>当然不是，实际上是在Tomcat服务器启动的时候，会先创建好N多个线程Thread对象，然后将线程对象放到集合当中，称为线程池。用户发送请求过来之后，需要有一个对应的线程来处理这个请求，这个时候线程对象就会直接从线程池中拿，效率比较高。</li>
<li>所有的WEB服务器，或者应用服务器，都是支持多线程的，都有线程池机制。</li>
</ul>
</li>
</ul>
</li>
<li>redis<ul>
<li>NoSQL数据库。非关系型数据库。缓存数据库。</li>
</ul>
</li>
<li>向ServletContext应用域中存储数据，也等于是将数据存放到缓存cache当中了。</li>
</ul>
</li>
</ul>
<p>idea的小猫咪</p>
<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><ul>
<li><p>什么是协议?</p>
<ul>
<li>协议实际上是某些人，或者某些组织提前制定好的一套规范，大家都按照这个规范来，这样可以做到沟通无障碍。</li>
<li>协议就是一套规范，就是—套标准。由其他人或其他组织来负责制定的。</li>
<li>我说的话你能听懂，你说的话，我也能听懂，这说明我们之间是有一套规范的，一套协议的，这套协议就是:中国普通话协议。我们都遵守这套协议，我们之间就可以沟通无障碍。</li>
</ul>
</li>
<li><p>什么是HTTP协议?</p>
<ul>
<li>HTTP协议:是W3C制定的—种超文本传输协议。</li>
<li>W3C:<ul>
<li>万维网联盟组织</li>
<li>负责制定标准的: HTTP HTML4.0 HTML5 XML DOM等规范都是W3C制定的。</li>
<li>万维网之父:蒂姆·伯纳斯·李</li>
</ul>
</li>
<li>什么是超文本?<ul>
<li>超文本说的就是:不是普通文本，比如流媒体:声音、视频、图片等。</li>
<li>HTTP协议支持:不但可以传送普通字符串，同样支持传递声音、视频、图片等流媒体信息。</li>
</ul>
</li>
<li>这种协议游走在B和S之间。B向S发数据要遵循HTTP协议。S向B发数据同样需要遵循HTTP协议。这样B和S才能解耦合。</li>
<li>什么是解耦合?<ul>
<li>B不依赖S。</li>
<li>S也不依赖B。</li>
</ul>
</li>
<li>B&#x2F;S表示:B&#x2F;S结构的系统（浏览器访问WEB服务器的系统)</li>
<li>浏览器向WEB服务器发送数据，叫做:请求(request)</li>
<li>WEB服务器向浏览器发送数据，叫做:响应(response)</li>
<li>HTTP协议包括:<ul>
<li>请求协议<br>浏览器向WEB服务器发送数据的时候，这个发送的数据需要遵循—套标准，这套标准中规定了发送的数据具体格式。</li>
<li>响应协议<br>WEB服务器向浏览器发送数据的时候，这个发送的数据需要遵循—套标准，这套标准中规定了发送的数据具体格式.</li>
</ul>
</li>
<li>HTTP协议就是提前制定好的一种消息模板。<ul>
<li>不管你是哪个品牌的浏览器，都是这么发。</li>
<li>不管你是哪个品牌的WEB服务器，都是这么发。</li>
<li>FF浏览器可以向Tomcat发送请求，也可以向Jetty服务器发送请求。浏览器不依赖具体的服务器品牌。</li>
<li>WEB服务器也不依赖具体的浏览器品牌。可以是FF浏览器，也可以是Chrome浏览器，可以是IE，都行。</li>
</ul>
</li>
</ul>
</li>
<li><p>HTTP的请求协议(B–&gt; S)</p>
<ul>
<li><p>HTTP的请求协议包括:4部分</p>
<ul>
<li>请求行</li>
<li>请求头</li>
<li>空白行</li>
<li>请求体</li>
</ul>
</li>
<li><p>HTTP的<strong>请求</strong>协议的具体报文：GET请求</p>
<ul>
<li>&#96;&#96;&#96;<br>GET &#x2F;servlet05&#x2F;getServlet?username&#x3D;lucy&amp;userpwd&#x3D;1111 HTTP&#x2F;1.1					请求行<br>Host: localhost : 8080															请求头<br>connection: keep-alive<br>sec-ch-ua: “Google chrome”;v&#x3D;”95”,”chromium “ ; v&#x3D;”95”,”;Not A Brand”;v&#x3D;”99”<br>sec-ch-ua-mobile: ?0<br>sec-ch-ua-platform: “windows”<br>upgrade-Insecure-Requests: 1<br>User-Agent: Mozi11a&#x2F;5.0 (windows NT 10.0; win64; x64) ApplewebKit&#x2F;537.36(KHTML,like Gecko)<br>Chrome&#x2F;95.0.4638.54 safari &#x2F; 537.36<br>Accept:<br>text &#x2F;htm1 ,application&#x2F;xhtm1+xm1, application&#x2F;xm1; q&#x3D;0.9 , image&#x2F;avif , image&#x2F;webp , image&#x2F;apng ,<em>&#x2F;</em>; q&#x3D;0.8,application&#x2F;signed-exchange; v&#x3D;b3; q&#x3D;0.9<br>Sec-Fetch-site: same-origin<br>sec-Fet ch-Mode: navigatesec-Fet ch-User : ?1<br>sec-Fet ch-Dest : document<br>Referer : http: &#x2F; &#x2F;localhost:8080&#x2F;servlet05 &#x2F;index.htm1<br>Accept-Encoding: gzip，deflate，br<br>Accept-Language: zh-CN,zh; q&#x3D;0.9												<br>                                                                            空白行	<br>                                                                            请求体	<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- HTTP的**请求**协议的具体报文：POST请求</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    POST /servlet05/postServlet HTTP/1.1											请求行</span><br><span class="line">    Host : localhost :8080															请求头</span><br><span class="line">    connection: keep-alivecontent-Length: 25</span><br><span class="line">    cache-control: max-age=O</span><br><span class="line">    sec-ch-ua: &quot;Google chrome&quot; ; v=&quot;95&quot;，&quot;chromium &quot; ; v=&quot;95&quot;，&quot;;Not A Brand&quot;;v=&quot;99&quot;</span><br><span class="line">    sec-ch-ua-mobile: ?o</span><br><span class="line">    sec-ch-ua-platform: &quot;windows&quot;</span><br><span class="line">    upgrade-Insecure-Requests : 1</span><br><span class="line">    Origin: http://localhost : 8080</span><br><span class="line">    content-Type: application/x-www-form-urlencoded</span><br><span class="line">    User-Agent: Mozilla/5.0 (windows NT 10.0; win64; x64) ApplewebKit/537.36(KHTML，7ike Gecko)</span><br><span class="line">    chrome/95.0.4638.54 safari/537.36</span><br><span class="line">    Accept:</span><br><span class="line">    text /htm1, application /xhtm马+xm1,app1ication/xm1;q=0.9,image/avif ,image/webp , image/apng,*/*;q=0.8 , application/signed-exchange;v=b3 ; q=0.9</span><br><span class="line">    sec-Fetch-site: same-origin</span><br><span class="line">    Sec-Fetch-Mode: navigatesec-Fetch-User: ?1</span><br><span class="line">    sec-Fetch-Dest: document</span><br><span class="line">    Referer : http://localhost:8080/servlet05 /index.html</span><br><span class="line">    Accept-Encoding: gzip,deflate，br</span><br><span class="line">    Accept-Language: zh-CN ,zh; q=0.9</span><br><span class="line">    																				空白行	</span><br><span class="line">    username=lisi&amp;userpwd=123														请求体		</span><br><span class="line">    </span><br><span class="line">    </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>请求行</p>
<ul>
<li>第一部分:请求方式((7种)<ul>
<li>get(常用的)</li>
<li>post(常用的)</li>
<li>delete</li>
<li>put </li>
<li>head</li>
<li>options</li>
<li>trace</li>
</ul>
</li>
<li>第二部分：URl<ul>
<li>什么是URI?统一资源标识符。代表网络中某个资源的名字。但是通过URI是无法定位资源的。</li>
<li>什么是URL?统一资源定位符。代表网络中某个资源，同时，通过URL是可以定位到该资源的。</li>
<li>URI和URL什么关系，有什么区别?<ul>
<li>URL包括URI</li>
<li><a target="_blank" rel="noopener" href="http://localhost:8080/servletO5/index.html%E8%BF%99%E6%98%AFURL%E3%80%82">http://localhost:8080/servletO5/index.html这是URL。</a></li>
<li>&#x2F;servletO5&#x2F;index.html这是URI。</li>
</ul>
</li>
</ul>
</li>
<li>第三部分：HTTP协议版本号</li>
</ul>
</li>
<li><p>请求头</p>
<ul>
<li>请求的主机</li>
<li>主机的端口</li>
<li>浏览器信息</li>
<li>平台信息</li>
<li>cookie等信息</li>
<li>……</li>
</ul>
</li>
<li><p>空白行</p>
<ul>
<li>空白行是用来区分”请求头”和“请求体”</li>
</ul>
</li>
<li><p>请求体</p>
<ul>
<li>向服务器发送的具体数据。</li>
</ul>
</li>
</ul>
</li>
<li><p>HTTP的响应协议(S–&gt;B)</p>
<ul>
<li><p>HTTP的响应协议包括:4部分</p>
<ul>
<li>状态行</li>
<li>响应头</li>
<li>空白行</li>
<li>响应体</li>
</ul>
</li>
<li><p>HTTP的<strong>响应</strong>协议的具体报文</p>
<ul>
<li>&#96;&#96;&#96;<br>HTTP&#x2F;1.1 200 ok											状态行<br>Content-Type: text&#x2F;html; charset&#x3D;UTF-8					响应头<br>Content-Length: 160<br>Date: Mon，08 Nov 2021 13:19:32 GMT<br>Keep-Alive: timeout&#x3D;20<br>connection: keep-alive<br>                                                    空白行<!doctype htm1>											响应体<html>
    <head>
        <title>from get servlet</title></head>
    <body>
        <h1>from get servlet</h1>
    </body>
</html>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 状态行</span><br><span class="line"></span><br><span class="line">    - 三部分组成</span><br><span class="line">      - 第─部分:协议版本号(HTTP/1.1)</span><br><span class="line">      - 第二部分:状态码(HTTP协议中规定的响应状态号。不同的响应结果对应不同的号码。)</span><br><span class="line">        - 200表示请求响应成功，正常结束。</span><br><span class="line">        - 404表示访问的资源不存在，通常是因为要么是你路径写错了，要么是路径写对了，但是服务器中对应的资源并没有启动成功。总之404错误是前端错误。</span><br><span class="line">        - 405表示前端发送的请求方式与后端请求的处理方式不一致时发生:</span><br><span class="line">          - 比如:前端是POST请求，后端的处理方式按照get方式进行处理时，发生405.</span><br><span class="line">          - 比如:前端是GET请求，后端的处理方式按照post方式进行处理时，发生405</span><br><span class="line">          - 500表示服务器端的程序出现了异常。一般会认为是服务器端的错误导致的。</span><br><span class="line">          - 以4开始的，一般是浏览器端的错误导致的。</span><br><span class="line">          - 以5开始的，一般是服务器端的错误导致的。</span><br><span class="line">      - 第三部分:状态的描述信息</span><br><span class="line">        - ok表示正常成功结束。.</span><br><span class="line">        - not found表示资源找不到。</span><br><span class="line"></span><br><span class="line">  - 响应头:</span><br><span class="line"></span><br><span class="line">    - 响应的内容类型</span><br><span class="line">    - 响应的内容长度</span><br><span class="line">    - 响应的时间</span><br><span class="line">    - ....</span><br><span class="line"></span><br><span class="line">  - 空白行:</span><br><span class="line"></span><br><span class="line">    - 用来分隔“响应头&quot;和“响应体&quot;的。</span><br><span class="line"></span><br><span class="line">  - 响应体:</span><br><span class="line"></span><br><span class="line">    - 响应体就是响应的正文，这些内容是一个长的字符串，这个字符串被浏览器渲染，解释并执行，最终展示出效果。</span><br><span class="line"></span><br><span class="line">- 怎么查看的协议内容?</span><br><span class="line"></span><br><span class="line">  - 使用chrome浏览器:E12。然后找到network，通过这个面板可以查看协议的具体内容。</span><br><span class="line"></span><br><span class="line">- ·怎么向服务器发送GET请求，怎么向服务器发送POST请求?</span><br><span class="line"></span><br><span class="line">  - 到目前为止，只有一种情况可以发送POST请求:使用form表单，并且form标签中的method属性值为: method=&quot;post &quot;。</span><br><span class="line">  - 其他所有情况一律都是get请求:</span><br><span class="line">    - 在浏览器地址栏上直接输入URL，敲回车，属于get请求。</span><br><span class="line">    - 在浏览器上直接点击超链接，属于get请求。</span><br><span class="line">    - 使用form表单提交数据时，form标签中没有写method属性，默认就是get</span><br><span class="line">    - 或者使用form的时候，form标签中method属性值为: method=&quot;get&quot;</span><br><span class="line">    - ....</span><br><span class="line"></span><br><span class="line">- GET请求和POST请求有什么区别?</span><br><span class="line"></span><br><span class="line">  -  get请求发送数据的时候，数据会挂在URI的后面，并且在URI后面添加一个?&quot;，&quot;?&quot;后面是数据。这样会导致发送的数据回显在浏览器的地址栏上。(get请求在“请求行&quot;上发送数据)</span><br><span class="line">     - http://localhost:8080/servlet05/getServlet?username=zhangsan&amp;userpwd=1111</span><br><span class="line">  -  post请求发送数据的时候，在请求体当中发送。不会回显到浏览器的地址栏上。也就是说post发送的数据，在浏览器地址栏上看不到。(post在“请求体&quot;当中发送数据)</span><br><span class="line">  -  get请求只能发送普通的字符串。并且发送的字符串长度有限制，不同的浏览器限制不同。这个没有明确的规范。</span><br><span class="line">  -  get请求无法发送大数据量。</span><br><span class="line">  -  post请求可以发送任何类型的数据，包括普通字符串，流媒体等信息:视频、声音、图片。</span><br><span class="line">  -  post请求可以发送大数据量，理论上没有长度限制。</span><br><span class="line">  -  get请求在W3C中是这样说的:get请求比较适合从服务器端获取数据。</span><br><span class="line">  -  post请求在W3C中是这样说的: post请求比较适合向服务器端传送数据。</span><br><span class="line">  -  get请求是安全的。get请求是绝对安全的。为什么?因为get请求只是为了从服务器上获取数据。不会对服务器造成威胁。</span><br><span class="line">  -  post请求是危险的。为什么?因为post请求是向服务器提交数据，如果这些数据通过后门的方式进入到服务器当中，服务器是很危险的。另外post是为了提交数据，所以一般情况下拦截请求的时候，太部分会选择拦截（监听) post请求。</span><br><span class="line">  -  **get请求支持缓存。**</span><br><span class="line">     - https://n.sinaimg.cn/finance/590/w240h350/20211101/b40c-b425eb67cabc342ff5b9dc018b4b00cc.jpg</span><br><span class="line">     - 任何一个get请求最终的“响应结果&quot;都会被浏览器缓存起来。在浏览器缓存当中:</span><br><span class="line">       - 一个get请求的路径a	对应	一个资源。</span><br><span class="line">       - 一个get请求的路径b   对应   一个资源。</span><br><span class="line">       - 一个get请求的路径c    对应    一个资源。</span><br><span class="line">       - ....</span><br><span class="line">     - 实际上，你只要发送get请求，浏览器做的第一件事都是先从本地浏览器缓存中找，找不到的时候才会去服务器上获取。这种</span><br><span class="line">       缓存机制目的是为了提高用户的体验。</span><br><span class="line">     - 有没有这样一个需求:我们不希望get请求走缓存，怎么办?怎么避免走缓存?我希望每一次这个get请求都去服务器上找资源，我不想从本地浏览器的缓存中取。</span><br><span class="line">       - 只要每一次get请求的请求路径不同即可。</span><br><span class="line">       - https:/n.sinaimg.cn/finance/590/w240h350/20211101/7cabc342ff5b9dc018b4b00cc.jpgt=789789787897898</span><br><span class="line">       - https:/n.sinaimg.cn/finance/590/w240h350/20211101/7cabc342ff5b9dc018b4b00cc.jpgt=789789787897899</span><br><span class="line">       - https:I/n.sinaimg.cn/finance/590/w240h350/20211101/7cabc342ffS5b9dc018b4b00cc.jpg?t=系统毫秒数</span><br><span class="line">       - 怎么解决?可以在路径的后面添加一个每时每刻都在变化的&quot;&#x27;时间戳”，这样，每一次的请求路径都不一样，浏览器就不走缓存了。</span><br><span class="line">  -  **post请求不支持缓存。**(POST是用来修改服务器端的资源的。)</span><br><span class="line">     - post请求之后，服务器′响应的结果&quot;不会被浏览器缓存起来。因为这个缓存没有意义。</span><br><span class="line"></span><br><span class="line">- GET请求和POST请求如何选择，什么时候使用GET请求，什么时候使用POST请求?</span><br><span class="line"></span><br><span class="line">  - 怎么选择GET请求和POST请求呢?衡量标准是什么呢?你这个请求是想获取服务器端的数据，还是想向服务器发送数据。如果你是想从服务器上获取资源，建议使用GET请求，如果你这个请求是为了向服务器提交数据，建议使用POST请求。</span><br><span class="line">  - 大部分的form表单提交，都是post方式，因为form表单中要填写大量的数据，这些数据是收集用户的信息，一般是需要传给服务器，服务器将这些数据保存/修改等。</span><br><span class="line">  - 如果表单中有敏感信息，还是建议适用post请求，因为get请求会回显敏感信息到浏览器地址栏上。(例如:密码信息)。做文件上传，一定是post请求。要传的数据不是普通文本。</span><br><span class="line">  - 其他情况都可以使用get请求。</span><br><span class="line"></span><br><span class="line">- 不管你是get请求还是post请求，发送的请求数据格式是完全相同的，只不过位置不同，格式都是统一的:</span><br><span class="line"></span><br><span class="line">  -  name=value&amp;name=value&amp;name=value&amp;name=value</span><br><span class="line">  -  String s = &quot;name=value&amp;name=value&amp;name=value&amp;name=value&quot;;</span><br><span class="line">  -  s.split(&amp;&quot;)  (只有格式一样小猫咪才能帮我们办事)</span><br><span class="line">  -  name=value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 模板方法设计模式</span><br><span class="line"></span><br><span class="line">- 什么是设计模式?</span><br><span class="line">  - 某个问题的固定的解决方案。(可以被重复使用。)·你知道哪些设计模式?</span><br><span class="line">  - GoF设计模式:</span><br><span class="line">    - 通常我们所说的23种设计模式。(Gang of Eo.ur:……4人组提出的设计模式)单例模式</span><br><span class="line">    - 工厂模式</span><br><span class="line">    - 代理模式</span><br><span class="line">    - 门面模式</span><br><span class="line">    - 责任链设计模式</span><br><span class="line">    - 观察者模式</span><br><span class="line">    - 模板方法设计模式</span><br><span class="line">  - JavaEE设计模式:</span><br><span class="line">    - DAO</span><br><span class="line">    - DIO</span><br><span class="line">    - vo</span><br><span class="line">    - PO</span><br><span class="line">    - pojo</span><br><span class="line">    - ……</span><br><span class="line">  - .....</span><br><span class="line"></span><br><span class="line">- 什么是模板方法设计模式?</span><br><span class="line">  - 在模板类的模板方法当中定义核心算法骨架，具体的实现步骤可以延迟到子类当中完成。</span><br><span class="line">- 模板类通常是一个抽象类，模板类当中的模板方法定义核心算法，这个方法通常是final的(但也可以不是final的)</span><br><span class="line">- 模板类当中的抽象方法就是不确定实现的方法，这个不确定怎么实现的事儿交给子类去做。</span><br><span class="line"></span><br><span class="line">### HttpServlet源码分析</span><br><span class="line"></span><br><span class="line">- HttpServlet类是专门为HTTP协议准备的。比GenericServlet更加适合HTTP协议下的开发。</span><br><span class="line"></span><br><span class="line">- HttpServlet在哪个包下?</span><br><span class="line"></span><br><span class="line">  -  jakarta.servlet.http.HttpServlet</span><br><span class="line"></span><br><span class="line">- 到目前为止我们接触了servlet规范中哪些接口?</span><br><span class="line"></span><br><span class="line">  -  jakarta.servlet.Servlet核心接口(接口)</span><br><span class="line">  -  jakarta.servlet.ServletConfig Servlet配置信息接口(接口)</span><br><span class="line">  -  jakarta.servlet.ServletContext Servlet上下文接口(接口)</span><br><span class="line">  -  jakarta.servlet.ServletRequest Serlet请求接口(接口)</span><br><span class="line">  -  jakarta.servlet.ServletResponse Sevlet响应接口(接口)</span><br><span class="line">  -  jakarta.servlet.ServletException Secvlet异常(类)</span><br><span class="line">  -  jiakarta.s.ervlet.GenericServlet标准通用的Serxlet类(抽象类).</span><br><span class="line"></span><br><span class="line">- http包下都有哪些类和接口呢? jakarta.serlet.http.*;</span><br><span class="line"></span><br><span class="line">  -  jakarta.servlet.http.HttpSerlet(HTTP协议专用的Servlet类，抽象类)</span><br><span class="line">  -  iakarta.servlet.http.HttpServletRequest (HTTP协议专用的请求对象)</span><br><span class="line">  -  iakarta.servlet.http.HttpServletResponse (HTTP协议专用的响应对象)</span><br><span class="line"></span><br><span class="line">- HttpServletReguest对象中封装了什么信息?</span><br><span class="line"></span><br><span class="line">  - HttpServletRequest，简称request对象。</span><br><span class="line">  - HttpServletRequest中封装了请求协议的全部内容。</span><br><span class="line">  - Tomcat服务器(WEB服务器）将“请求协议&quot;中的数据全部解析出来，然后将这些数据全部封装到request对象当中了。</span><br><span class="line">  - 也就是说，我们只要面向HttpServletRequest，就可以获取请求协议中的数据。</span><br><span class="line"></span><br><span class="line">- HttpServletResponse对象是专门用来响应HTTP协议到浏览器的。</span><br><span class="line"></span><br><span class="line">- 回忆Servlet生命周期?</span><br><span class="line"></span><br><span class="line">  - 用户第一次请求</span><br><span class="line">    - Tomcat服务器通过反射机制，调用无参数构造方法。创建Servlet对象。(web.xm/文件中配置的Servlet类对应的对象。)</span><br><span class="line">    - Tomcat服务器调用Servlet对象的init方法完成初始化。</span><br><span class="line">    - Tomcat服务器调用Servlet对象的service方法处理请求。</span><br><span class="line">  - 用户第二次请求</span><br><span class="line">    - Tomcat服务器调用Servlet对象的service方法处理请求。</span><br><span class="line">  - 用户第三次请求</span><br><span class="line">    - Tomcat服务器调用Servlet对象的service方法处理请求。</span><br><span class="line">  - ..........</span><br><span class="line">    - Tomcat服务器调用Servlet对象的service方法处理请求。</span><br><span class="line">  - 服务器关闭</span><br><span class="line">    - Tomcat服务器调用Servlet对象的destroy方法，做销毁之前的准备工作。Tomcat服务器销Servlet对象。</span><br><span class="line"></span><br><span class="line">- HttpServlet源码分析:</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    /*</span><br><span class="line">    通过以上源代码分析:</span><br><span class="line">    	假设前端发送的请求是get请求,后端程序员重写的方法是doPost</span><br><span class="line">    	假设前端发送的请求是post请求，后端程序员重写的方法是doGet</span><br><span class="line">    	会发生什么呢?</span><br><span class="line">    		发生405这样的一个错误。</span><br><span class="line">    		405表示前端的错误，发送的请求方式不对。和服务器不一致。不是服务器需要的请求方式。</span><br><span class="line">    </span><br><span class="line">    	通过以上源代码可以知道:只要HttpServlet类中的doGet方法或doPost方法执行了，必然405.</span><br><span class="line">    </span><br><span class="line">    怎么避免405的错误呢?</span><br><span class="line">    	后端重写了doGet方法，前端一定要发get请求。</span><br><span class="line">    	后端重写了doPost方法，前端一定要发post请求。</span><br><span class="line">    	这样可以避免405错误。</span><br><span class="line">    </span><br><span class="line">    	这种前端到底需要发什么样的请求，其实应该后端说了算。后端让发什么方式，前端就得发什么方式。</span><br><span class="line">    </span><br><span class="line">    有的人，你会看到为了避免405错误，在servlet类当中，将doGet和doPost方法都进行了重写。</span><br><span class="line">    这样，确实可以避免405的发生，但是不建议，405错误还是有用的。该报错的时候就应该让他报错。如果你要是同时重写了doGet和doPost，那还不如你直接重写service方法好了。这样代码还能少写一点。</span><br><span class="line">    */</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>我们编写的HelloServlet直接继承HttpServlet，直接重写HttpServlet类中的service()方法行吗?</p>
<ul>
<li>可以，只不过你享受不到405错误。享受不到HTTP协议专属的东西。</li>
</ul>
</li>
<li><p>到今天我们终于得到了最终的一个Servlet类的开发步骤:</p>
<ul>
<li>第一步:编写一个Servlet类，直接继承HttpSerulet</li>
<li>第二步:重写doGet方法或者重写doPost方法，到底重写谁，javaweb程序员说了算。</li>
<li>第三步:将Servlet类配置到web.xml文件当中。</li>
<li>第四步:准备前端的而面(form表单). form表单中指定请求路径即可.</li>
</ul>
</li>
</ul>
<h3 id="关于一个web站点的欢迎页面"><a href="#关于一个web站点的欢迎页面" class="headerlink" title="关于一个web站点的欢迎页面"></a>关于一个web站点的欢迎页面</h3><ul>
<li><p>什么是一个web站点的欢迎页面?</p>
<ul>
<li>对于一个webapp来说，我们是可以设置它的欢迎页面的。</li>
<li>设置了欢迎页面之后，当你访问这个webapp的时候，或者访问这个web站点的时候，没有指定任何′资源路径”，这个时候会默认访问你的欢迎页面。</li>
<li>我们一般的访问方式是:<ul>
<li>http:&#x2F;localhost:8080&#x2F;servlet06&#x2F;login.html这种方式是指定了要访问的就是login.html资源。</li>
</ul>
</li>
<li>如果我们访问的方式是:<ul>
<li>http:&#x2F;localhost:8080&#x2F;servlet06如果我们访问的就是这个站点，没有指定具体的资源路径。它默认会访问谁呢?</li>
<li>默认会访问你设置的欢迎页面。</li>
</ul>
</li>
</ul>
</li>
<li><p>怎么设置欢迎页面呢?</p>
<ul>
<li><p>第一步:我在IDEA工具的web目录下新建了一个文件login.html</p>
</li>
<li><p>第二步:在web.xml文件中进行了以下的配置</p>
<ul>
<li><pre><code class="xml">&lt;we1come-file-list&gt;
    &lt;welcome-file&gt;login.html&lt;/welcome-file&gt;
&lt;/welcome-file-list&gt;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    - 注意:设置欢迎页面的时候，这个路径不需要以&quot;/&quot;开始。并且这个路径默认是从webapp的根下开始查找。</span><br><span class="line"></span><br><span class="line">  - 第三步:启动服务器，浏览器地址栏输入地址</span><br><span class="line"></span><br><span class="line">    - http://localhost:8080/servletO7</span><br><span class="line"></span><br><span class="line">- 如果在webapp的根下新建一个目录，目录中再给一个文件，那么这个欢迎页该如何设置呢?</span><br><span class="line"></span><br><span class="line">  - 在webapp根下新建page1</span><br><span class="line"></span><br><span class="line">  - 在page1下新建page2目录</span><br><span class="line"></span><br><span class="line">  - 在page2目录下新建page.html页面</span><br><span class="line"></span><br><span class="line">  - 在web.xml文件中应该这样配置</span><br><span class="line"></span><br><span class="line">    - ```xml</span><br><span class="line">      &lt;weTeome-file-list&gt;</span><br><span class="line">      	&lt;we1come-file&gt;page1/page2/page. html&lt;/we1come-file&gt;</span><br><span class="line">      &lt;/welcome-file-list&gt;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>注意:路径不需要以”””开始，并且路径默认从webapp的根下开始找。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>一个webapp是可以设置多个欢迎页面的</p>
<ul>
<li>&#96;&#96;&#96;xml<welcome-file-list>
    <welcome-file>page1/page2/page.html
    <welcome-file>login.html</welcome-file>
</welcome-file></welcome-file-list>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 注意:越靠上的优先级越高。找不到的继续向下找。</span><br><span class="line"></span><br><span class="line">- 你有没有注意一件事:当我的文件名设置为index.html的时候，不需要在web.xml文件中进行配置欢迎页面。这是为什么?</span><br><span class="line"></span><br><span class="line">  - 这是因为小猫咪Tomcat服务器已经提前配置好了。</span><br><span class="line"></span><br><span class="line">  - 实际上配置欢迎页面有两个地方可以配置:</span><br><span class="line"></span><br><span class="line">    - 一个是在webapp内部的web.xml文件中。(在这个地方配置的属于局部配置)</span><br><span class="line"></span><br><span class="line">    - 一个是在CATALINA_HOME/conf/web.xml文件中进行配置。(在这个地方配置的属于全局配置)</span><br><span class="line"></span><br><span class="line">      - ```xml</span><br><span class="line">        &lt;welcome-file-list&gt;</span><br><span class="line">                &lt;welcome-file&gt;index.html&lt;/welcome-file&gt;</span><br><span class="line">                &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt;</span><br><span class="line">                &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;</span><br><span class="line">            &lt;/welcome-file-list&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Tomcat服务器的全局欢迎页面是: index.html index.htm index.isp。如果你一个web站点没有设置局部的欢迎页面，Tomcat服务器就会以index.html index.htm index.isp作为一个web站点的欢迎页面。</p>
</li>
<li><p>注意原则:局部优先原则。(就近原则)</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>欢迎页可以是一个S.ervlet吗?</p>
<ul>
<li><p>当然可以。</p>
</li>
<li><p>你不要多想，欢迎页就是一个资源，既然是一个资源，那么可以是静态资源，也可以是动态资源。。静态资源: index.html welcome.html …..</p>
</li>
<li><p>动态资源:Servlet类。</p>
</li>
<li><p>步骤:</p>
<ul>
<li><p>第一步:写一个Serulet</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">we1comeServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request，HttpServletResponse response)</span>throwsServletException,IOException &#123;</span><br><span class="line">        response.setContentType( <span class="string">&quot;text/ htm1&quot;</span>);</span><br><span class="line">        <span class="type">Printwriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        out.print( <span class="string">&quot;&lt;h1&gt;we1come to bjpowernode!&lt;/h1&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二步，在web.xml文件中配置servlet</p>
<ul>
<li>&#96;&#96;&#96;xml<servlet>
    <servlet-name>welcomeservlet</servlet-name>
    <servlet-class>com.bjpowernode.javaweb.servlet.welcomeServlet</servlet-class>
</servlet>
<servlet-mapping>
    <servlet-name>welcomeservlet</servlet-name>
    <url-pattern>/fdsa/fds/a/fds /af/ds/af/dsafdsafdsa</url-pattern>
</servlet-mapping>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 第三步:在web.xml文件中配置欢迎页</span><br><span class="line"></span><br><span class="line">  - ```xml</span><br><span class="line">    &lt;welcome-file-list&gt;</span><br><span class="line">    	&lt;welcome-file&gt;fdfa/fds/a/fds/af/ds/af/dsafdsafdsa&lt;/welcome-file&gt;</span><br><span class="line">    &lt;/welcome-file-list&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="关于WEB-INF目录"><a href="#关于WEB-INF目录" class="headerlink" title="关于WEB-INF目录"></a>关于WEB-INF目录</h3><p>在WEB-INF目录下新建了一个文件: welcome.html</p>
<p>打开浏览器访问: <a target="_blank" rel="noopener" href="http://localhost:8080/servlet07/WEB-INF/welcome.html%E5%87%BA%E7%8E%B0%E4%BA%86404%E9%94%99%E8%AF%AF%E3%80%82">http://localhost:8080/servlet07/WEB-INF/welcome.html出现了404错误。</a></p>
<p>注意:放在WEB-INF目录下的资源是受保护的。在浏览器上不能够通过路径直接访问。所以像HTML、CSS、Simage等静态资源-定要放到WEB-INF目录之外。</p>
<h3 id="HttpServletRequest接口详解"><a href="#HttpServletRequest接口详解" class="headerlink" title="HttpServletRequest接口详解"></a>HttpServletRequest接口详解</h3><ul>
<li><p>HttpServletRequest是一个接口，全限定名称: jakarta.serxlet.http.HttpServletRequest. </p>
</li>
<li><p>HttpSerletRequest接口是Servlet规范中的一员。</p>
</li>
<li><p>HttpServletRequest接口的父接口: ServletRequest</p>
<ul>
<li><pre><code class="java">public interface HttpServletRequest extends ServletRequest &#123;&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- HttpServletRequest接口的实现类谁写的? HttpServletRequest对象是谁给创建的?</span><br><span class="line"></span><br><span class="line">  - 通过测试: org.apache.catalina.connector.RequestFacade实现了HttpSerletReguest接口</span><br><span class="line"></span><br><span class="line">    - ```java</span><br><span class="line">      public class RequestFacade implements HttpServletRequest &#123;&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>测试结果说明:Tomcat服务器(WEB服务器、WEB容器)实现了HttpoServletRequest接口，还是说明了Tomcat服务器实现了<br>Servlet规范。而对于我们javaweb程序员来说，实际上不需要关心这个，我们只需要面向接口编程即可。我们关心的是<br>HttpServletReguest接口中有哪些方法，这些方法可以完成什么功能! ! ! !</p>
</li>
</ul>
</li>
<li><p>HttpServletRequest对象中都有什么信息?都包装了什么信息?</p>
<ul>
<li>HittpServletRequest对象是Tomcat服务器负责创建的。这个对象中封装了什么信息?封装了HTTP的请求协议。</li>
<li>实际上是用户发送请求的时候，遵循了HTTP协议，发送的是HTTP的请求协议，<strong>Tomcat服务器将HTTP协议中的信息以及数据全部解析出来，然后Tomcat服务器把这些信息封装到HttpServletReguest对象当中，传给了我们javaweb程序员。</strong></li>
<li>javaweb程序员面向HttpServletRequest接口编程，调用方法就可以获取到请求的信息了。</li>
</ul>
</li>
<li><p>request和response对象的生命周期?</p>
<ul>
<li>request对象和response对象，一个是请求对象，一个是响应对象。这两个对象只在当前请求中有效。</li>
<li>一次请求对应一个request。</li>
<li>两次请求则对应两个request。</li>
<li>…..</li>
</ul>
</li>
<li><p>HttpServletRequest接口中有哪些常用的方法?</p>
<ul>
<li><p>怎么获取前端浏览器用户提交的数据?</p>
<ul>
<li>&#96;&#96;&#96;java<br>String getParameter (String name)	这个是获取Map<br>Map&lt;String , String[]&gt; getParameterMap()	这个是获取Map集合中所有的key<br>Enumeration<String> getParameterNames()		根据key获取Map集合的value<br>string[] getParametervalues(java.lang.String name)	获取value这个一维数组当中的第一个元素。这个方法最常用。<br>&#x2F;&#x2F;以上的4个方法，和获取用户提交的数据有关系。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 思考:如果是你，前端的form表单提交了数据之后，你准备怎么存储这些数据，你准备采用什么样的数据结构去存储这些数据呢?</span><br><span class="line"></span><br><span class="line">  - 前端提交的数据格式: username=abc&amp;userpwd=111&amp;aihao=s&amp;aihao=d &amp;aihao-tt</span><br><span class="line"></span><br><span class="line">  - 我会采用Map集合来存储:</span><br><span class="line"></span><br><span class="line">    - ```</span><br><span class="line">      Map&lt;String , String&gt;</span><br><span class="line">      	key存储string</span><br><span class="line">      	value存储string</span><br><span class="line">      	这种想法对吗?不对。</span><br><span class="line">      	如果采用以上的数据结构存储会发现key重复的时候value覆盖。</span><br><span class="line">      	key					value</span><br><span class="line">      	-----------------------------------------</span><br><span class="line">      	username			abc</span><br><span class="line">      	userpwd				111</span><br><span class="line">      	aihao				5</span><br><span class="line">      	aihao				d</span><br><span class="line">      	aihao				tt</span><br><span class="line">      这样是不行的，因为map的key不能重复。</span><br><span class="line">      Map&lt;String,String[]&gt;</span><br><span class="line">      key存储String</span><br><span class="line">      value存储String[]</span><br><span class="line">      	key					value</span><br><span class="line">      	------------------------------------------</span><br><span class="line">      	username			&#123; &quot;abc&quot;&#125;</span><br><span class="line">      	userpwd				&#123; &quot;111&quot;&#125;</span><br><span class="line">      	aihao				&#123; &quot;s&quot; ,&quot;d&quot;, &quot;tt&quot;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意:前端表单提交数据的时候，假设提交了120这样的“数字”，其实是以字符串”120”的方式提交的，所以服务器端获取到的一定是一个字符串的”120”，而不是一个数字。(前端永远提交的是字符串，后端获取的也永远是字符串。)</li>
</ul>
</String></li>
</ul>
</li>
<li><p>request对象实际上又称为”请求域”对象。</p>
<ul>
<li><p>应用域对象是什么?</p>
</li>
<li><p>ServletContext (Servlet上下文对象。)</p>
</li>
<li><p>什么情况下余考虑向ServletContext这个应用域当中绑定数据呢?</p>
<ul>
<li>第一:所有用户共享的数据。</li>
<li>第二:这个共享的数据量很小。</li>
<li>第三:这个共享的数据很少的修改操作。</li>
<li>在以上三个条件都满足的情况下，使用这个应用域对象，可以大大提高我们程序执行效率。</li>
<li><strong>实际上向应用域当中绑定数据，就相当于把数据放到了缓存(Cache)当中，然后用户访问的时候直接从缓存中取，减少IO的操作，大大提升系统的性能，所以缓存技术是提高系统性能的重要手段。</strong></li>
</ul>
</li>
<li><p>你见过哪些缓存技术呢?</p>
<ul>
<li>字符串常量池</li>
<li>整数型常量池[-128~127]，但凡是在这个范围当中的Integer对象不再创建新对象，直接从这个整数型常量池中<br>获取。大大提升系统性能。</li>
<li>数据库连接池(提前创建好N个连接对象，将连接对象放到集合当中，使用连接对象的时候，直接从缓存中拿。省去了连接对象的创建过程。效率提升。)</li>
<li>线程池(Tomcat服务器就是支持多线程的。所谓的线程池就是提前先创建好N个线程对象，将线程对象存储到集合中，然后用户请求过来之后，直接从线程池中获取线程对象，直接拿来用。提升系统性能)</li>
</ul>
</li>
<li><p>后期你还会学习更多的缓存技术，例如: redis、mongoDB.……</p>
</li>
<li><p>ServletContext当中有三个操作域的方法</p>
<ul>
<li><p>&#96;&#96;&#96;java<br>void setAttribute(String name，Object obj);&#x2F;&#x2F;向域当中绑定数据。<br>Object getAttribute(String name);&#x2F;&#x2F;从域当中根据name获取数据。<br>void removeAttribute(String name);&#x2F;&#x2F;将域当中绑定的数据移除</p>
<p>&#x2F;&#x2F;以上的操作类似于Map集合的操作。<br>Map&lt;String，Object&gt; map;<br>map. put ( “name “, obj);	&#x2F;&#x2F; 向map集合中放key和value<br>Object obj &#x3D; map.get(“name “); &#x2F;&#x2F; 通过map集合的key获取value<br>map.remove(“name “);	&#x2F;&#x2F;通过Map集合的key删除key和value这个键值对。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- “请求域&quot;对象</span><br><span class="line"></span><br><span class="line">  - “请求域&quot;对象要比&quot;应用域&quot;对象范围小很多。生命周期短很多。请求域只在一次请求内有效。</span><br><span class="line"></span><br><span class="line">  - 一个请求对象request对应一个请求域对象。一次请求结束之后，这个请求域就销毁了。</span><br><span class="line"></span><br><span class="line">  - 请求域对象也有这三个方法:</span><br><span class="line"></span><br><span class="line">    - ```java</span><br><span class="line">      void setAttribute(String name，Object obj);//向域当中绑定数据。</span><br><span class="line">      Object getAttribute(String name);//从域当中根据name获取数据。</span><br><span class="line">      void removeAttribute(String name); //将域当中绑定的数据移除</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>请求域和应用域的选用原则?</p>
<ul>
<li>尽量使用小的域对象，因为小的域对象占用的资源较少。</li>
</ul>
</li>
<li><p>跳转</p>
<ul>
<li><p>转发(一次请求)</p>
<ul>
<li><p>&#96;&#96;&#96;java<br>&#x2F;&#x2F;第一步:获取请求转发器对象<br>RequestDispatcher dispatcher &#x3D; request. getRequestDispatcher(“&#x2F;b”);<br>&#x2F;&#x2F;第二步:调用转发器的forward方法完成跳转&#x2F;转发<br>dispatcher .forward(request ,response) ;</p>
<p>&#x2F;&#x2F;第一步和第二步代码可以联合在一起。<br>request.getRequestDispatcher(“&#x2F;b”).forward(request,response);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 两个Servlet怎么共享数据?</span><br><span class="line"></span><br><span class="line">  - 将数据放到ServletContext应用域当中，当然是可以的，但是应用域范围太大，占用资源太多。不建议使用。</span><br><span class="line">  - 可以将数据放到request域当中，然后AServlet转发到BServlet，保证AServlet和BServlet在同一次请求当中，这样就可以做到两个Servlet，或者多个Servlet共享同一份数据。</span><br><span class="line"></span><br><span class="line">- 转发的下一个资源必须是一个Servlet吗?</span><br><span class="line"></span><br><span class="line">  - 不一定，只要是Tomcat服务器当中的合法资源，都是可以转发的。例如:html....</span><br><span class="line">  - 注意:转发的时候，路径的写法要注意，转发的路径以&quot;&quot;开始，不加项目名。关于</span><br><span class="line"></span><br><span class="line">- request对象中两个非常容易混淆的方法:</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    // uri?username=zhangsan&amp;userpwd=123&amp;sex=1</span><br><span class="line">    String username = request.getParameter (&quot;username&quot;);</span><br><span class="line">    //之前一定是执行过:request.setAttribute( &quot;name&quot;, new objectO)</span><br><span class="line">    Object obj = request.getAttribute( &quot;name &quot; );</span><br><span class="line">    </span><br><span class="line">    //以上两个方法的区别是什么?</span><br><span class="line">    //第一个方法:获取的是用户在浏览器上提交的数据。</span><br><span class="line">    //第二个方法:获取的是请求域当中绑定的数据。</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>HttpServletRequest接口的其他常用方法</p>
<ul>
<li><p>&#96;&#96;&#96;java<br>&#x2F;&#x2F;获取客户端的IP地址<br>String remoteAddr &#x3D; request.getRemoteAddr() ;</p>
<p>&#x2F;&#x2F;get请求在请求行上提交数据。<br>&#x2F;&#x2F;post请求在请求体中提交数据。<br>&#x2F;&#x2F;设置请求体的字符集。(显然这个方法是处理POST请求的乱码问题。这种方式并不能解决get请求的乱码问题。)<br>&#x2F;&#x2F; Tomcat10之后，request请求体当中的字符集黑认就是UTF-8，不需要设置字符集，不会出现乱码问题。<br>&#x2F;&#x2F;Tomcat9前〈包括9在内)，如果前端请求体提交的休中文，后端获取之后出现乱码，怎么解决这个乱码?执行以下代码。<br>request.setCharacterEncoding(“UTF-8”);</p>
<p>&#x2F;&#x2F;在Tomcat9之前（包括9）,响应中文也是有乱码的，怎么解决这个响应的乱码?<br>response.setContentType(“text &#x2F;html ; charset&#x3D;UTF-8”);<br>&#x2F;&#x2F;在Tomcat10之后，包括10在内，响应中文的时候就不在出现乱码问题了。以上代码就不需要设置UTF-8了。</p>
<p>&#x2F;&#x2F;注意一个细节<br>&#x2F;&#x2F;在Tomcat10包括10在内之后的版本，中文将不再出现乱码。(这也体现了中文地位的提升。)</p>
<p>&#x2F;&#x2F;get请求乱码问题怎么解决?<br>&#x2F;&#x2F;get请求发送的时候,数据是在请求行上提交的,不是在请求体当中提交的。<br>&#x2F;&#x2F;get请求乱码怎么解决<br>&#x2F;&#x2F;方案:修改CATALINA_HOME&#x2F;conf&#x2F;server.xml配置文件</p>
<Connector uriencoding="UTF-8">
//注意:从Tomcat8之后，URIEncoding的黑f认值就是UTF-8，所以GET请求也没有乱码问题了。
    
<p>&#x2F;&#x2F;获取应用的根路径<br>String contextPath &#x3D; request.getcontextPath(;</p>
<p>&#x2F;&#x2F;获取请求方式<br>String method &#x3D; request.getMethod(;</p>
<p>&#x2F;&#x2F;获取请求的URI<br>String uri &#x3D; request.getRequestURI(); &#x2F;&#x2F; &#x2F;aaa&#x2F;testRequest</p>
<p>&#x2F;&#x2F;获取servlet path<br>String servletPath &#x3D; request. getServletPath(;&#x2F;&#x2F;&#x2F;testRequest</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 在一个web应用中应该如何完成资源的跳转</span><br><span class="line"></span><br><span class="line">- 在一个web应用中通过两种方式，可以完成资源的跳转:</span><br><span class="line"></span><br><span class="line">  - 第一种方式:转发</span><br><span class="line">  - 第二种方式:重定向</span><br><span class="line"></span><br><span class="line">- 转发和重定向有什么区别?</span><br><span class="line"></span><br><span class="line">  - 代码上有什么区别?</span><br><span class="line"></span><br><span class="line">    - 转发</span><br><span class="line"></span><br><span class="line">      - ```java</span><br><span class="line">        //获取请求转发器对象</span><br><span class="line">        RequestDispatcher dispatcher = request.getRequestDispatcher (&quot; /dept/list&quot;);</span><br><span class="line">        //调用请求转发器对象的forward方法完成转发</span><br><span class="line">        dispatcher .forward(request, response);</span><br><span class="line">        //合并一行代码</span><br><span class="line">        request.getRequestDispatcher(&quot;/dept/1ist&quot;).forward(request，response);</span><br><span class="line">        //转发的时候是一次请求,不管你转发了多少次。都是一次请求。</span><br><span class="line">        //AServlet转发到BServlet，再转发到cservlet，再转发到DServlet，不管转发了多少次，都在同一个request当中。</span><br><span class="line">        //这是因为调用forwar d方法的时候，会将当前的request和r esponse对象传递给下一个servlet。</span><br></pre></td></tr></table></figure></Connector></li>
</ul>
</li>
<li><p>重定向</p>
<ul>
<li>&#96;&#96;&#96;java<br>&#x2F;&#x2F;注意:路径上要加一个项目名。为什么?<br>&#x2F;&#x2F;浏览器发送请求，请求路径上是需要添加项目名的。<br>&#x2F;&#x2F;以下这一行代码会将请求路径”&#x2F;oa&#x2F;dept&#x2F;list”发送给浏览器<br>&#x2F;&#x2F;浏览器会自发的向服务器发送一次全新的请求:&#x2F;oa&#x2F;dept&#x2F;listresponse.sendRedirect(“ &#x2F; oa&#x2F;dept&#x2F;list”);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 形式上有什么区别?</span><br><span class="line"></span><br><span class="line">    - 转发(一次请求)</span><br><span class="line">      - 在浏览器地址栏上发送的请求是: http://localhost:8080/servlet10/a，最终请求结束之后，浏览器地址栏上的地址还是这个。没变。</span><br><span class="line">    - 重定向(两次请求)</span><br><span class="line">      - 在浏览器地址栏上发送的请求是: http:/localhost:8080/servlet10/a，最终在浏览器地址栏上显示的地址是: http;:/localhost:8080/servlet10/b</span><br><span class="line"></span><br><span class="line">  - 转发和重定向的本质区别?</span><br><span class="line"></span><br><span class="line">    - **转发:是由WEB服务器来控制的。A资源跳转到B资源，这个跳转动作是Tomcat服务器内部完成的。**</span><br><span class="line">    - **重定向:是浏览器完成的。具体跳转到哪个资源，是浏览器说了算。（浏览器发送请求需要加资源名【/XMM】）**</span><br><span class="line"></span><br><span class="line">  - 使用一个例子去描述这个转发和重定向</span><br><span class="line"></span><br><span class="line">    - 借钱（转发)</span><br><span class="line">      - 杜老师没钱了，找张三借钱，其实张三没有钱，但是张三够义气，张三自己找李四借了钱，然后张三把这个钱给了杜老师，杜老师不知道这个钱是李四的，杜老师只求了一个人。杜老师以为这个钱就是张三的。</span><br><span class="line">    - 借钱（重定向)</span><br><span class="line">      - 杜老师没钱了，找张三借钱，张三没有钱，张三有一个好哥们，叫李四，李四是个富二代，于是张三将李四的家庭住址告诉了杜老师，杜老师按照这个地址去找到李四，然后从李四那里借了钱。显然杜老师在这个过程中，求了两个人。并且杜老师知道最终这个钱是李四借给俺的。</span><br><span class="line"></span><br><span class="line">- 转发和重定向应该如何选择?什么时候使用转发，什么时候使用重定向?</span><br><span class="line"></span><br><span class="line">  - 如果在上一个Serlet当中向request域当中绑定了数据，希望从下一个Serulet当中把request域里面的数据取出来，使用转发机制。</span><br><span class="line">  - 剩下所有的请求均使用重定向。(重定向使用较多。)</span><br><span class="line"></span><br><span class="line">- 跳转的下一个资源有没有要求呢?必须是一个Servlet吗?</span><br><span class="line"></span><br><span class="line">  - 不一定，跳转的资源只要是服务器内部合法的资源即可。包括: Servlet、lSP、HTML...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 将oa项目中的资源跳转修改为合适的跳转方式</span><br><span class="line"></span><br><span class="line">- 删除之后，重定向</span><br><span class="line">- 修改之后，重定向</span><br><span class="line">- 保存之后，重定向 (保存后会刷新页面，会重新发送相同的请求，导致多条记录，所以必须使用重定向)</span><br><span class="line">- 重定向:</span><br><span class="line">  - 成功</span><br><span class="line">  - 失败</span><br><span class="line"></span><br><span class="line">### Servlet注解，简化配置</span><br><span class="line"></span><br><span class="line">- 分析oa项目中的web.xml文件</span><br><span class="line"></span><br><span class="line">  - 现在只是一个单标的CRUD，没有复杂的业务逻辑，很简单的一丢丢功能。web.xml文件中就有如此多的配置信息。如果采用这种方式，对于一个大的项目来说，这样的话web.xml文件会非常庞大，有可能最终会达到几十兆。</span><br><span class="line">  - 在web.xml文件中进行servlet信息的配置，显然开发效率比较低，每一个都需要配置一下。</span><br><span class="line">  - 而且在web.xml文件中的配置是很少被修改的，所以这种配置信息能不能直接写到java类当中呢?可以的。</span><br><span class="line"></span><br><span class="line">- Servlet3.0版本之后，推出了各种Servlet基于注解式开发。优点是什么?</span><br><span class="line"></span><br><span class="line">  - 开发效率高，不需要编写大量的配置信息。直接在java类上使用注解进行标注。</span><br><span class="line">  - web.xml文件体积变小了。</span><br><span class="line"></span><br><span class="line">- 并不是说注解有了之后，web.xml文件就不需要了:</span><br><span class="line"></span><br><span class="line">  - 有一些需要变化的信息，还是要配置到web.xml文件中。一般都是注解+配置文件的开发模式</span><br><span class="line">  - —些不会经常变化修改的配置建议使用注解。一些可能会被修改的建议写到配置文件中。</span><br><span class="line"></span><br><span class="line">- 我们的第一个注解:</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    jakarta.servlet.annotation.webserv1et</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>在Servlet类上使用:@WebServlet，WebServlet注解中有哪些属性呢?</p>
<ul>
<li>name属性:用来指定Servlet的名字。等同于:<servlet-name></servlet-name></li>
<li>urlPatterns属性:用来指定Servlet的映射路径。可以指定多个字符串。<url-pattern></url-pattern></li>
<li>loadOnStartUJp属性:用来指定在服务器启动阶段是否加载该Servlet。等同于:<load-on-startup></load-on-startup></li>
<li>value属性:当注解的属性名是value的时候，使用注解的时候，value属性名是可以省略的。</li>
<li>注意:不是必须将所有属性都写上，只需要提供需要的。(需要什么用什么。)</li>
</ul>
</li>
<li><p>注解对象的使用格式:</p>
<ul>
<li>@注解名称(属性名&#x3D;属性值,属性名&#x3D;属性值,属性名&#x3D;属性值….)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="使用模板方法设计模式优化oa项目"><a href="#使用模板方法设计模式优化oa项目" class="headerlink" title="使用模板方法设计模式优化oa项目"></a>使用模板方法设计模式优化oa项目</h3><ul>
<li>上面的注解解决了配置文件的问题。但是现在的oa项目仍然存在一个比较臃肿的问题。<ul>
<li>一个单标的CRUD，就写了6个Serylet。如果一个复杂的业务系统，这种开发方式，显然会导致类爆炸。(类的数量太大。)。</li>
<li>怎么解决这个类爆炸问题?可以使用模板方法设计模式。</li>
</ul>
</li>
<li>怎么解决类爆炸问题?<ul>
<li>以前的设计是一个请求一个Servlet类。1000个请求对应1000个Servlet类。导致类爆炸。</li>
<li>可以这样做:一个请求对应一个方法。一个业务对应一个Serulet类。</li>
<li>处理部门相关业务的对应一个DeptServlet。处理用户相关业务的对应一个UserServlet。处理银行卡卡片业务对应一个CardServlet.</li>
</ul>
</li>
</ul>
<h3 id="分析使用纯粹Servlet开发web应用的缺陷"><a href="#分析使用纯粹Servlet开发web应用的缺陷" class="headerlink" title="分析使用纯粹Servlet开发web应用的缺陷"></a>分析使用纯粹Servlet开发web应用的缺陷</h3><ul>
<li>在Servlet当中编写HTML&#x2F;CSS&#x2F;JavaScript等前端代码。存在什么问题?<ul>
<li>java程序中编写前端代码，编写难度大。麻烦。</li>
<li>java程序中编写前端代码，显然程序的耦合度非常高。</li>
<li>java程序中编写前端代码，代码非常不美观。</li>
<li>java程序中编写前端代码，维护成本太高。(非常难于维护)<ul>
<li>修改小小的一个前端代码，只要有改动，就需要重新编译java代码，生成新的class文件，打一个新的war包,重新发布</li>
</ul>
</li>
</ul>
</li>
<li>思考一下，如果是你的话，你准备怎么解决这个问题?<ul>
<li>思路很重要。使用什么样的思路去做、去解决这个问题<ul>
<li>上面的那个Servlet (Java程序)能不能不写了，让机器自动生成。我们程序员只需要写这个Serlet程序中的′前端的那段代码”，然后让机器将我们写的”前端代码”自动翻译生成”Serulet这种java程序”。然后机器再自动将”iava”程序编译生成”class”文件。然后再使用JMM调用这个class中的方法。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="关于B-x2F-S结构系统的会话机制（session）"><a href="#关于B-x2F-S结构系统的会话机制（session）" class="headerlink" title="关于B&#x2F;S结构系统的会话机制（session）"></a>关于B&#x2F;S结构系统的会话机制（session）</h3><ul>
<li>什么是会话?<ul>
<li>会话对应的英语单词: session</li>
<li>用户打开浏览器，进行一系列操作，然后最终将浏览器关闭，这个整个过程叫做:一次会话。会话在服务器端也有一个对应的java对象，这个java对象叫做:session。</li>
<li>回顾：什么是一次请求:用户在浏览器上点击了一下，然后到页面停下来，可以粗略认为是一次请求。请求对应的服务器端的java对象是: request。</li>
<li><strong>一个会话当中包含多次请求。(一次会话对应N次请求。</strong>)</li>
</ul>
</li>
<li>在java的servlet规范当中，session对应的类名: HttpSession (jarkata.servlet.http.HttpSession)</li>
<li>session机制属于B&#x2F;S结构的一部分。如果使用php语言开发WEB项目，同样也是有session这种机制的。session机制实际上是一个规范。然后不同的语言对这种会话机制都有实现。</li>
<li>session对象最主要的作用是:保存会话状态。(用户登录成功了，这是一种登录成功的状态，你怎么把登录成功的状态一直保存下来呢?使用session对象可以保留会话状态。)</li>
<li>为什么需要session对象来保存会话状态呢?<ul>
<li>因为HTTP协议是一种无状态协议。</li>
<li>什么是无状态:请求的时候，B和S是连接的，但是请求结束之后，连接就断了。为什么要这么做?HTTP协议为什么要设计成这样?因为这样的无状态协议，可以降低服务器的压力。请求的瞬间是连接的，请求结束之后，连接断开，这样服务器压力小,</li>
<li>只要B和S断开了，那么关闭浏览器这个动作，服务器知道吗?<ul>
<li>不知道。服务器是不知道浏览器关闭的。</li>
</ul>
</li>
</ul>
</li>
<li>张三打开一个浏览器A，李四打开一个浏览器B，访问服务器之后，在服务器端会生成:<ul>
<li>张三专属的session对象</li>
<li>李四专属的session对象</li>
</ul>
</li>
<li>为什么不使用request对象保存会话状态?为什么不使用ServletContext对象保存会话状态?<ul>
<li>request.setAttribute()存，request.getAttribute()取，ServletContext也有这个方法。request是请求域。ServletContext是应用域。</li>
<li>request是一次请求一个对象。</li>
<li>ServletContext对象是服务器启动的时候创建，服务器关闭的时候销毁，这个ServletContext对象只有一个。</li>
<li>ServletContext对象的域太大。</li>
<li>ServletContext对象是服务器启动的时候创建，服务器关闭的时候销毁，这个SeruletContext对象只有一个。</li>
<li>ServletContext对象的域太大。</li>
<li>request请求域(HttpServletReguest) . session会话域(HlttpSession)、 application域.(SeruletContext)</li>
<li>request &lt; session &lt; application</li>
</ul>
</li>
<li>思考一下: session对象的实现原理。<ul>
<li>HttpSession session &#x3D; request.getSession();</li>
<li>这行代码很神奇。张三访问的时候获取的session对象就是张三的。李四访问的时候获取的session对象就是李四的。</li>
</ul>
</li>
<li>session的实现原理:<ul>
<li>ISESSIONID&#x3D;xXXXXX这个是以Cookie的形式保存在浏览器的内存中的。浏览器只要关闭。这个cookie就没有了。</li>
<li>session列表是一个Map,map的key是sessionid,map的value是session对象。</li>
<li>用户第一次请求，服务器生成session对象，同时生成id，将id发送给浏览器。</li>
<li>用户第二次请求，自动将浏览器内存中的id发送给服务器，服务器根据id查找session对象。</li>
<li>关闭浏览器，内存消失，cookie消失,s.essionid消失，会话等同于结束。</li>
</ul>
</li>
<li>Cookie禁用了，session还能找到吗?<ul>
<li>cookie禁用是什么意思?服务器正常发送cookie给浏览器，但是浏览器不要了。拒收了。并不是服务器不发了。。找不到了。每一次请求都会获取到新的session对象。</li>
<li>cookie禁用了, session机制还能实现吗?<ul>
<li>可以。需要使用URL重写机制。</li>
<li>http:&#x2F;localhost:8080&#x2F;servlet12&#x2F;test&#x2F;session;jsessionid&#x3D;19D1C99560DCBF84839FA43D58F56E16</li>
<li>URL重写机制会提高开发者的成本。开发人员在编写任何请求路径的时候，后面都要添加一个sessionid，给开发带来了很大的难度，很大的成本。所以大部分的网站都是这样设计的:你要是禁用cookie，你就别用了。</li>
</ul>
</li>
</ul>
</li>
<li>总结—下到目前位置我们所了解的域对象:<ul>
<li>request (对应的类名:HttpServletRequest)<ul>
<li>请求域（请求级别）</li>
</ul>
</li>
<li>session (对应的类名:Httpsession)<ul>
<li>会话域（用户级别）</li>
</ul>
</li>
<li>application(对应的类名:ServletContext)<ul>
<li>应用域（项目级别的，所以用户共享的）</li>
</ul>
</li>
<li>这三个域对象的大小关系<ul>
<li>request &lt; session &lt; application</li>
</ul>
</li>
<li>他们三个域对象都有以下三个公共的方法:<ul>
<li>setAttribute(向域当中绑定数据)</li>
<li>getAttribute (从域当中获取数据)</li>
<li>removeAttribute (删除域当中的数据)</li>
</ul>
</li>
<li>使用原则：尽量使用小的域</li>
</ul>
</li>
<li>session掌握之后，我们怎么解决oa项目中的登录问题，怎么能让登录起作用。<ul>
<li>登录成功之后，可以将用户的登录信息存储到session当中。也就是说session中如果有用户的信息就代表用户登录成功了。session中没有用户信息，用户没有登录过。则跳转到登录页面。</li>
</ul>
</li>
<li>销毁session对象:<ul>
<li><strong>session.invalidate();</strong></li>
</ul>
</li>
<li><h2 id><a href="#" class="headerlink" title="- "></a>- </h2>- </li>
<li><strong>浏览器关闭的时候，服务器无法检测到浏览器关闭了，所以session的销毁要依靠session超时机制，但也有一种可能“系统提供了“安全退出”，用户可以点击这个按钮，这样浏览器就知道你退出了，然后服务器会自动销毁session对象</strong><ul>
<li><img src="/2022/10/26/JAVAWEB-2/2.png" alt="2"></li>
</ul>
</li>
</ul>
<p><img src="/2022/10/26/JAVAWEB-2/1.png" alt="image-20221024134724850"></p>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><ul>
<li><p>session的实现原理中，每一个session对象都会关联一个sessionid，例如:</p>
<ul>
<li>JSESSIONID&#x3D;41C481F0224664BDB28E95081D23D5B8</li>
<li>以上的这个键值对数据其实就是cookie对象。</li>
<li>对于session关联的cookie来说，这个cookie是被保存在浏览器的“运行内存”当中。</li>
<li>只要浏览器不关闭，用户再次发送请求的时候，会自动将运行内存中的cookie发送给服务器。</li>
<li>例如，这个Cookie: JSESSIONID&#x3D;41C481F0224664BDB28E95081D23D5B8就会再次发送给服务器。</li>
<li>服务器就是根据41C481F0224664BDB28E95081D23D5B8这个值来找到对应的session对象的。</li>
</ul>
</li>
<li><p>cookie怎么生成? cookie保存在什么地方? cookie有啥用?浏览器什么时候会发送cookie，发送哪些cookie给服务器? ?? ? ? ? ?.</p>
</li>
<li><p>cookie最终是保存在浏览器客户端上的。</p>
<ul>
<li>可以保存在运行内存中。(浏览器只要关闭cookie就消失了。)</li>
<li>也可以保存在硬盘文件中。(永久保存。)</li>
</ul>
</li>
<li><p>cookie有啥用呢?</p>
<ul>
<li>cookie和session机制其实都是为了保存会话的状态。</li>
<li>cookie是将会话的状态保存在浏览器客户端上。(cookie数据存储在浏览器客户端上的。)</li>
<li>session是将会话的状态保存在服务器端上。(session对象是存储在服务器上。)</li>
<li>为什么要有cookie和session机制呢?因为HTTP协议是无状态无连接协议。</li>
</ul>
</li>
<li><p>cookie的经典案例</p>
<ul>
<li>京东商城，在未登录的情况下，向购物车中放几件商品。然后关闭商城，再次打开浏览器，访问京东商城的时候，购物车中的商品还在，这是怎么做的我没有登录，为什么购物车中还有商品呢?<ul>
<li>将购物车中的商品编号放到cookie当中,cookie保存在硬盘文件当中。这样即使关闭浏览器。硬盘上的cookie还在。下一次再打开京东商城的时候查看购物车的时候，会自动读取本地硬盘中存储的cookie，拿到商品编号，动态展示购物车中的商品。<ul>
<li>京东存储购物车中商品的cookie可能是这样的: productlds&#x3D;xXxxx,Y,zzz,kkkk</li>
<li>注意:cookie如果清除掉，购物车中的商品就消失了。</li>
</ul>
</li>
</ul>
</li>
<li>126邮箱中有—个功能:十天内免登录<ul>
<li>这个功能也是需要cookie来实现的。</li>
<li>怎么实现的呢?<ul>
<li>用户输入正确的用户名和密码，并且同时选择十天内兔登录。登录成功后。浏览器客户端会保存一个cookie，这个cookie中保存了用户名和密码等信息，这个cookie是保存在硬盘文件当中的，十天有效。在十天内用户再次访问126的时候，浏览器自动提交126的关联的cookie给服务器,服务器接收到cookie之后，获取用户名和密码，验证，通过之后，自动登录成功。</li>
<li>怎么让cookie失效?<ul>
<li>十天过后自动失效。</li>
<li>或者改密码。</li>
<li>或者在客户端浏览器上清除cookie。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>cookie机制和session机制其实都不属于java中的机制，实际上cookie机制和session机制都是HTTP协议的一部分。php开发中也有cookie和session机制，只要是你是做web开发，不管是什么编程语言，cookie和session机制都是需要的。</p>
</li>
<li><p>HTTP协议中规定:任何一个cookie都是由name和value组成的。name和value都是字符串类型的。</p>
</li>
<li><p>在java的servlet中，对cookie提供了哪些支持呢?</p>
<ul>
<li>提供了一个Cookie类来专门表示cookie数据。jakarta.servlet.http.Cookie;		</li>
<li>java程序怎么把cookie数据发送给浏览器呢?  <strong>response.addCookie(cookie);</strong></li>
</ul>
</li>
<li><p><strong>在HTTP协议中是这样规定的:当浏览器发送请求的时候，会自动携带该path下的cookie数据给服务器。</strong>(URL)</p>
</li>
<li><p>关于cookie的有效时间</p>
<ul>
<li>怎么用java设置cookie的有效时间<ul>
<li>cookie.setMaxAge(60 * 60);设置cookie在—小时之后失效。</li>
</ul>
</li>
<li>没有设置有效时间:默认保存在浏览器的运行内存中，浏览器关闭则cookie消失</li>
<li>只要设置cookie的有效时间&gt;0，这个cookie一定会存储到硬盘文件当中。</li>
<li>设置cookie的有效时间&#x3D;0呢?<ul>
<li>cookie被删除，同名cookie被删除。</li>
</ul>
</li>
<li>设置cookie的有效时间&lt;0呢?<ul>
<li>保存在运行内存中。和不设置一样。</li>
</ul>
</li>
</ul>
</li>
<li><p>关于cookie的path,cookie关联的路径:</p>
<ul>
<li>假设现在发送的请求路径是”http:llocalhost8080&#x2F;servlet13&#x2F;cookielgenerate”生成的cookie，如果cooke没有设置path，默认的path是什么?<ul>
<li><strong>默认的path是:<a target="_blank" rel="noopener" href="http://localhost:8080/servlet13/cookie%E4%BB%A5%E5%8F%8A%E5%AE%83%E7%9A%84%E5%AD%90%E8%B7%AF%E5%BE%84%E3%80%82">http://localhost:8080/servlet13/cookie以及它的子路径。</a></strong></li>
<li>也就是说，以后只要浏览器的请求路径是http:&#x2F;localhost.8080&#x2F;servlet13&#x2F;cookie这个路径以及这个路径下的子路径，cookie都会被发送到服务器。</li>
</ul>
</li>
<li>手动设置cookie的path<ul>
<li>cookie.setPath(“&#x2F;servlet13”);表示只要是这个servlet13项目的请求路径，都会提交这个cookie给服务器。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>浏览器发送cookie给服务器了，服务器中的java程序怎么接收?</strong></p>
<ul>
<li>&#96;&#96;&#96;java<br>Cookie[] cookies &#x3D; request.getCookies();&#x2F;&#x2F;这个方法可能返回nu1l<br>if(cookies !&#x3D; nu11){<br>    for (Cookie cookie : cookies){<br>        &#x2F;&#x2F;获取cookie的name<br>        String name &#x3D; cookie.getName();<br>        &#x2F;&#x2F;获取cookie的value<br>        String value &#x3D; cookie.getvalue(;<br>}<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 使用cookie实现一下十天内免登录功能。</span><br><span class="line"></span><br><span class="line">## JSP</span><br><span class="line"></span><br><span class="line">我的第一个ISP程序:</span><br><span class="line"></span><br><span class="line">- 在WEB-INF目录之外创建一个index.isp文件，然后这个文件中没有任何内容。</span><br><span class="line"></span><br><span class="line">将上面的项目部署之后，启动服务器，打开浏览器，访问以下地址:</span><br><span class="line"></span><br><span class="line">-  http://localhost:8080ljsp/index.jsp展现在大家面前的是一个空白。</span><br><span class="line">-  实际上访问以上的这个: index.isp，底层执行的是: index_jsp.class这个java程序。</span><br><span class="line">-  这个index.isp会被tomcat翻译生成index_jsp.iaxa文件，然后tomcat服务器又会将index_jsp.iava编译生成index_sp.class文件</span><br><span class="line">-  访问index.isp，实际上执行的是index_jsp.class中的方法。</span><br><span class="line"></span><br><span class="line">JSP实际上就是一个Serxlet。</span><br><span class="line"></span><br><span class="line">- index.jsp访问的时候，会自动翻译生成index jsp.iaxa，会自动编译生成index_jsp.class，那么index_jsp.这就是一个类。</span><br><span class="line">- index_jsp,类继承HttplIspBase，而HttplspBase类继承的是HttpServlet。所以index_jsp类就是一个Servlet类。</span><br><span class="line">- jsp的生命周期和Servlet的生命周期完全相同。完全就是一个东西。没有任何区别。</span><br><span class="line">- jsp和serxlet一样，都是单例的。(假单例。)</span><br><span class="line"></span><br><span class="line">jsp文件第一次访问的时候是比较慢的，为什么?</span><br><span class="line"></span><br><span class="line">- 为什么大部分的运维人员在给客户演示项目的时候，为什么提前先把所有的isp文件先访问一遍。</span><br><span class="line">- 第一次比较麻烦:</span><br><span class="line">  - 要把jsp文件翻译生成java源文件</span><br><span class="line">  - java源文件要编译生成class字节码文件</span><br><span class="line">  - 然后通过class去创建servlet对象</span><br><span class="line">  - 然后调用servlet对象的init方法</span><br><span class="line">  - 最后调用servlet对象的service方法。</span><br><span class="line">- 第二次就比较快了，为什么?</span><br><span class="line">  - 因为第二次直接调用单例servlet对象的service方法即可</span><br><span class="line"></span><br><span class="line">JSP是什么?</span><br><span class="line"></span><br><span class="line">- JSP是java程序。(JSP本质还是一个Servlet)</span><br><span class="line">- JSP是: JavaServer Pages的缩写。(基于Java语言实现的服务器端的页面。)</span><br><span class="line">- Servlet是JavaEE的13个子规范之一，那么ISP也是JavaEE的13个子规范之一。</span><br><span class="line">- JSP是一套规范。所有的web容器/web服务器都是遵循这套规范的，都是按照这套规范进行的“翻译”。</span><br><span class="line">- 每一个web容器/web服务器都会内置一个ISP翻译引擎。</span><br><span class="line"></span><br><span class="line">对JSP进行错误调试的时候，还是要直接打开ISP文件对应的java文件，检查java代码。</span><br><span class="line"></span><br><span class="line">开发JSP的最高境界:</span><br><span class="line"></span><br><span class="line">- 眼前是SP代码，但是脑袋中呈现的是java代码。</span><br><span class="line"></span><br><span class="line"> JSP既然本质上是一个Servlet，那么JSP和Servlet到底有什么区别呢?</span><br><span class="line"></span><br><span class="line">- 职责不同:</span><br><span class="line">  - Serxlet的职责是什么:收集数据。(Serlet的强项是逻辑处理，业务处理，然后链接数据库，获取/收集数据。)</span><br><span class="line">  - JSP的职责是什么:展示数据。(JSP的强项是做数据的展示)</span><br><span class="line"></span><br><span class="line">JSP的基础语法</span><br><span class="line"></span><br><span class="line">- 在jsp文件中直接编写文字，都会自动被翻译到哪里?</span><br><span class="line">  - 翻译到servlet类的service方法的out.write(&quot;翻译到这里&quot;)，直接翻译到双引号里，被java程序当做普通字符串打印输出到流览器。</span><br><span class="line">  - 在jSP中编写的HTML CSS JS代码，这些代码对于ISP来说只是一个普通的字符串。但是jSP把这个普通的字符串一旦输出到流览器，浏览器就会对HTML CSS S进行解释执行。展现一个效果。</span><br><span class="line"></span><br><span class="line">- JSP的page指令(这个指令后面再详细说，这里先解决一下中文乱码问题)，解决响应时的中文乱码问题:</span><br><span class="line">  - 通过page指令来设置响应的内容类型，在内容类型的最后面添加: charset=UTF-8</span><br><span class="line">    - &lt;%@page contentType=&quot;text/ntml;charset=UTF-8&quot;%&gt;，表示响应的内容类型是text/html，采用的字符集UTF-8</span><br><span class="line">- 登录功能实现了，目前存在的最大的问题:</span><br><span class="line">- 这个登录功能目前只是一个摆设，没有任何作用。只要用户知道后端的请求路径，照样可以在不登录的情况下访问。。这个登录没有真正起到拦截的作用。怎么解决?</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- ####  JSP的指令</span><br><span class="line"></span><br><span class="line">  - 指令的作用:</span><br><span class="line"></span><br><span class="line">    - 指导ISP的翻译引擎如何工作(指导当前的lSP翻译引擎如何翻译ISP文件。)</span><br><span class="line"></span><br><span class="line">  - 指令包括哪些呢?</span><br><span class="line"></span><br><span class="line">    - include指令:包含指令，在ISP中完成静态包含，很少用了。(这里不讲)</span><br><span class="line">    - taglib指令:引入标签库的指令。这个到SIL标签库的时候再学习。现在先不管。</span><br><span class="line">    - page指令:目前重点学习一个page指令。</span><br><span class="line"></span><br><span class="line">  - 指令的使用语法是什么?</span><br><span class="line"></span><br><span class="line">    - &lt;%@指令名属性名=属性值属性名=属性值属性名=属性值....%&gt;。</span><br><span class="line"></span><br><span class="line">  - 关于page指令当中都有哪些常用的属性呢?</span><br><span class="line"></span><br><span class="line">    - ```jsp</span><br><span class="line">      &lt;@page session=&quot;true |false&quot;%&gt;</span><br><span class="line">      true表示启用3SP的内置对象session,表示一定启动session对象。没有session对象会创建。</span><br><span class="line">      如果没有设置，黑认值就是session=&quot;true&quot;</span><br><span class="line">      session=&quot;false&quot;表示不启动内置对象session。当前&quot;SP页面中无法使用内置对象session。</span><br><span class="line">      </span><br><span class="line">      &lt;%@page contentType=&quot;text/json&quot;%&gt;</span><br><span class="line">      contentType属性用来设置响应的内容类型</span><br><span class="line">      但同时也可以设置字符集。</span><br><span class="line">      &lt;%@page contentType=&quot;text/json ; charset=UTF-8&quot;%&gt;</span><br><span class="line">      </span><br><span class="line">      &lt;%@page pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line">      pageEncoding=&quot;UTF-8”表示设置响应时采用的字符集。</span><br><span class="line">      </span><br><span class="line">      &lt;%@page import=&quot;java.uti7.List，java.uti1.Date，java.uti7.ArrayList&quot;%&gt;</span><br><span class="line">      &lt;%@page import=&quot;java.util.☆&quot;%&gt;</span><br><span class="line">      import语句，导包。</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      &lt;%@page errorPage=&quot; / error .jsp”%&gt;</span><br><span class="line">          </span><br><span class="line">      </span><br><span class="line">      &lt;%@page isErrorPage=&quot;true&quot;%&gt;表示启用JSP九大内置对象之一:exception默认值是false。</span><br><span class="line">      </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>JSP的九大内置对象</p>
<ul>
<li>jakarta.servlet.jsp.PageContext pageContext页面作用域</li>
<li>jakarta.servlet.http.HttpServletRequest request请求作用域</li>
<li>jakarta.servlet.http.HttpSession session会话作用域</li>
<li>jakarta.servlet.ServletContext application应用作用域<ul>
<li>pageContext &lt; request &lt; session &lt; application</li>
<li>以上四个作用域都有: setAttribute、getAttribute、removeAttribute方法。</li>
<li>以上作用域的使用原则:尽可能使用小的域。</li>
</ul>
</li>
<li>java.lang.Throwable excegtion</li>
<li>iakarta.servlet.ServletConfig config</li>
<li>java.lang.Object page(其实是this，当前的servlet对象)</li>
<li>jakarta.servlet.jsp.JspWriter out(负责输出)</li>
<li>jakarta.servlet.http.HttpServletResponse response(负责响应)</li>
</ul>
</li>
</ul>
<h3 id="同学问-包名bean是什么意思"><a href="#同学问-包名bean是什么意思" class="headerlink" title="同学问:包名bean是什么意思?"></a>同学问:包名bean是什么意思?</h3><ul>
<li>javabean (java的logo是一杯冒着热气的咖啡。javabean被翻译为:咖啡豆)</li>
<li>java是一杯咖啡，咖啡又是由一粒一粒的咖啡豆研磨而成。</li>
<li>整个java程序中有很多bean的存在。由很多bean组成。</li>
<li>什么是iavabean?实际上javabean你可以理解为符合某种规范的java类，比如:<ul>
<li>有无参数构造方法</li>
<li>属性私有化</li>
<li>对外提供公开的set和get方法</li>
<li>实现java.io.Serializable接口</li>
<li>重写toString</li>
<li>重写hashCode+equals</li>
<li>………..</li>
</ul>
</li>
<li>javabean其实就是java中的实体类。负责数据的封装。</li>
<li>由于iavabean符合javabean规范，具有更强的通用性。</li>
</ul>
<h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><ul>
<li><p>EL表达式是干什么用的?</p>
<ul>
<li>Expression Language(表达式语言)</li>
<li>EL表达式可以代替lSP中的iava代码，让ISP文件中的程序看起来更加整洁，美观。</li>
<li>JSP中夹杂着各种java代码，例如 &lt;% java代码%&gt;、&lt;%&#x3D;%&gt;等，导致JSP文件很混乱，不好看，不好维护。所以才有了后期的EL表达式。</li>
<li>EL表达式可以算是JSP语法的一部分。EL表达式归属于JSP。</li>
</ul>
</li>
<li><p>EL表达式出现在ISP中主要是:</p>
<ul>
<li>从某个作用域中取数据，然后将其转换成字符串，然后将其输出到浏览器。这就是EL表达式的功效。三大功效:<ul>
<li>第一功效:从某个域中取数据。<ul>
<li>四个域:<ul>
<li>pageContext</li>
<li>request</li>
<li>session</li>
<li>application</li>
</ul>
</li>
</ul>
</li>
<li>第二功效:将取出的数据转成字符串。<ul>
<li>如果是一个java对象，也会自动调用java对象的toString方法将其转换成字符串。</li>
</ul>
</li>
<li>第三功效:将字符串输出到浏览器。<ul>
<li>和这个—样:&lt;%&#x3D; %&gt;，将其输出到浏览器。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>EL表达式很好用，基本的语法格式:</p>
<ul>
<li><p>${表达式}</p>
</li>
<li><pre><code class="jsp">&lt;%@page contentType=&quot;text/html; charset=UTF-8&quot;%&gt;

&lt;%
    //向request作用域当中存储username为Zhangsan.
    request.setAttribute(&quot;username &quot;, &quot;zhangsan&quot;);
%&gt;
&lt;%--将request域当中的数据取出来，并且还要输出到浏览器，使用java代码怎么办?--%&gt;
&lt;%=request.getAttribute(&quot;username &quot;)%&gt;

&lt;%--使用EL表达式呢?--%&gt;
$&#123;username&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```jsp</span><br><span class="line">  &lt;%</span><br><span class="line">      //创建User对象</span><br><span class="line">      User user = new User();</span><br><span class="line">      user.setUsername (&quot;jackson&quot;);</span><br><span class="line">      user.setPasswor d(&quot;1234&quot;);</span><br><span class="line">      user.setAge(50);</span><br><span class="line">      //将User对象存储到某个域当中。一定要存，因为EL表达式只能从某个范围中取数据。</span><br><span class="line">      //数据是必须存储到四大范围之一的。</span><br><span class="line">      request.setAttribute( &quot;userobj&quot;, user);</span><br><span class="line">  %&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;%--使用EL表达式取--%&gt;</span><br><span class="line">  $&#123;这个位置写什么????这里写的一定是存储到域对象当中时的name&#125;</span><br><span class="line">  要这样写:</span><br><span class="line">  $&#123;userobj&#125;</span><br><span class="line">  等同于java代码:&lt;%=request.getAttribute(&quot;userobj&quot;)%&gt;</span><br><span class="line">  你不要这样写: $&#123;&quot;userobj&quot;&#125;</span><br><span class="line">  </span><br><span class="line">  面试题:</span><br><span class="line">  $&#123;abc&#125;和$&#123; &quot;abc&quot;&#125;的区别是什么?</span><br><span class="line">  $&#123;abc]&#125;表示从某个域中取出数据，并且被取的这个数据的name是&quot; abc&quot;，之前一定有这样的代码:域.setAttribute(&quot;abc&quot;，对象);</span><br><span class="line">  $&#123; &quot;abc&quot;&#125;表示直接将&quot;abc&quot;当做普通字符串输出到浏览器。不会从某个域中取数据了。</span><br><span class="line">  </span><br><span class="line">  $&#123;userobj]底层是怎么做的?从域中取数据，取出user对象，然后调用user对象的toString方法，转换成字符串，输出到浏览器。</span><br><span class="line">  </span><br><span class="line">  &lt;%--如果想输出对象的属性值，怎么办?--%&gt;</span><br><span class="line">  $&#123;userobj.username&#125;使用这个语法的前提是:user对象有getusername()方法。</span><br><span class="line">  $&#123;userobj.password&#125;使用这个语法的前提是:user对象有getPassword()方法。</span><br><span class="line">  $&#123;userobj.age&#125;使用这个语法的前提是:user对象有getAge()方法。</span><br><span class="line">  $&#123;userobj.email&#125;使用这个语法的前提是:user对象有getEmai1()方法。</span><br><span class="line">  EL表达式中的．这个语法，实际上调用了底层的getxxx()方法。</span><br><span class="line">  注意:如果没有对应的get方法，则出现异常。报500错误。</span><br><span class="line">  $&#123;userobj .addr222.zipcode&#125;</span><br><span class="line">  以上EL表达式对应的java代码:</span><br><span class="line">  user. getAddr222O.getzipcode(</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>EL表达式优先从小范围中读取数据。</p>
<ul>
<li>pageContext &lt; request &lt; session &lt; application。</li>
</ul>
</li>
<li><p>EL表达式中有四个隐含的隐式的范围:</p>
<ul>
<li>pageScope 对应的是pageContext范围。</li>
<li>requestScope 对应的是request范围。</li>
<li>sessionScope 对应的是session范围。</li>
<li>applicationScope对应的是application范围。</li>
</ul>
</li>
<li><p>EL表达式对null进行了预处理。如果是null，则向浏览器输出一个空字符串。</p>
</li>
<li><p>EL表达式取数据的时候有两种形式:</p>
<ul>
<li>第一种:﹒(大部分使用这种方式)</li>
<li>第二种:<a href="%E5%A6%82%E6%9E%9C%E5%AD%98%E5%82%A8%E5%88%B0%E5%9F%9F%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E8%BF%99%E4%B8%AAname%E4%B8%AD%E5%90%AB%E6%9C%89%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%5B%5D"></a><ul>
<li>request.setAttribute(“abc.def” , “zhangsan”);</li>
<li>${requestScope.abc.def}这样是无法取值的。</li>
<li>应该这样: ${requestScope[“abc.def”]）</li>
</ul>
</li>
</ul>
</li>
<li><p>掌握使用L表达式，怎么从Map集合中取数据:</p>
<ul>
<li>${map.key}</li>
</ul>
</li>
<li><p>掌握使用EL表达式，怎么从数组中取数据:</p>
<ul>
<li>${数组[0]}</li>
<li>${数组[1]}</li>
<li>${数组[2]}</li>
<li>${list[0]}</li>
</ul>
</li>
<li><p>page指令当中，有一个属性，可以忽略E印L表达式</p>
<ul>
<li><p>&#96;&#96;&#96;jsp<br>&lt;%@page contentType&#x3D;”text&#x2F;htm1;charset&#x3D;UTF-8” isELIgnored&#x3D;”true”%&gt;<br>isELIgnored&#x3D;”true”表示忽略EL表达式<br>isELIgnored&#x3D;”false”表示不忽略EL表达式。(这是默认值)</p>
<p>isELIgnored&#x3D;”true”这个是全局的控制。</p>
<p>可以使用反斜杠进行局部控制:${username}这样也可以忽略EL表达式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 通过EL表达式获取应用的根:</span><br><span class="line"></span><br><span class="line">    - $&#123;pageContext.request.contextPath&#125;</span><br><span class="line"></span><br><span class="line">  - EL表达式中其他的隐式对象:</span><br><span class="line"></span><br><span class="line">    - pageContext</span><br><span class="line">    - param</span><br><span class="line">    - paramalues</span><br><span class="line">    - initParam</span><br><span class="line"></span><br><span class="line">  - EL表达式的运算符</span><br><span class="line"></span><br><span class="line">    - empty运算符</span><br><span class="line">      - empty运算符的结果是boolean类型</span><br><span class="line">      - $&#123;empty param.username&#125;</span><br><span class="line">      - $&#123;not empty param.username&#125;</span><br><span class="line">      - $&#123;(lempty param.password&#125;</span><br><span class="line"></span><br><span class="line">## JSTL标签库</span><br><span class="line"></span><br><span class="line">- 什么是ISTL标签库?</span><br><span class="line"></span><br><span class="line">  -  Java Standard Tag Lib (Java标准的标签库)</span><br><span class="line">  -  JSTL标签库通常结合EL表达式一起使用。目的是让ISP中的java代码消失。</span><br><span class="line">  -  标签是写在[SP当中的，但实际上最终还是要执行对应的java程序。(java程序在jar包当中。)</span><br><span class="line"></span><br><span class="line">- 使用ISTL标签库的步骤:</span><br><span class="line"></span><br><span class="line">  - 第一步:引入ISIL标签库对应的jar包。</span><br><span class="line"></span><br><span class="line">    - tomcat10之后引入的jar包是:</span><br><span class="line">      - jakarta.servlet.jsp.jstl-2.0.0.jar</span><br><span class="line">      - taglibs-standard-impl-1.2.5.jar</span><br><span class="line">      - taglibs-standard-spec-1.2.5.jar</span><br><span class="line">    - 在IDEA当中怎么引入?</span><br><span class="line">      - 在WEB-INF下新建lib目录，然后将jar包拷贝到lib当中。然后将其&quot;Add Lib...&quot;</span><br><span class="line">      - 一定是要和mysqI的数据库驱动一样，都是放在WEB-INF/lib目录下的。</span><br><span class="line">      - 什么时候需要将jar包放到WEB-INF/lib目录下?如果这个jar是tomcat服务器没有的。</span><br><span class="line"></span><br><span class="line">  - 第二步:在ISP中引入要使用标签库。(使用taglib指令引入标签库。)</span><br><span class="line"></span><br><span class="line">    - JSIL提供了很多种标签，你要引入哪个标签????重点掌握核心标签库。</span><br><span class="line"></span><br><span class="line">    - ```jsp</span><br><span class="line">      &lt;%@t aglib prefix=&quot;c &quot; uri=&quot;http://java.sun.com/jsp/jst1/core&quot; %&gt;</span><br><span class="line">      这个就是核心标签库。</span><br><span class="line">      prefix=&quot;这里随便起一个名字就行了，核心标签库，大家默认的叫做c，你随意。&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>第三步:在需要使用标签的位置使用即可。表面使用的是标签，底层实际上还是java程序。</strong>.</p>
</li>
<li><p>JSTL标签的原理</p>
<ul>
<li>&#96;&#96;&#96;jsp<br>&lt;%@taglib prefix&#x3D;”c “ uri&#x3D;”<a target="_blank" rel="noopener" href="http://java.sun.com/jsp/jst1/core&quot;">http://java.sun.com/jsp/jst1/core&quot;</a> %&gt;<br>以上uri后面的路径实际上指向了一个xxx.t1d文件。<br>tld文件实际上是一个xml配置文件。<br>在tld文件中描述了“标签”和”java类”之间的关系。<br>以上核心标签库对应的tld文件是:c.tld文件。它在哪里。<br>在jakarta.servlet.jsp.jst1-2.0.0.jar里面META-INF目录下，有一个c.tld文件。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 源码解析:配置文件tld解析</span><br><span class="line"></span><br><span class="line">  - ```tld</span><br><span class="line">    &lt;tag&gt;</span><br><span class="line">    	&lt;description&gt;</span><br><span class="line">        catches any Throwable that occurs in its body and optionallyexposes it.</span><br><span class="line">        &lt;/description&gt;</span><br><span class="line">        &lt;name&gt;catch&lt;/name&gt;</span><br><span class="line">        &lt;tag-class&gt;org.apache.taglibs.standard.tag.common.core.CatchTag&lt;/tag-class&gt;</span><br><span class="line">        &lt;body-content&gt;]SP&lt;/body-content&gt;</span><br><span class="line">        &lt;attribute&gt;</span><br><span class="line">        	&lt;description&gt;</span><br><span class="line">        Name of the exported scoped variable for the</span><br><span class="line">        exception thrown from a nested action. The type of thescoped variable is the type of the exception thrown.</span><br><span class="line">       	 	&lt;/description&gt;</span><br><span class="line">        &lt;name&gt;var&lt;/name&gt;</span><br><span class="line">        &lt;required&gt;false&lt;/required&gt;</span><br><span class="line">        &lt;rtexprvalue&gt;false&lt;/rtexprvalue&gt;&lt;/ attribute&gt;</span><br><span class="line">    &lt;/tag&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>o jstl中的核心标签库core当中有哪些常用的标签呢?</p>
<ul>
<li><p>c:if</p>
<ul>
<li><p><cif test="boolean类型，支持EL表达式">&lt;&#x2F;c: if&gt;</cif></p>
</li>
<li><p>c:forEach</p>
</li>
<li><p>&lt;c:forEach items&#x3D;”集合，支持EL表达式” var&#x3D;”集合中的元素” varStatus&#x3D;”元素状态对象”&gt;${元素状态对象.count}&lt;&#x2F;c: forEach&gt;</p>
</li>
<li><p>&lt;c:forEach var&#x3D;”i” begin&#x3D;”1” end&#x3D;”10” step&#x3D;”2”&gt;${i}&lt;&#x2F;c: forEach&gt;</p>
</li>
<li><p>c:choose c:when cotherwise</p>
</li>
<li><p>&#96;&#96;&#96;jsp<br>&lt;c:choose&gt;<br>&lt;c:when test&#x3D;”$iparam. age &lt; 18} “&gt;<br>    青少年<br><br>&lt;c:when test&#x3D;”${param.age &lt; 35}”&gt;<br>    青年<br><br>&lt;c:when test&#x3D;”${param. age &lt; 55}”&gt;<br>    中年<br><br>&lt;c:otherwise&gt;<br>    老年<br><br></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 改造OA</span><br><span class="line"></span><br><span class="line">- 使用什么技术改造呢?</span><br><span class="line">  - Servlet+ SP+EL表达式＋JSIL标签。进行改造。</span><br><span class="line">- 在前端HTML代码中，有一个标签，叫做base标签，这个标签可以设置整个网页的基础路径。</span><br><span class="line">  - 这不是Java的语法，也不是JSP的语法。是HTML中的一个语法。HTML中的一个标签。通常出现在head标签中。</span><br><span class="line">  - 在当前页面中，凡是路径没有以&quot;&quot;&quot;开始的，都会自动将base中的路径添加到这些路径之前。</span><br><span class="line">    - &lt;a href=&quot;ab/def&quot;&gt;&lt;l a&gt;</span><br><span class="line">    - 等同于: &lt;a href=&quot;http://localhost:8080/oa/ab/def&quot;&gt;&lt;/ a&gt;</span><br><span class="line">  - 需要注意:在IS代码中的路径，保险起见，最好不要依赖base标签。JS代码中的路径最好写上全路径。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## Filter过滤器</span><br><span class="line"></span><br><span class="line">- 当前的OA项目存在什么缺陷?</span><br><span class="line">  - DeptSenilet. EmgSernwlet Orderserwlet。每一个Sernlet都是处理自己相关的业务。在这些Senwlet执行之前都是需要判断用户是否登录了。如果用户登录了，可以继续操作，如果没有登录，需要用户登录。这段判断用户是否登录的代码是固定的，并且在每一个Servlet类当中都需要编写，显然代码没有得到重复利用。包括每一个Serdlet都要解决中文乱码问题，也有公共的代码。这些代码目前都是重复编写，并没有达到复用。怎么解决这个问题?</span><br><span class="line">    - 可以使用Servlet规范中的Filter过滤器来解决这个问题。</span><br><span class="line">- Filter是什么，有什么用，执行原理是什么?</span><br><span class="line">  - Filter是过滤器。</span><br><span class="line">  - Filter可以在Servlet这个目标程序执行之前添加代码。也可以在目标Serlet执行之后添加代码。之前之后都可以添加过滤规则</span><br><span class="line">  - 一般情况下，都是在过滤器当中编写公共代码。</span><br><span class="line">- 一个过滤器怎么写呢?</span><br><span class="line">  - 第一步:编写一个ava类实现一个接口: jarkata.servlet.Filter。并且实现这个接口当中所有的方法。</span><br><span class="line">    - init方法:在Filter对象第一次被创建之后调用，并且只调用一次。</span><br><span class="line">    - doFilter方法:只要用户发送一次请求，则执行一次。发送N次请求，则执行N次。在这个方法中编写过滤规则。</span><br><span class="line">    - destroy方法:在Filter对象被释放/销毁之前调用，并且只调用一次。</span><br><span class="line">  - 第二步:在web.xml文件中对Filter进行配置。这个配置和Servlet很像。</span><br><span class="line">    - 注意:</span><br><span class="line">      -  Servlet对象默认情况下，在服务器启动的时候是不会新建对象的。o Filter对象默认情况下，在服务器启动的时候会新建对象。</span><br><span class="line">      -  Servlet是单例的。Filter也是单例的。(单实例。)</span><br><span class="line">- 目标Servlet是否执行，取决于两个条件:</span><br><span class="line">  - 第一:在过滤器当中是否编写了: chain.doFilter(request, response);代码。</span><br><span class="line">  - 第二:用户发送的请求路径是否和Servlet的请求路径一致。</span><br><span class="line">- chain.doFilter(request, response);这行代码的作用:</span><br><span class="line">  - 执行下一个过滤器，如果下面没有过滤器了，执行最终的Servlet。</span><br><span class="line">- 注意:Filter的优先级，天生的就比Servlet优先级高。</span><br><span class="line">  - **/a.do对应一个Filter，也对应一个Servlet。那么一定是先执行Filter，然后再执行Serulet.** </span><br><span class="line">- 关于Filter的配置路径:</span><br><span class="line">  - /a.do、/b.do、/dept/save。这些配置方式都是精确匹配。</span><br><span class="line">  - */产匹配所有路径。</span><br><span class="line">  - *.do后缀匹配。不要以/开始</span><br><span class="line">  - /dept/*前缀匹配。</span><br><span class="line">- 在web.xml文件中进行配置的时候，Filter的执行顺序是什么?</span><br><span class="line">  - 依靠filter-mapping标签的配置位置，越靠上优先级越高。</span><br><span class="line">- 过滤器的调用顺序，遵循栈数据结构。</span><br><span class="line">- 使用@WebFilter的时候，Filter的执行顺序是怎样的呢?</span><br><span class="line">  - 执行顺序是:比较Filter这个类名。</span><br><span class="line">  - 比如: FilterA和FilterB，则先执行FilterA。</span><br><span class="line">  - o 比如: Filter1和Eilter2，则先执行Filter.1</span><br><span class="line">- Filter的生命周期?</span><br><span class="line">- 和Servlet对象生命周期一致。</span><br><span class="line">  - 唯一的区别: Filter默认情况下，在服务器启动阶段就实例化。Serulet不会。· Filter过滤器这里有一个设计模式:</span><br><span class="line">- 责任链设计模式。</span><br><span class="line">- Filter过滤器这里有一个设计模式:</span><br><span class="line">  - 责任链设计模式。</span><br><span class="line">  - 过滤器最大的优点:</span><br><span class="line">    - 在程序编译阶段不会确定调用顺序。因为Flter的调用顺序是配置到web.xml文件中的，只要修改web.xml配置文件中flter-mapping的顺序就可以调整Filter的执行顺序。显然Filter的执行顺序是在程序运行阶段动态组合的。那么这种设计模式被称为责任链设计模式。</span><br><span class="line">  - 责任链设计模式最大的核心思想:</span><br><span class="line">    - **在程序运行阶段，动态的组合程序的调用顺序。**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20221024200417153](./JAVAWEB-2/3.png)</span><br><span class="line"></span><br><span class="line">## Listener监听器</span><br><span class="line"></span><br><span class="line">- 什么是监听器?</span><br><span class="line"></span><br><span class="line">  - 监听器是Servlet规范中的一员。就像Filter一样。Filter也是Servlet规范中的一员。</span><br><span class="line">  - 在Servlet中，所有的监听器接口都是以&quot;”Listener&quot;结尾。</span><br><span class="line"></span><br><span class="line">- 监听器有什么用?</span><br><span class="line"></span><br><span class="line">  - 监听器实际上是Servlet规范留给我们javaweb程序员的特殊时机。</span><br><span class="line">  - 特殊的时刻如果想执行这段代码，你需要想到使用对应的监听器。.</span><br><span class="line"></span><br><span class="line">- Servlet规范中提供了哪些监听器?</span><br><span class="line"></span><br><span class="line">  -  jakarta.servlet包下:</span><br><span class="line">     - ServletContextListener</span><br><span class="line">     - servletContextAttributeListener</span><br><span class="line">     - ServletRequestListener</span><br><span class="line">     - ServletRequestAttributeListener</span><br><span class="line">  -  jakarta.servlet.http包下:</span><br><span class="line">     - HttpSessionListener</span><br><span class="line">     - HttpSessionAttributeListener</span><br><span class="line">       - 该监听器需要使用@WebListener注解进行标注。</span><br><span class="line">       - 该监听器监听的是什么?是session域中数据的变化。只要数据变化，则执行相应的方法。主要监测点在session域对象上。</span><br><span class="line">     - HttpSessionBindingListener</span><br><span class="line">     - HttpSessionldListener</span><br><span class="line">       - 该监听器不需要使用@WebListener进行标注。</span><br><span class="line">       - 假设User类实现了该监听器，那么User对象在被放入session的时候触发bind事件，User对象从session中删除的时候，触发unbind事件</span><br><span class="line">       - 假设Customer类没有实现该监听器，那么Customer对象放入session或者从session删除的时候，不会触发bind和unbind事件。</span><br><span class="line">     - HttpSessionActivationListener</span><br><span class="line"></span><br><span class="line">- 实现一个监听器的步骤</span><br><span class="line"></span><br><span class="line">- 实现一个监听器的步骤:以ServletContextListener为例。</span><br><span class="line"></span><br><span class="line">  - 第一步:编写一个类实现ServletContextListener接口。并且实现里面的方法。</span><br><span class="line"></span><br><span class="line">    - ```java</span><br><span class="line">      void contextInitialized(servletContextEvent event)</span><br><span class="line">      void contextDestroyed(servletContextEvent event)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>第二步:在web.xml文件中对ServletContextListener进行配置，如下:</p>
<ul>
<li><pre><code class="xml">&lt;listener&gt;
&lt;listener-class&gt;com.bjpowernode.javaweb.listener .MyServletContextListener&lt;/listener-class&gt;
&lt;/ listener&gt;
</code></pre>
</li>
<li><p>当然，第二步也可以不使用配置文件，也可以用注解，例如:@WebListener</p>
</li>
</ul>
</li>
<li><p>注意:所有监听器中的方法都是不需要javaweb程序员调用的，由服务器来负责调用?什么时候被调用呢?</p>
<ul>
<li>当某个特殊的事件发生（特殊的事件发生其实就是某个时机到了。）之后，被web服务器自动调用。</li>
</ul>
</li>
</ul>
</li>
<li><p>思考一个业务场景:</p>
<ul>
<li>请编写一个功能，记录该网站实时的在线用户的个数。</li>
<li>我们可以通过服务器端有没有分配session对象，因为一个session代表了一个用户。有一个session就代表有一个用户。如果你采用这种逻辑去实现的话,session有多少个，在线用户就有多少个。这种方式的话: HittgSessionListener够用了。session对象只要新建，则count++，然后将count存储到ServletContext域当中，在页面展示在线人数即可。</li>
<li>业务发生改变了，只统计登录的用户的在线数量，这个该怎么办?<ul>
<li>session.setAttribute(“user” , userObj);</li>
<li>用户登录的标志是什么?session中曾经存储过User类型的对象。那么这个时候可以让User类型的对象实现比ittgSessionBindingListener监听器，只要User类型对象存储到session域中，则count++，然后将count++存储到SerletContext对象中。页面展示在线人数即可。</li>
</ul>
</li>
</ul>
</li>
<li><p>实现oa项目中当前登录在线的人数。</p>
<ul>
<li>什么代表着用户登录了?<ul>
<li>session.setAttribute(“user”, userObj); User类型的对象只要往session中存储过，表示有新用户登录。</li>
</ul>
</li>
<li>什么代表着用户退出了?<ul>
<li>session.removeAttribute(“user”); User类型的对象从session域中移除了</li>
<li>或者有可能是session销毁了。(session超时)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="MVC简介"><a href="#MVC简介" class="headerlink" title="MVC简介"></a>MVC简介</h2><p><img src="/2022/10/26/JAVAWEB-2/4.png" alt="image-20221025093319944"></p>
<p><img src="/2022/10/26/JAVAWEB-2/9.png" alt="image-20221025112210463"></p>
<p><img src="/2022/10/26/JAVAWEB-2/6.png" alt="image-20221025111909544"></p>
<p><img src="/2022/10/26/JAVAWEB-2/7.png" alt="image-20221025112001448"></p>
<p><img src="/2022/10/26/JAVAWEB-2/8.png" alt="image-20221025112109652"></p>
<p>&#x2F;&#x2F;思考一下:为什么conn关闭之后，这里要从大Map中移除呢?<br>&#x2F;&#x2F;根本原因是:Tomcat服务器是支持线程池的。也就是说一个人用过了t1线程，t1线程还有可能被其他用户使用。</p>
<p><img src="/2022/10/26/JAVAWEB-2/5.png" alt="image-20221025111803174"></p>
<p>目前项目仍然存在缺陷:<br>1&gt; 在service层控制了事务，service方法中的事务控制代码看着有点别扭，以后能不能不写?? ? ?<br>可以使用动态代理机制解决这个问题。这个自己研究就行了。<br>2&gt;目前虽然面向接口编程了，但是并没有完全解决对象和对象之间的依赖关系。怎么办?可以使用spring的IoC容器来解诀这个间题。<br>对象的创建我不用管了。<br>对象和对象之间关系的管理我也不想管了。都交给spring容器来负责这件事。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Barry</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/10/26/JAVAWEB-2/">http://example.com/2022/10/26/JAVAWEB-2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Barry</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JAVAWEB/">JAVAWEB</a></div><div class="post_share"><div class="social-share" data-image="https://w.wallhaven.cc/full/d6/wallhaven-d65dxg.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/10/26/juc-1/"><img class="prev-cover" src="https://w.wallhaven.cc/full/9d/wallhaven-9d5gpw.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">juc(1)</div></div></a></div><div class="next-post pull-right"><a href="/2022/10/26/JAVAWEB-1/"><img class="next-cover" src="https://w.wallhaven.cc/full/1p/wallhaven-1pj2k3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JAVAWEB(1)</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/myfile/1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Barry</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Servlet"><span class="toc-number">1.</span> <span class="toc-text">Servlet</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Servlet%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.1.</span> <span class="toc-text">Servlet对象的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ServletConfig%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89-%E5%B1%80%E9%83%A8"><span class="toc-number">1.2.</span> <span class="toc-text">ServletConfig（重点）(局部)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.3.</span> <span class="toc-text">HTTP协议</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number"></span> <span class="toc-text">from get servlet</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E4%B8%80%E4%B8%AAweb%E7%AB%99%E7%82%B9%E7%9A%84%E6%AC%A2%E8%BF%8E%E9%A1%B5%E9%9D%A2"><span class="toc-number">0.1.</span> <span class="toc-text">关于一个web站点的欢迎页面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8EWEB-INF%E7%9B%AE%E5%BD%95"><span class="toc-number">0.2.</span> <span class="toc-text">关于WEB-INF目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HttpServletRequest%E6%8E%A5%E5%8F%A3%E8%AF%A6%E8%A7%A3"><span class="toc-number">0.3.</span> <span class="toc-text">HttpServletRequest接口详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BC%98%E5%8C%96oa%E9%A1%B9%E7%9B%AE"><span class="toc-number">0.4.</span> <span class="toc-text">使用模板方法设计模式优化oa项目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E4%BD%BF%E7%94%A8%E7%BA%AF%E7%B2%B9Servlet%E5%BC%80%E5%8F%91web%E5%BA%94%E7%94%A8%E7%9A%84%E7%BC%BA%E9%99%B7"><span class="toc-number">0.5.</span> <span class="toc-text">分析使用纯粹Servlet开发web应用的缺陷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8EB-x2F-S%E7%BB%93%E6%9E%84%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BC%9A%E8%AF%9D%E6%9C%BA%E5%88%B6%EF%BC%88session%EF%BC%89"><span class="toc-number">0.6.</span> <span class="toc-text">关于B&#x2F;S结构系统的会话机制（session）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">- </span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie"><span class="toc-number">1.1.</span> <span class="toc-text">Cookie</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E5%AD%A6%E9%97%AE-%E5%8C%85%E5%90%8Dbean%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D"><span class="toc-number">1.2.</span> <span class="toc-text">同学问:包名bean是什么意思?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EL%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">EL表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVC%E7%AE%80%E4%BB%8B"><span class="toc-number">3.</span> <span class="toc-text">MVC简介</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/10/26/MySQL-3/" title="MySQL(3)"><img src="https://w.wallhaven.cc/full/ex/wallhaven-exo2gr.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL(3)"/></a><div class="content"><a class="title" href="/2022/10/26/MySQL-3/" title="MySQL(3)">MySQL(3)</a><time datetime="2022-10-26T02:08:30.000Z" title="发表于 2022-10-26 10:08:30">2022-10-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/26/MySQL-2/" title="MySQL(2)"><img src="https://w.wallhaven.cc/full/9d/wallhaven-9d59xx.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL(2)"/></a><div class="content"><a class="title" href="/2022/10/26/MySQL-2/" title="MySQL(2)">MySQL(2)</a><time datetime="2022-10-26T02:08:16.000Z" title="发表于 2022-10-26 10:08:16">2022-10-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/26/MySQL-1/" title="MySQL(1)"><img src="https://w.wallhaven.cc/full/l8/wallhaven-l8qjwp.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL(1)"/></a><div class="content"><a class="title" href="/2022/10/26/MySQL-1/" title="MySQL(1)">MySQL(1)</a><time datetime="2022-10-26T02:08:05.000Z" title="发表于 2022-10-26 10:08:05">2022-10-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/26/JDBC/" title="JDBC"><img src="https://w.wallhaven.cc/full/kx/wallhaven-kx9d56.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JDBC"/></a><div class="content"><a class="title" href="/2022/10/26/JDBC/" title="JDBC">JDBC</a><time datetime="2022-10-26T02:07:38.000Z" title="发表于 2022-10-26 10:07:38">2022-10-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/26/juc-1/" title="juc(1)"><img src="https://w.wallhaven.cc/full/9d/wallhaven-9d5gpw.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="juc(1)"/></a><div class="content"><a class="title" href="/2022/10/26/juc-1/" title="juc(1)">juc(1)</a><time datetime="2022-10-26T02:06:04.000Z" title="发表于 2022-10-26 10:06:04">2022-10-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Barry</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'http://example.com/2022/10/26/JAVAWEB-2/'
    this.page.identifier = '/2022/10/26/JAVAWEB-2/'
    this.page.title = 'JAVAWEB(2)'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }

  document.getElementById('darkmode').addEventListener('click', () => {
    setTimeout(() => window.disqusReset(), 200)
  })
}

if ('Valine' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><div class="aplayer no-destroy" data-id="60198" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>