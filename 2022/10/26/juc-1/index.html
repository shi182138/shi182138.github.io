<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>juc(1) | Barry</title><meta name="keywords" content="JAVA"><meta name="author" content="Barry"><meta name="copyright" content="Barry"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JAVA">
<meta property="og:type" content="article">
<meta property="og:title" content="juc(1)">
<meta property="og:url" content="http://example.com/2022/10/26/juc-1/index.html">
<meta property="og:site_name" content="Barry">
<meta property="og:description" content="JAVA">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://w.wallhaven.cc/full/9d/wallhaven-9d5gpw.png">
<meta property="article:published_time" content="2022-10-26T02:06:04.000Z">
<meta property="article:modified_time" content="2022-10-26T02:40:28.505Z">
<meta property="article:author" content="Barry">
<meta property="article:tag" content="JAVA">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://w.wallhaven.cc/full/9d/wallhaven-9d5gpw.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/10/26/juc-1/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'juc(1)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-10-26 10:40:28'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/myfile/1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/myfile/test.html"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://w.wallhaven.cc/full/9d/wallhaven-9d5gpw.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Barry</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/myfile/test.html"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">juc(1)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-10-26T02:06:04.000Z" title="发表于 2022-10-26 10:06:04">2022-10-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-10-26T02:40:28.505Z" title="更新于 2022-10-26 10:40:28">2022-10-26</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="juc(1)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>用户线程</p>
<p>守护线程</p>
<p><strong>用户线程相互独立</strong>，如：主线程结束后，其他用户线程还能继续执行</p>
<h2 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h2><p>异步任务</p>
<p>——–<strong>Future接口可以为主线程开一个分支任务，专门为主线程处理耗时和费力的复杂业务。</strong></p>
<p>比如，再烧水的同时，可以看电视，<strong>充分利用时间，</strong>一心二用，相当于开了一个分支任务；</p>
<p>目的：<strong>异步多线程任务执行且返回有结果</strong>，<strong>三个特点:多线程&#x2F;有返回&#x2F;异步任务</strong></p>
<p>(班长为老师去买水作为新启动的异步多线程任务且买到水有结果返回)</p>
<p>通过<strong>构造注入</strong>与callable和runable拉近关系</p>
<p><img src="/2022/10/26/juc-1/1.png" alt="image-20221015182652399"></p>
<p><strong>FutureTask</strong>实现Runnable，Future接口，即可以实现创建线程（Runnable），异步任务（Future），最后一个返回值，也通过构造注入callable接口实现，<strong>集Runnable，Future，callable三大势力与一身</strong></p>
<p>优点：</p>
<p><strong>future+线程池异步多线程任务配合，能显著提高程序的执行效率。</strong></p>
<p>缺点：</p>
<p>一旦调用get()方法求结果，如果<strong>计算没有完成容易导致程序阻塞,</strong></p>
<p>如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException，InterruptedException，TimeoutException&#123;</span><br><span class="line">   FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;String&gt;( () -&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t -----come in&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">5</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;task over&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask,<span class="string">&quot;t1&quot;</span> );</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread( ).getName()+<span class="string">&quot;\t ----忙其它任务了&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// System.out.println(futureTask.get() );</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println(futureTask.get( 3,Timeunit.SECONDS));	//不够优雅</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用轮询</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(futureTask.isDone()) &#123;</span><br><span class="line">                System.out.println(futureTask.get());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//暂停毫秒</span></span><br><span class="line">                <span class="keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep( <span class="number">500</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace();&#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;正在处理中，不要再催了，越催越慢，再催熄火&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>解决：</p>
<p>1.使用System.out.println(futureTask.get( 3,Timeunit.SECONDS));,不管是否完成，都只等待3秒，抛出超时异常，可以用，但是</p>
<p><strong>不够优雅</strong></p>
<p>2.使用轮询解决；</p>
<p><strong>轮询的方式会耗费无谓的CPU资源，而且也不见得能及时地得到计算结果.如果想要异步获取结果,通常都会以轮询的方式去获取结果</strong><br><strong>尽量不要阻塞</strong></p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p><strong>Future对于结果的获取不是很友好，只能通过阻塞或轮询的方式得到任务的结果。</strong></p>
<h2 id="CompletableFuture接口"><a href="#CompletableFuture接口" class="headerlink" title="CompletableFuture接口"></a>CompletableFuture接口</h2><p>对于一些复杂的任务</p>
<ul>
<li>对于简单的业务场景使用Future完全OK，老铁，每毛病</li>
<li><strong>回调通知</strong></li>
<li>创建异步任务———–Future+线程池配合</li>
<li>多个任务前后依赖可以组合处理(水煮鱼)<ul>
<li>像是水煮鱼，得先买鱼，再买调料，才能煮鱼儿，煮鱼儿依赖前面的结果</li>
<li><strong>想将多个异步任务的计算结果组合起来，后一个异步任务的计算结果需要前一个异步任务的值</strong></li>
<li>将两个或多个异步计算合成一个异步计算，这几个异步计算互相独立，同时后面这个又依赖前一个处理的结果。</li>
</ul>
</li>
<li>对计算速度选最快—–当Future集合中某个任务最快结束时，返回结果，返回第一名处理结果。</li>
<li><strong>使用Future之前提供的那点API就囊中羞涩，处理起来不够优雅，</strong><br><strong>这时候还是让CompletableFuture以声明式的方式优雅的处理这些需求</strong></li>
<li>从i到i++，o(n_n)O哈哈~<br>Future能干的，CompletableFuture都能干</li>
</ul>
<p><img src="/2022/10/26/juc-1/2.png" alt="image-20221015190644004"></p>
<h4 id="CompletionStage"><a href="#CompletionStage" class="headerlink" title="CompletionStage"></a>CompletionStage</h4><p><strong>完成的步骤，分阶段的任务</strong></p>
<h4 id="核心的四个散态方法，来创建一个异步任务"><a href="#核心的四个散态方法，来创建一个异步任务" class="headerlink" title="核心的四个散态方法，来创建一个异步任务"></a>核心的四个散态方法，来创建一个异步任务</h4><p>—-两个构造方法来获得CompletableFuture对象:不推荐使用，</p>
<ul>
<li>completableruture ()</li>
<li>Creates a new incomplete CompletableFuture()</li>
</ul>
<p>—–核心的四个散态方法，来创建一个异步任务</p>
<ul>
<li>runAsync	<strong>有返回值</strong><ul>
<li>public static CompletableFuture<Void> runAsync(Runnable runnable)<br>public static CompletableFuture<Void> runAsync(Runnable runnable,Executor executor)</Void></Void></li>
</ul>
</li>
<li>supplyAsync	<strong>无返回值</strong><ul>
<li>public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier)<br>public static <U>CompletableFuture<U> supplyAsync(Supplier<U> supplierExecutor executor)</U></U></U></U></U></U></li>
</ul>
</li>
</ul>
<p>注意：</p>
<p>​	没有指定Executor的方法，直接使用默认的**ForkJoinPool.commonPool()**作为它的线程池执行异步代码。</p>
<p>​	<strong>如果指定线程池，则使用我们自定义的或者特别指定的线程池执行异步代码</strong></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span> <span class="keyword">throws</span> ExecutionException，InterruptedException&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool( <span class="number">3</span>); <span class="comment">//可以传入线程池</span></span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(() -&gt;&#123;</span><br><span class="line">            System.out.println( Thread.currentThread( ).getName( ));</span><br><span class="line">            <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(  <span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println( completableFuture.get()); <span class="comment">//输出为null</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; completableFuture2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println( Thread.currentThread( ).getName( ));</span><br><span class="line">            <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(  <span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;hello supplyAsync&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println( completableFuture2.get()); <span class="comment">//不在为null			hello supplyAsync</span></span><br><span class="line"></span><br><span class="line">        threadPool.shutdown( ) ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>从Java8开始引入了CompletableFuture，它是Future的功能增强版，<strong>减少阻塞和轮询</strong><br><strong>可以传入回调对象</strong>，<strong>当异步任务完成或者发生异常时，自动调用回调对象的回调方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span> <span class="keyword">throws</span> ExecutionException，InterruptedException&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool( <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        </span><br><span class="line">        CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;----come in&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> ThreadLocalRandom.current( ).nextInt( <span class="number">10</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep( <span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printstackTrace();&#125;</span><br><span class="line">            System.out.println( <span class="string">&quot;-----1秒钟后出结果:&quot;</span> + result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">            <span class="keyword">if</span> (result &gt; <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>/<span class="number">0</span>; <span class="comment">//出异常</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,threadPool).whencomplete((v,e) -&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">                system.out.println(<span class="string">&quot;-----计算完成，更新系统updatevalue: &quot;</span>+v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).exceptionally(e -&gt; &#123;</span><br><span class="line">            e.printstackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;异常情况:&quot;</span>+ e.getcause()+ <span class="string">&quot; \t&quot;</span>+ e.getMessage());</span><br><span class="line">            <span class="keyword">return</span> nul1;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread( ) .getName() + <span class="string">&quot;线程先去忙其它任务&quot;</span>);</span><br><span class="line">        </span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    	e.printstackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    	threadPool.shutdown();	<span class="comment">//使用完记得关闭线程池</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line">    <span class="comment">//主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:暂停3秒钟线程</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//try &#123; TimeUnit.SECONDS.sleep( 3); &#125; catch (InterruptedException e) &#123; e.printstackTrace();&#125;  //使用线程池</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="小案例"><a href="#小案例" class="headerlink" title="小案例"></a>小案例</h4><p>案例说明:电商比价需求，模拟如下情况:</p>
<p>1需求:<br>1.1同一款产品，同时搜索出同款产品在各大电商平台的售价;<br>1.2同一款产品，同时搜索出本产品在同一个电商平台下，各个入驻卖家售价是多少</p>
<p>2输出:出来结果希望是同款产品的在不同地方的价格清单列表，返回一个Llist<string></string></p>
<p>《mysql》in jd price is 88.05</p>
<p>《mysql》in dangdang price is 86.11</p>
<p>《mysql》in taobao price is 90.43</p>
<p>3技术要求<br>3.1西数式编程工3.2链式编程<br>3.3 Stream流式计算</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">completableFutureMallDemo</span>&#123;</span><br><span class="line">	<span class="keyword">static</span> List&lt;NetMall&gt; list = Arrays.asList(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NetMall</span>( <span class="string">&quot;jd&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NetMall</span>(  <span class="string">&quot;dangdang&quot;</span> ),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NetMall</span>(  <span class="string">&quot;taobao&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一家一家的搜索</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getPrice</span><span class="params">(List&lt;NetMall&gt; list,String productName)</span>&#123;</span><br><span class="line">        <span class="comment">//《mysqL》 in taobao price is 90.43</span></span><br><span class="line">        <span class="keyword">return</span> list</span><br><span class="line">                .stream()</span><br><span class="line">                .map( netMall -&gt;</span><br><span class="line">                        String.format(productName + <span class="string">&quot;in %s price is %.2f&quot;</span>,</span><br><span class="line">                                netMall.getNetMallName(),</span><br><span class="line">                                netMall.calcPrice(productName) ))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//你懂的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getPriceBycompletableFuture</span><span class="params">(List &lt;NetMall&gt; list,String productName)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> list.stream( ).</span><br><span class="line">                map( netMall -&gt; CompletableFuture</span><br><span class="line">                        .supplyAsync(() -&gt; String.format(productName + <span class="string">&quot;in %s price is %.2f&quot;</span>,                                                                         netMall.getNetMallName(),</span><br><span class="line">                                netMall.calcPrice(productName) )))</span><br><span class="line">                        .collect(Collectors.toList())</span><br><span class="line">                        .stream()</span><br><span class="line">                        .map(s -&gt;s.join())</span><br><span class="line">                        .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="comment">//一家一家搜	//串行</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        List&lt;String&gt; list1 = getPrice(list,<span class="string">&quot;mysq1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String element : list1) &#123;</span><br><span class="line">            System.out.println(element);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;----costTime: &quot;</span>+(endTime - startTime)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//并行</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        List&lt;String&gt; list2 = getPriceBycompletableFuture(list,<span class="string">&quot;mysql1&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String element : list2) &#123;</span><br><span class="line">            System.out.println(element);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;----costTime: &quot;</span>+(endTime2 - startTime2)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//电商类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NetMall</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String netMallName;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">NetMall</span><span class="params">(String netMallName)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.netMallName = netMallName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getNetMallName</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> netMallName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calcPrice</span><span class="params">(String productName)</span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(  <span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            <span class="keyword">return</span> ThreadLocalRandom.current( ).nextDouble() * <span class="number">2</span> + productName. charAt(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><h5 id="1-获得结果和触发计算"><a href="#1-获得结果和触发计算" class="headerlink" title="1.获得结果和触发计算"></a>1.获得结果和触发计算</h5><ul>
<li>public T get()</li>
<li>public T get(long timeout,TimeUnit unit)</li>
<li>public T join() <ul>
<li><strong>与get()唯一区别是是否抛出异常</strong></li>
</ul>
</li>
<li>public T  getNow(T valuelfAbsent)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span>&#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep( <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> ( InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span> ;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//System.out.println( completableFuture.get());</span></span><br><span class="line">        <span class="comment">//System.out.println( completableFuture.get(2L, TimeUnit.SECONDS) );//</span></span><br><span class="line">        <span class="comment">//System.out.println( completableFuture.join( ) );</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//现在获得执行结果，若没有执行完则输出valuelfAbsent</span></span><br><span class="line">        System.out.println(completableFuture.getNow( <span class="string">&quot;xxx&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="2-对计算结果进行处理"><a href="#2-对计算结果进行处理" class="headerlink" title="2.对计算结果进行处理"></a>2.对计算结果进行处理</h5><ul>
<li>thenApply<ul>
<li>计算结果存在依赖关系，这两个线程串行化</li>
<li>异常：由于存在依赖关系(当前步错，不走下一步)，当前步骤有异常的话就叫停</li>
</ul>
</li>
<li>handle<ul>
<li>计算结果存在依赖关系，这两个线程串行化</li>
<li>异常：有异常也可以往下一步走，根据带的异常参数可以进一步处理</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    </span><br><span class="line">   <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        CompletableFuture.supplyAsync(() -&gt;&#123;</span><br><span class="line">            <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace();&#125;</span><br><span class="line">            System.out.println( <span class="string">&quot;111&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; ,threadPool).thenApply(f -&gt;&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//int i = 10/0; // 模拟异常</span></span><br><span class="line"></span><br><span class="line">            System.out.println( <span class="string">&quot;222&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> f + <span class="number">2</span>;</span><br><span class="line">        &#125;).thenApply(f -&gt;&#123;</span><br><span class="line">            System.out.println( <span class="string">&quot;333&quot;</span> );<span class="keyword">return</span> f + <span class="number">3</span>;</span><br><span class="line">        &#125;).whenComplete((v,e) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println( <span class="string">&quot;----计算结果:&quot;</span>+v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).exceptionally(e -&gt; &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread( ).getName( )+<span class="string">&quot;----主线程先去忙其它任务&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//主线程不要立刻结束，否则completableFuture默认使用的线程池会立刻关闭:</span></span><br><span class="line">        <span class="comment">//try &#123; TimeUnit.SECONDS.sleep( timeout 2); &#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;</span></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">                   </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="3-对计算结果进行消费"><a href="#3-对计算结果进行消费" class="headerlink" title="3.对计算结果进行消费"></a>3.对计算结果进行消费</h5><ul>
<li>接收任务的处理结果，<strong>并消费处理，无返回结果</strong></li>
<li>thenAccept(Consumer action)<ul>
<li>任务A执行完执行B，B需要A的结果，<strong>但是任务B无返回值</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">                   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">	System.out.println(CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultA&quot;</span>).thenRun(() -&gt; &#123;&#125;).join()); <span class="comment">//null resultA</span></span><br><span class="line"></span><br><span class="line">	System.out.println(CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultA&quot;</span>).thenAccept(r -&gt; System.out. println(r)).join());	<span class="comment">// null</span></span><br><span class="line"></span><br><span class="line">	System.out.println(CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultA&quot;</span>).thenApply(r -&gt; r + <span class="string">&quot; resultB&quot;</span>). join());<span class="comment">//resultAresultB</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="4-对计算速度进行选用"><a href="#4-对计算速度进行选用" class="headerlink" title="4.对计算速度进行选用"></a>4.对计算速度进行选用</h5><p>实际中很实用：<strong>谁快谁就是赢家</strong>，<strong>谁快用谁</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        CompletableFuture&lt;String&gt; playA = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            System.out.println( <span class="string">&quot;A come in&quot;</span> );</span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep( <span class="number">2</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;playA&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        CompletableFuture&lt;String&gt; playB = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            System.out.println( <span class="string">&quot;B come in&quot;</span> );</span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep( <span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;playB&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; result = playA.applyToEither(playB, f -&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> f + <span class="string">&quot; is winer&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System. out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;-----: &quot;</span>+result.join());</span><br><span class="line">    &#125;                                                                         </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="5-对计算结果进行合并"><a href="#5-对计算结果进行合并" class="headerlink" title="5.对计算结果进行合并"></a>5.对计算结果进行合并</h5><p>两个CompletionStage任务都完成后，<strong>最终能把两个任务的结果一起交给thenCombine来处理</strong></p>
<p><strong>先完成的先等着</strong>，<strong>等待其它分支任务</strong></p>
<p>then</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[ ] args)</span> &#123;</span><br><span class="line">        CompletableFuture&lt;Integer&gt; completableFuture1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread( ).getName() + <span class="string">&quot;It ---启动&quot;</span>);</span><br><span class="line">            <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep( <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> ( InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace( );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        CompletableFuture&lt;Integer&gt; completableFuture2 = CompletableFuture. supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println( Thread.currentThread( ).getName() + <span class="string">&quot;\t ---启动&quot;</span>);</span><br><span class="line">            <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(  <span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> ( InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Integer&gt; result = completableFuture1.thenCombine(completableFuture2,(x, y)-&gt; &#123;</span><br><span class="line">            System.out.println( <span class="string">&quot;-----开始两个结果合并&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println( result.join());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><ul>
<li>认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。</li>
<li>适合写操作多的场景，先加锁可以保证写操作时数据正确。显式的锁定之后再操作同步资源</li>
</ul>
<h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><ul>
<li>认为自己在使用数据时不会有别的线程修改数据或资源， 以不会添加锁。</li>
<li><strong>版本号，防止ABA问题</strong></li>
<li><strong>最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。</strong></li>
<li>适合读操作多的场景，<strong>不加锁的特点能够使其读操作的性能大幅提升。</strong><br>乐观锁则直接去操作同步资源，是一种无锁算法，得之我幸不得我命，再努力就是</li>
</ul>
<h4 id="类锁，对象锁"><a href="#类锁，对象锁" class="headerlink" title="类锁，对象锁"></a>类锁，对象锁</h4><p>类锁只有一把，一个对象也只有一把锁</p>
<h2 id="简单字节码"><a href="#简单字节码" class="headerlink" title="简单字节码"></a>简单字节码</h2><p>javap -c	xxx.class</p>
<p>反编译命令</p>
<p>javap -v xxx.class 输出附加信息（包括行号、本地变量表，返汇编等详细信息）</p>
<p>synchronized同步代码块实现使用的是monitorenter和monitorexit<strong>指令</strong></p>
<p><strong>一般情况下一个exit对应2exit</strong></p>
<p><img src="/2022/10/26/juc-1/3.png" alt="image-20221016173215509"></p>
<p><img src="/2022/10/26/juc-1/4.png" alt="image-20221016175654450"></p>
<p>调用指令将会检查方法的ACC SYNCHRONIZED访问标志是否被设置。如果设置了，执行线程会将先持有monitor锁．然后再按行方法.心最后在方法完成(无论是正常完成还是非正常完成)时释放monitor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    Object object = new Object();</span></span><br><span class="line"><span class="comment">//    public void m1()</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        synchronized (object)&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;----hello synchronized code block&quot;);</span></span><br><span class="line"><span class="comment">//            throw new RuntimeException(&quot;-----exp&quot;);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//javap -v test08.class</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;</span><br><span class="line">       System.out.println( <span class="string">&quot;----hello synchronized m2&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println( <span class="string">&quot;----hello synchronized m3&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="管程（moniter）"><a href="#管程（moniter）" class="headerlink" title="管程（moniter）"></a>管程（moniter）</h2><p>为什么每一个对象都可以成为锁</p>
<p>每一个对象就是一个moniter监视器</p>
<p>指针指向monitor对象（也称为管程或监视器锁）的起始地址。每个对象都存在着一个montor与之关联，当一个monitor被某个线程持有后，它便处于锁定状态。在Java虚拟机(HotSpot)中，monitor是由ObjectMonitor实现的，其主要数据结构如下（位于HotSpot虚拟机源码ObjectMonitor.hpp文件，C++实现的)</p>
<p><img src="/2022/10/26/juc-1/7.png" alt="image-20221017105144335"></p>
<p>管程(英语:Monitors，也称为监视器)是一种程序结构，结构内的多个子程序(对象或模块〉形成的多个工作线程互斥访问共享资源。<br>这些共享资源一般是硬件设备或一群变量。对共享变量能够进行的所有操作集中在一个模块中。(把信号量及其操作原语“封装”在一个对象内部)管程实现了在一个时间点，最多只有一个线程在执行管程的某个子程序。管程提供了一种机制，管程可以看做一个软件模块，它是将共享的变量和对于这些共享变量的操作封装起来，形成一个具有一定接口的功能模块，进程可以调用管程来实现进程级别的并发控制。</p>
<p><strong>Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程(Monitor，更常见的是直接将它称为“锁”）来实现的。</strong></p>
<p><img src="/2022/10/26/juc-1/5.png" alt="image-20221016195849833"></p>
<p>ObjectMonitor中有几个关键属性</p>
<table>
<thead>
<tr>
<th>_owner</th>
<th align="left">指向持有ObjectMonitor对象的线程</th>
</tr>
</thead>
<tbody><tr>
<td>_WaitSet</td>
<td align="left">存放处于wait状态的线程队列</td>
</tr>
<tr>
<td>_EntryList</td>
<td align="left">存放处于等待锁block状态的线程队列</td>
</tr>
<tr>
<td>_recursions</td>
<td align="left">锁的重入次数</td>
</tr>
<tr>
<td>_count</td>
<td align="left">用来记录该线程获取锁的次数</td>
</tr>
</tbody></table>
<h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(number &gt; <span class="number">0</span>)</span><br><span class="line">            System.out.println(Thread.currentThread( ). getName()+<span class="string">&quot;卖出第: \t&quot;</span>+(number--) +<span class="string">&quot;\t还剩下:&quot;</span>+number);</span><br><span class="line">        &#125;	<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">saleTicketDemod</span> &#123;</span><br><span class="line">    <span class="comment">//一坊程序的入口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[ ] args)</span>&#123;</span><br><span class="line">    	<span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line">    	<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123; <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">55</span>; i++) ticket.sale(); &#125;, <span class="string">&quot;a&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123; <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">55</span>; i++) ticket.sale(); &#125;,  <span class="string">&quot;b&quot;</span>). start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123; <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i <span class="number">55</span>; i++) ticket.sale(); &#125;,  <span class="string">&quot;c&quot;</span> ).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>1<br>恢复挂起的线程到真正锁的获取还是有时间差的，从开发人员来看这个时间微乎其微，但是从CPU的角度来看，这个时间差存在的还是很明显的。<strong>所以非公平锁能更充分的利用CPU的时间片，尽量减少CPU空闲状态时间。</strong></p>
<p>2<br>使用多线程很重要的考量点是线程切换的开销，当采用非公平锁时，<strong>当1个线程请求锁获取同步状态，然后释放同步状态，所以刚释放锁的线程在此刻再次获取同步状态的概率就变得非常大，所以就减少了线程的开销。</strong></p>
<h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>一个线程中的多个流程可以获取同一把锁，持有这把同步锁可以再次进入。。<strong>自己可以获取自己的内部锁</strong></p>
<p>指的是可<strong>重复可递归调用</strong>的锁，在外层使用锁之后，在内层仍然可以使用，<strong>并且不发生死锁</strong>，这样的锁就叫做可重入锁。<br>简单的来说就是:在一个synchronized修饰的方法或代码块的内部调用本类的其他synchronized修饰的方法或代码块时，<strong>是永远可以得到锁</strong>的</p>
<p><strong>在一个synchronized修饰的方法或代码块的内部调用本类的其他synchronized修饰的方法或代码块时，是永远可以得到锁的</strong></p>
<h4 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h4><p><strong>每个锁对象拥有一个锁计数器和一个指向持有该锁的线程的指针。</strong><br>当执行monitorenter时，如果目标锁对象的计数器为零，那么说明它没有被其他线程所持有，Java虚拟机会将该锁对象的持有线程设置为当前线程，并且将其计数器加1。<br>在目标锁对象的计数器不为零的情况下，如果锁对象的持有线程是当前线程，那么Java虚拟机可以将其计数器加1，否则需要等待，直至持有线程释放该锁。<br><strong>当执行monitorexit时，Java虚拟机则需将锁对象的计数器减1。计数器为零代表锁已被释放。</strong></p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p><strong>死锁是指两个或两个以上的线程在执行过程中,因争夺资源而造成的一种互相等待的现象</strong>,<strong>若无外力干涉那它们都将无法推进下去</strong>，如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。</p>
<p><strong>主要原因</strong></p>
<ul>
<li>系统资源不足</li>
<li>进程运行推进的顺序不合适</li>
<li>资源分配不当</li>
</ul>
<p>案例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[ ] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">objectA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">objectB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectA) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t自己持有A锁，希望获得B锁&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (objectB) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 成功获得B锁&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectB) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t自己持有B锁，希望获得A锁&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (objectA) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;It成功获得A锁&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>证明</p>
<p>jps -l</p>
<p>找到改进程，然后jstack</p>
<p>jstack 进程号</p>
<h4 id="jconsole图形检测死锁"><a href="#jconsole图形检测死锁" class="headerlink" title="jconsole图形检测死锁"></a>jconsole图形检测死锁</h4><p>实际可能用</p>
<p><img src="/2022/10/26/juc-1/6.png" alt="image-20221017102531173"></p>
<h2 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h2><h4 id="经典"><a href="#经典" class="headerlink" title="经典"></a>经典</h4><p><img src="/2022/10/26/juc-1/8.png" alt="image-20221017112502547"></p>
<table>
<thead>
<tr>
<th>public void interrupt()</th>
<th>实例方法，Just to set the interrupt fLag<br>实例方法interrupt()仅仅是设置线程的中断状态为true，发起一个协商而不会立刻停止线程</th>
</tr>
</thead>
<tbody><tr>
<td>public static boolean interrupted()</td>
<td>静态方法，Thread.interrupted();<br>判断线程是否被中断并清除当前中断状态。<br>这个方法做了两件事<br>1返回当前线程的中断状态，测试当前线程是否已被中断<br>2将当前线程的中断状态清零并重新设为false，清除线程的中断状态<br>此方法有点不好理解，如果连续两次调用此方法，则第二次调用将返回false，因为连续调用两次的结果可能不一样</td>
</tr>
<tr>
<td>public boolean isinterruoted()</td>
<td>实例方法，<br>判断当前线程是否被中断(通过检查中断标志位)</td>
</tr>
</tbody></table>
<h5 id="如何中断一个运行中的线程"><a href="#如何中断一个运行中的线程" class="headerlink" title="如何中断一个运行中的线程??"></a>如何中断一个运行中的线程??</h5><h6 id="通过一个volatile变量实现"><a href="#通过一个volatile变量实现" class="headerlink" title="通过一个volatile变量实现"></a>通过一个volatile变量实现</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">isStop</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isStop) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t isstop被修改为true，程序停止&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;t1 -----hello volatile&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停毫秒</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(  <span class="number">20</span>); &#125; <span class="keyword">catch</span>  (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">                isStop = <span class="literal">true</span>;</span><br><span class="line">        &#125; ,<span class="string">&quot;t2&quot;</span> ).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h6 id="通过AtomicBoolean天生原子操作"><a href="#通过AtomicBoolean天生原子操作" class="headerlink" title="通过AtomicBoolean	天生原子操作"></a>通过AtomicBoolean	天生原子操作</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">AtomicBoolean</span> <span class="variable">atomicBoolean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(  <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (atomicBoolean.get()) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t atomicBoolean被修改为true，程序停止&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;t1 -----hello atomicBoolean&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//暂停毫秒</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">20</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            atomicBoolean.set(<span class="literal">true</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h6 id="通过Thread类自带的中断api实例方法实现"><a href="#通过Thread类自带的中断api实例方法实现" class="headerlink" title="通过Thread类自带的中断api实例方法实现"></a>通过Thread类自带的中断api实例方法实现</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t isInterrupted()被修改为true，程序停止&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;t1 -----hello interrupt api&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">//暂停毫秒</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">50</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">   		<span class="comment">//t2向t1发出协商，将t1的中断标志位设为true希望t1停下来</span></span><br><span class="line">        <span class="comment">/*new Thread(() -&gt; &#123;</span></span><br><span class="line"><span class="comment">            t1.interrupt();</span></span><br><span class="line"><span class="comment">        &#125;, &quot;t2&quot;).start();*/</span></span><br><span class="line">    </span><br><span class="line">		<span class="comment">//也可以自己停下来</span></span><br><span class="line">   		 t1.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如何停止一个运行中的线程??</p>
<p>如何停止中断运行中的线程?</p>
<h4 id="当前线程的中断标识为true，是不是线程就立刻停止"><a href="#当前线程的中断标识为true，是不是线程就立刻停止" class="headerlink" title="当前线程的中断标识为true，是不是线程就立刻停止?"></a>当前线程的中断标识为true，是不是线程就立刻停止?</h4><p>静态方法Thread.interrupted()，谈谈你的理解</p>
<h4 id="什么是中断机制"><a href="#什么是中断机制" class="headerlink" title="什么是中断机制?"></a>什么是中断机制?</h4><p>首先<br><strong>一个线程不应该由其他线程来强制中断或停止，而是应该山线程自己自行停止，自己来决定自己的命运</strong>。所以，<strong>Thread.stop,Thread.suspend, Thread.resume都已经被废弃了。</strong><br>其次<br><strong>在Java中没有办法立即停止一条线程，然而停止线程却显得尤为重要</strong>，如取消一个耗时操作。因此，<strong>Java提供了一种用于停止线程的协商机制—中断，也即中断标识协商机制。</strong><br>中断只是一种协作协商机制，Java没有给中断增加任何语法，中断的过程完全需要程序员自己实现。<br>若要中断一个线程，你需要手动调用该线程的interrupt方法，<strong>该方法也仅仅是将线程对象的中断标识设成true</strong>;<strong>接着你需要自己写代码不断地检测当前线程的标识位，如果为true，表示别的线程请求这条线程中断，</strong><br>此时究竟该做什么需要你自己写代码实现。<br>每个线程对象中都有一个中断标识位，用于表示线程是否被中断;该标识位为true表示中断，为false表示未中断;通过调用线程对象的interrupt方法将该线程的标识位设为true;可以在别的线程中调用，也可以在自己的线程中调用。</p>
<p>例子，一家餐厅，顾客线程和服务员线程，顾客抽烟，服务员只能劝说顾客别抽烟，协商</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意</p>
<p>如果该统程日塞的调用wait() , wait(long) , 或wait(long，int)的方法Dbject类，的join()， join(1ong) ， join(long, int) ， slep(lng),islerp(1lng , int) 这个英的方法，那么它的中断状态将被清除，并且将收到InterruptedException 。</p>
<p>具体来说，当对一个线程，调用interrupt()时:<br>1、<strong>如果线程处于正常活动状态，那么会将该线程的中断标志设置为 true，仅此而已</strong>。<strong>被设置中断标志的线程将继续正常运行，不受影响。</strong><br>所以，interrupt()并不能真正的中断线程，需要被调用的线程自己进行配合才行。</p>
<p>2、<strong>如果线程处于被阻塞状态（例如处于sleep, wait,join等状态)，在别的线程中调用当前线程对象的interrupt方法，那么线程将立即退出被阻塞状态，并抛出一个InterruptedException异常。</strong></p>
<p>实例方法interrupt()仅仅是设置菲程的中断状态位设置为true，不会停止线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//实例方法interrupt()仅仅是设置菲程的中断状态位设置为true，不会停止线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">300</span>; i++)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;-----: &quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;t1线程调用interrupt()后的的中断标识02:&quot;</span> + Thread.currentThread().isInterrupted());</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span> );</span><br><span class="line">        t1.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;t1线程默认的中断标识:&quot;</span>+t1.isInterrupted());<span class="comment">//false</span></span><br><span class="line">        <span class="comment">//暂停毫秒</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(  <span class="number">2</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        t1.interrupt(); <span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;t1线程调用interrupt()后的的中断标识01:&quot;</span>+t1.isInterrupted());<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep( <span class="number">2000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace();&#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;t1线程调用interrupt()后的的中断标识03:&quot;</span>+t1.isInterrupted());<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h4 id="小小案例"><a href="#小小案例" class="headerlink" title="小小案例"></a>小小案例</h4><p>1中断标志位，默认false</p>
<p>2 t2 —-&gt; t1发出了中断协商，t2调用t1.interrupt( )，中断标志位true</p>
<p>3中断标志位true，正常情况，程序停止，八_A</p>
<p>4中断标志位true，异常情况，InterruptedException，将会把中断状态将被清除，并且将收到nterruptedEwception 。中断标志(ifolse<br>导致无限循环</p>
<p>5 在catch块中，需要再次给中断标志位设置为true，2次调用停止程序才ok</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                   System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;中断标志位:&quot;</span> + Thread.currentThread().isInterrupted() + <span class="string">&quot;程序停止&quot;</span>);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   Thread.sleep(<span class="number">200</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   Thread.currentThread().interrupt();<span class="comment">//没有它，程序不会停止，中断不打断，看看sleep方法的源码</span></span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               System.out.println(<span class="string">&quot;-----hello InterruptDemo3&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">       t1.start();</span><br><span class="line">       <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">       <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep( <span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; t1.interrupt(),  <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="小小案例（二）"><a href="#小小案例（二）" class="headerlink" title="小小案例（二）"></a>小小案例（二）</h4><p><img src="/2022/10/26/juc-1/9.png" alt="image-20221018214931283"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试当前线程是否被中断（检查中断标志），返回一个boolean并清除中断状态，</span></span><br><span class="line">        <span class="comment">//第二次再调用时中断状态已经被清除，将返回一个false。</span></span><br><span class="line"></span><br><span class="line">       System.out.println(Thread.currentThread( ).getName()+<span class="string">&quot;\t&quot;</span>+Thread.interrupted());</span><br><span class="line">       System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+Thread.interrupted());</span><br><span class="line">       System.out.println( <span class="string">&quot;----1&quot;</span> );</span><br><span class="line">        Thread.currentThread( ).interrupt( );<span class="comment">//中断标志位设置为truesystem.out.println(&quot;----2&quot; );</span></span><br><span class="line">        System.out.println(Thread.currentThread( ).getName()+<span class="string">&quot;\t&quot;</span>+Thread.interrupted());</span><br><span class="line">        System.out.println(Thread.currentThread() .getName()+<span class="string">&quot;\t&quot;</span>+Thread.interrupted());</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出结果</span></span><br><span class="line"><span class="comment">main	false</span></span><br><span class="line"><span class="comment">main	false</span></span><br><span class="line"><span class="comment">----1</span></span><br><span class="line"><span class="comment">main	true</span></span><br><span class="line"><span class="comment">main	false</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>线程中断相关的方法:<br>public void interrupt() . interrupt()方法是一个实例方法<br>它通知目标线程中断，也仅是设置目标线程的中断标志位为true。<br>public boolean isInterrupted(). isInterrupted()方法也是一个实例方法它判断当前线程是否被中断（通过检查中断标志位）并获取中断标志<br>public static boolean interrupted().Thread类的静态方法interrupted()<br>返回当前线程的中断状态真实值(boolean类型)后会将当前线程的中断状态设为false，此方法调用之后会清除当前线程的中断标志位的状态（将中断标志置为false了)，返回当前值并清零置false</p>
<h2 id="lockInterrupt"><a href="#lockInterrupt" class="headerlink" title="lockInterrupt"></a>lockInterrupt</h2><p>锁的支撑类，解决了老技术什么问题？</p>
<p>Package java.util.concurrent.locks</p>
<p>用于创建锁和其他同步类的基本线程阻塞原语。</p>
<p>lockInterrupt线程等待唤醒机制的加强与提升</p>
<h4 id="三种让线程等待和唤醒的方法"><a href="#三种让线程等待和唤醒的方法" class="headerlink" title="三种让线程等待和唤醒的方法"></a>三种让线程等待和唤醒的方法</h4><ul>
<li>方式1:使用object中的wait()方法让线程等待，使用Object中的notify()方法唤醒线程</li>
<li>方式2:使用Juc包中Condition的e:ait()方法让线程等待，使用signal()方法唤醒线程方式</li>
<li>3:LockSupport类可以阻塞当前线程以及唤醒指定被阻塞的线程</li>
</ul>
<h4 id="先来看看wait和notify实现线程的等待和唤醒"><a href="#先来看看wait和notify实现线程的等待和唤醒" class="headerlink" title="先来看看wait和notify实现线程的等待和唤醒"></a>先来看看wait和notify实现线程的等待和唤醒</h4><ul>
<li><p>wait方法和notify方法，两个都去掉同步代码块                       —————–出现异常</p>
</li>
<li><p>将notify放在wait方法前面程序无法执行，无法唤醒                —————–无法被唤醒</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">objectLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t ----come in&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    objectLock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t ----被唤醒&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="comment">//暂停几秒钟线程</span></span><br><span class="line"><span class="comment">//        try &#123;</span></span><br><span class="line"><span class="comment">//            TimeUnit.SECONDS.sleep(1);</span></span><br><span class="line"><span class="comment">//        &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">                objectLock.notify();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t ----发出通知&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="condition接口中的await和signal方法实现线程的等待和唤醒"><a href="#condition接口中的await和signal方法实现线程的等待和唤醒" class="headerlink" title="condition接口中的await和signal方法实现线程的等待和唤醒"></a>condition接口中的await和signal方法实现线程的等待和唤醒</h4><p>同样</p>
<ul>
<li><p>wait方法和notify方法，两个都去掉同步代码块                       —————–出现异常</p>
</li>
<li><p>将notify放在wait方法前面程序无法执行，无法唤醒                —————–无法被唤醒</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(  <span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">            lock.lock( );</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread( ).getName()+<span class="string">&quot;\t ----come in&quot;</span>);condition.await();</span><br><span class="line">                System.out.println(Thread.currentThread( ).getName()+<span class="string">&quot;\t ----被唤醒&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;t1&quot;</span> ).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">        <span class="comment">//try &#123; TimeUnit.SECONDS.sleep(  1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                condition.signal();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t -----发出通知&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="小小总结"><a href="#小小总结" class="headerlink" title="小小总结"></a>小小总结</h4><p>线程先要获得并持有锁，必须在锁块(synchronized或lock)中必须要先等待后唤醒，线程才能够被唤醒</p>
<h4 id="lockInterrupt的改进"><a href="#lockInterrupt的改进" class="headerlink" title="lockInterrupt的改进"></a>lockInterrupt的改进</h4><p>对上面两种进行了改进</p>
<p><strong>sleep方法3秒后醒来，执行park无效，没有阻塞效果，</strong>解释如下先执行了unpark(t1)导致上面的park方法形同虚设无效，时间一样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(  <span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        System.out.println(Thread.currentThread( ).getName() + <span class="string">&quot;\t ----come in&quot;</span>);</span><br><span class="line">        LockSupport.park();</span><br><span class="line">		<span class="comment">//LockSupport.park();  //只有一个许可证</span></span><br><span class="line">        System.out.println( Thread.currentThread( ).getName() + <span class="string">&quot;\t ----被唤醒&quot;</span>);&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">    <span class="comment">//try &#123; TimeUnit.SECONDS.sleep(  1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">        LockSupport.unpark(t1);</span><br><span class="line">        System.out.println(Thread.currentThread( ).getName()+<span class="string">&quot;\t ----发出通知&quot;</span>);&#125;,  <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>注意：只有一个许可证</strong></p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul>
<li>为什么可以突破wait&#x2F;notify的原有调用顺序?</li>
</ul>
<p>因为unpark获得了一个凭证，之后再调用park方法，就可以名正言顺的凭证消费，故不会阻塞。I先发放了凭证后续可以畅通无阻。</p>
<ul>
<li>为什么唤醒两次后阻塞两次，但最终结果还会阻塞线程?</li>
</ul>
<p>因为凭证的数量最多为1，连续调用两次unpark和调用一次unpark效果一样，只会增加一个凭证;而调用两次park却需要消费两个凭证，证不够，不能放行。</p>
<h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><h4 id="先问几个问题"><a href="#先问几个问题" class="headerlink" title="先问几个问题"></a>先问几个问题</h4><ul>
<li>你知道什么是Java内存模型JMM吗?</li>
<li>JMM与volatile它们两个之间的关系?</li>
<li>JMM有哪些特性or它的三大特性是什么?</li>
<li>为什么要有JMM，它为什么出现?作用和功能是什么?</li>
<li>happens-before先行发生原则你有了解过吗?</li>
</ul>
<h4 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h4><p>因为有这么多级的缓存(cpu和物理主内存的速度不一致的)，<br>    <strong>CPU的运行并不是直接操作内存而是先把内存里边的数据读到缓存</strong>，<strong>而内存的读和写操作的时候就会造成不一致的问题</strong></p>
<p><strong>数据库先把数据load到内存，CPU再从内存load到缓存</strong></p>
<img src="/2022/10/26/juc-1/10.png" alt="image-20221019142821802" style="zoom: 67%;">



<p>JVM规范中试图定义一种Java内存模型(java Memory Model，简称JMM)来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。<strong>比如普通话，让粤语和四川话的人都能沟通</strong><br>所以，推导出我们需要知道JMM</p>
<h4 id="JMM简介"><a href="#JMM简介" class="headerlink" title="JMM简介"></a>JMM简介</h4><p>JMM(Java内存模型Java Memory Model，简称JMM)本身是一种抽象的概念并不真实存在它仅仅描述的是一组约定或规范，通过这组规范定义了程序中(尤其是多线程)各个变量的读写访问方式并决定一个线程对共享变量的写入何时以及如何变成对另一个线程可见，<strong>关键技术点都是围绕多线程的原子性、可见性和有序性展开的。</strong><br>原则:<br>JMM的关键技术点都是围绕多线程的原子性、可见性和有序性展开的</p>
<p>能干嘛?</p>
<p>1通过JMM来实现线程和主内存之间的抽象关系。</p>
<p>2<strong>屏蔽各个硬件平台和操作系统的内存访问差异以实现让Java程序在各种平台下都能达到一致的内存访问效果。</strong></p>
<h4 id="JMM下三大特性"><a href="#JMM下三大特性" class="headerlink" title="JMM下三大特性"></a>JMM下三大特性</h4><p>可见性</p>
<p>原子性</p>
<p>有序性</p>
<p>​	指令重排</p>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>可见性<br><strong>是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道该变更，JMM规定了所有的变量都存储在主内种。</strong></p>
<p><img src="/2022/10/26/juc-1/11.png" alt="image-20221019144330146"></p>
<p>系统主内存共享变量数据修改被写入的时机是不确定的，多线程并发下很可能出现”脏读”.所以每个线程都有自己的工作内存、线程自己的工作内存中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取，赋值等）都必需在线程自己的工作内存中进行，而不能够直接读写主内存中的变量。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成</p>
<table>
<thead>
<tr>
<th>主内存中有变量x，初始值为0</th>
</tr>
</thead>
<tbody><tr>
<td>线程A要将x加1，先将x&#x3D;O拷贝到自己的私有内存中，然后更新x的值</td>
</tr>
<tr>
<td>线程A将更新后的×值回刷到主内存的时间是不固定的</td>
</tr>
<tr>
<td>刚好在线程A没有回刷x到主内存时，线程B同样从主内存中读取x，此时为0，和线程A一样的操作，最后期盼的x&#x3D;2就会变成x&#x3D;1</td>
</tr>
</tbody></table>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><h5 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h5><p>对于一个线程的执行代码而言，我们总是习惯性认为代码的执行总是从上到下，有序执行。但为了提升性能，<strong>编译器和处理器通常会对指令序列进行重新排序。Java规范规定JMM线程内部维持顺序化语义，即只要程序的最终结果与它顺序化执行的结果相等，那么指令的执行顺序可以与代码顺序不一致，此过程叫指令的重排序。</strong></p>
<h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><p>JVM能根据处理器特性〈CPU多级缓存系统、多核处理器等）适当的对机器指令进行重排序，使机器指令能更符合CPU的执行特性，最大限度的发挥机器性能。但是，<br><strong>指令重排可以保证串行语义一致，但没有义务保证多线程间的语义也一致</strong>(即可能产生”脏读”)，简单说，<br>两行以上不相干的代码在执行的时候有可能先执行的不是第一条，不见得是从上到下顺序执行，执行顺序会被优化。<br>从源码到最终执行示例图:</p>
<p><img src="/2022/10/26/juc-1/12.png" alt="image-20221019155719591"></p>
<p>单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致。处理器在进行重排序时必须要考虑指令之间的数据依赖性<br>多线程环境中线程交替执行,由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的,结果无法预测。</p>
<p>读取过程<br>有数据区域，而Java内存模型中规定所有变量都存储在主内存，<strong>主内存是共享内存区域，所有线程都可以访问</strong>，<strong>但线程对变量的操作(读取赋值等)必须在工作内存中进行</strong>，<strong>首先要将变量从主内存拷贝到的线程自己的工作内存空间，然后对变量进行操作</strong>，<strong>操作完成后再将变量写回主内存，不能直接操作主内存中的变量</strong>，各个线程中的工作内存中存储着主内存中的变量副本拷贝，<strong>因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成</strong>，其简要访问过程如下图:</p>
<p><img src="/2022/10/26/juc-1/13.png" alt="image-20221019162124515"></p>
<h4 id="小小小总结"><a href="#小小小总结" class="headerlink" title="小小小总结"></a>小小小总结</h4><p>我们定义的所有共享变量都储存在物理主内存中<br>每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本(主内存中该变量的一份拷贝)<br>线程对共享变量所有的操作都必须先在线程自己的工作内存中进行后写回主内存，不能直接从主内存中读写(不能越级)<br>不同线程之间也无法直接访问其她线程的工作内存中的变量，线程间变量值的传递需要通过主内存来进行(同级不能相互访问)</p>
<h4 id="Happens-Before"><a href="#Happens-Before" class="headerlink" title="Happens-Before"></a>Happens-Before</h4><p><strong>如果Java内存模型中所有的有序性都仅靠volatile和synchronized来完成，那么有很多操作都将会变得非常啰嗦，但是我们在编写Java并发代码的时候并没有察觉到这一点。</strong><br><strong>我们没有时时、处处、次次，添加volatile和synchronized来完成程序，这是因为Java语言中JMM原网下有一个“先行发生”(Happens-Before)的原则限制和规矩，给你立好了规矩!</strong>			&lt;————————-<strong>Happens-Before</strong><br>这个原则非常重要:<br>它是判断数据是否存在竞争，线程是否安全的非常有用的手段。依赖这个原则，我们可以通过几条简单规则一揽子解决并发环境下两个操作之间是否可能存在冲突的所有问题，而不需要陷入Java内存模型苦涩难懂的底层编译原理之中。</p>
<h4 id><a href="#" class="headerlink" title></a></h4><p>多线程先行发生原则</p>
<p><strong>规定了多线程谁先谁后了之后，互相让其他线程获得感知</strong></p>
<p>在JMM中，<br><strong>如果一个操作执行的结果需要对另一个操作可见性</strong><br><strong>或者代码重排序，那么这两个操作之间必须存在happens-before(先行发生)原则</strong>。逻辑上的先后关系</p>
<h5 id="总原则"><a href="#总原则" class="headerlink" title="总原则"></a>总原则</h5><p><strong>把下面的happens-before直译为“在什么之前”，那么就很好理解了，你懂的</strong></p>
<p>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。<br>两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。</p>
<h5 id="8大原则"><a href="#8大原则" class="headerlink" title="8大原则"></a>8大原则</h5><ul>
<li><p>1.次序规则:</p>
</li>
<li><p>2.锁定规则:</p>
</li>
<li><p>3.volatile变量规则:</p>
<ul>
<li>对一个volatile变量的写操作先行发生于后面对这个变量的读操作，<strong>前面的写对后面的读是可见的</strong>，这里的“后面”同样是指时间上的先后。</li>
</ul>
</li>
<li><p>4.传递规则:</p>
</li>
<li><p>5.线程启动规则(Thread Start Rule):</p>
<ul>
<li>Thread对象的start()方法先行发生于此线程的每一个动作</li>
</ul>
</li>
<li><p>6.线程中断规则(Thread lnterruption Rule):</p>
<ul>
<li>对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生;</li>
<li>可以通过Thread.interrupted()检测到是否发生中断<br><strong>也就是说你要先调用interrupt()方法设置过中断标志位，我才能检测到中断发送</strong></li>
</ul>
</li>
<li><p>7.线程终止规则(Thread Termination Rule):</p>
<ul>
<li>线程中的所有操作都先行发生于对此线程的终止检<br>测，我们可以通过isAlive()等手段检测线程是否已经终止执行。</li>
</ul>
</li>
<li><p>8.对象终结规则(Finalizer Rule):</p>
<ul>
<li>一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始</li>
<li>人话：对象没有完成初始化之前，是不能调用finalized()方法的</li>
</ul>
</li>
</ul>
<h4 id="Happens-Before小小总结"><a href="#Happens-Before小小总结" class="headerlink" title="Happens-Before小小总结"></a>Happens-Before小小总结</h4><p>在Java语言里面，Happens-Before的语义本质上是一种可见性<br>A Happens-BeforeB意味着A发生过的事情对B来说是可见的，无论A事件和B事件是否发生在同一个线程里.<br>JMM的设计分为两部分:<br>一部分是面向我们程序员提供的，也就是happens-before规则，它通俗易懂的向我们程序员阐述了一个强内存模型，我们只要理解happens-before规则，就可以编写并发安全的程序了。<br>另一部分是针对JVM实现的，为了尽可能少的对编译器和处理器做约束从而提高性能，JMM在不影响程序执行结果的前提下对其不做要求，即允许优化重排序。我们只需要关注前者就好了，也就是理解happens-before规则即可，其它繁杂的内容有JMM规范结合操作系统给我们搞定，我们只写好代码即可。</p>
<h2 id="Volatile与JMM"><a href="#Volatile与JMM" class="headerlink" title="Volatile与JMM"></a>Volatile与JMM</h2><p>volatile两大特点</p>
<ul>
<li>可见性</li>
<li>和有序性<ul>
<li>禁止重排序</li>
<li><strong>从编译器的手动挡变成自动挡</strong></li>
</ul>
</li>
</ul>
<h4 id="volatile内存语义"><a href="#volatile内存语义" class="headerlink" title="volatile内存语义"></a>volatile内存语义</h4><p><strong>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共亳变量值立即刷新回主内存中。</strong><br><strong>当读一个volatile变量时，JMM会把该线程对应的本地内存设置为无效，重新回到主内存中读取最新共享变量</strong></p>
<p><strong>注意：</strong>本地内存和主内存，你懂的</p>
<p>所以volatile的<strong>写内存语义是直接刷新到主内存中，读的内存语义是直接从主内存中读取。</strong></p>
<p>为什么可以禁止重排序</p>
<p>——内存屏障</p>
<h4 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h4><p>是什么<br>内存屏障（也称内存栅栏，屏障指令等，是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一1个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作），避免代码重排序。<strong>内存屏障其实就是一种JVM指令</strong>，Java内存模型<br>的重排规则会<strong>要求Java编译器在生成JVM指令时插入特定的内存屏障指令</strong>，通过这些内存屏障指令，volatile实现了Java内存模型中的可见性和有序性(禁重排)，<strong>但volatile无法保证原子性。</strong><br><strong>内存屏障之前的所有写操作都要回写到主内存，</strong><br><strong>内存屏障之后的所有读操作都能获得内存屏障之前的所有写操作的最新结果(实现了可见性)。</strong></p>
<p>写屏障（Store Memory Barrier):告诉处理器在写屏障之前将所有存储在缓存(store bufferes)中的数据同步到主内存。也就是说当看到Store屏障指令，就必须把该指令之前所有写入指令执行完毕才能继续往下执行。</p>
<p>读屏障(Load Memory Barrier):处理器在读屏障之后的读操作，都在读屏障之后执行。也就是说在Load屏障指令之后就能够保证后面的读取数据指令一定能够读取到最新的数据。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Barry</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/10/26/juc-1/">http://example.com/2022/10/26/juc-1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Barry</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JAVA/">JAVA</a></div><div class="post_share"><div class="social-share" data-image="https://w.wallhaven.cc/full/9d/wallhaven-9d5gpw.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/10/26/JDBC/"><img class="prev-cover" src="https://w.wallhaven.cc/full/kx/wallhaven-kx9d56.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JDBC</div></div></a></div><div class="next-post pull-right"><a href="/2022/10/26/JAVAWEB-2/"><img class="next-cover" src="https://w.wallhaven.cc/full/d6/wallhaven-d65dxg.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JAVAWEB(2)</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/myfile/1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Barry</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Future%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.</span> <span class="toc-text">Future接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">1.0.1.</span> <span class="toc-text">结论</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CompletableFuture%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.</span> <span class="toc-text">CompletableFuture接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CompletionStage"><span class="toc-number">2.0.1.</span> <span class="toc-text">CompletionStage</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%9A%84%E5%9B%9B%E4%B8%AA%E6%95%A3%E6%80%81%E6%96%B9%E6%B3%95%EF%BC%8C%E6%9D%A5%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1"><span class="toc-number">2.0.2.</span> <span class="toc-text">核心的四个散态方法，来创建一个异步任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E6%A1%88%E4%BE%8B"><span class="toc-number">2.0.3.</span> <span class="toc-text">小案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">2.0.4.</span> <span class="toc-text">常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%8E%B7%E5%BE%97%E7%BB%93%E6%9E%9C%E5%92%8C%E8%A7%A6%E5%8F%91%E8%AE%A1%E7%AE%97"><span class="toc-number">2.0.4.1.</span> <span class="toc-text">1.获得结果和触发计算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%AF%B9%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%9C%E8%BF%9B%E8%A1%8C%E5%A4%84%E7%90%86"><span class="toc-number">2.0.4.2.</span> <span class="toc-text">2.对计算结果进行处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%AF%B9%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%9C%E8%BF%9B%E8%A1%8C%E6%B6%88%E8%B4%B9"><span class="toc-number">2.0.4.3.</span> <span class="toc-text">3.对计算结果进行消费</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%AF%B9%E8%AE%A1%E7%AE%97%E9%80%9F%E5%BA%A6%E8%BF%9B%E8%A1%8C%E9%80%89%E7%94%A8"><span class="toc-number">2.0.4.4.</span> <span class="toc-text">4.对计算速度进行选用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%AF%B9%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%9C%E8%BF%9B%E8%A1%8C%E5%90%88%E5%B9%B6"><span class="toc-number">2.0.4.5.</span> <span class="toc-text">5.对计算结果进行合并</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">3.</span> <span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">3.0.1.</span> <span class="toc-text">悲观锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">3.0.2.</span> <span class="toc-text">乐观锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E9%94%81%EF%BC%8C%E5%AF%B9%E8%B1%A1%E9%94%81"><span class="toc-number">3.0.3.</span> <span class="toc-text">类锁，对象锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%AD%97%E8%8A%82%E7%A0%81"><span class="toc-number">4.</span> <span class="toc-text">简单字节码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B%EF%BC%88moniter%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">管程（moniter）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">6.</span> <span class="toc-text">公平锁和非公平锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="toc-number">7.</span> <span class="toc-text">可重入锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">7.0.1.</span> <span class="toc-text">实现机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">8.</span> <span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#jconsole%E5%9B%BE%E5%BD%A2%E6%A3%80%E6%B5%8B%E6%AD%BB%E9%94%81"><span class="toc-number">8.0.1.</span> <span class="toc-text">jconsole图形检测死锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#interrupt"><span class="toc-number">9.</span> <span class="toc-text">interrupt</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8"><span class="toc-number">9.0.1.</span> <span class="toc-text">经典</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%B8%AD%E6%96%AD%E4%B8%80%E4%B8%AA%E8%BF%90%E8%A1%8C%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="toc-number">9.0.1.1.</span> <span class="toc-text">如何中断一个运行中的线程??</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E4%B8%80%E4%B8%AAvolatile%E5%8F%98%E9%87%8F%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.0.1.1.1.</span> <span class="toc-text">通过一个volatile变量实现</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%80%9A%E8%BF%87AtomicBoolean%E5%A4%A9%E7%94%9F%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">9.0.1.1.2.</span> <span class="toc-text">通过AtomicBoolean	天生原子操作</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%80%9A%E8%BF%87Thread%E7%B1%BB%E8%87%AA%E5%B8%A6%E7%9A%84%E4%B8%AD%E6%96%ADapi%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.0.1.1.3.</span> <span class="toc-text">通过Thread类自带的中断api实例方法实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%AD%E6%96%AD%E6%A0%87%E8%AF%86%E4%B8%BAtrue%EF%BC%8C%E6%98%AF%E4%B8%8D%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%B0%B1%E7%AB%8B%E5%88%BB%E5%81%9C%E6%AD%A2"><span class="toc-number">9.0.2.</span> <span class="toc-text">当前线程的中断标识为true，是不是线程就立刻停止?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6"><span class="toc-number">9.0.3.</span> <span class="toc-text">什么是中断机制?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E5%B0%8F%E6%A1%88%E4%BE%8B"><span class="toc-number">9.0.4.</span> <span class="toc-text">小小案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E5%B0%8F%E6%A1%88%E4%BE%8B%EF%BC%88%E4%BA%8C%EF%BC%89"><span class="toc-number">9.0.5.</span> <span class="toc-text">小小案例（二）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lockInterrupt"><span class="toc-number">10.</span> <span class="toc-text">lockInterrupt</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E8%AE%A9%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85%E5%92%8C%E5%94%A4%E9%86%92%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">10.0.1.</span> <span class="toc-text">三种让线程等待和唤醒的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E6%9D%A5%E7%9C%8B%E7%9C%8Bwait%E5%92%8Cnotify%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%AD%89%E5%BE%85%E5%92%8C%E5%94%A4%E9%86%92"><span class="toc-number">10.0.2.</span> <span class="toc-text">先来看看wait和notify实现线程的等待和唤醒</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#condition%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84await%E5%92%8Csignal%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%AD%89%E5%BE%85%E5%92%8C%E5%94%A4%E9%86%92"><span class="toc-number">10.0.3.</span> <span class="toc-text">condition接口中的await和signal方法实现线程的等待和唤醒</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E5%B0%8F%E6%80%BB%E7%BB%93"><span class="toc-number">10.0.4.</span> <span class="toc-text">小小总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lockInterrupt%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="toc-number">10.0.5.</span> <span class="toc-text">lockInterrupt的改进</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">10.0.6.</span> <span class="toc-text">问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JMM"><span class="toc-number">11.</span> <span class="toc-text">JMM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E9%97%AE%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="toc-number">11.0.1.</span> <span class="toc-text">先问几个问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%9F%A5%E8%AF%86"><span class="toc-number">11.0.2.</span> <span class="toc-text">小知识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JMM%E7%AE%80%E4%BB%8B"><span class="toc-number">11.0.3.</span> <span class="toc-text">JMM简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JMM%E4%B8%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-number">11.0.4.</span> <span class="toc-text">JMM下三大特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">11.0.5.</span> <span class="toc-text">可见性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-number">11.0.6.</span> <span class="toc-text">有序性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">11.0.6.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">11.0.6.2.</span> <span class="toc-text">优缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E5%B0%8F%E5%B0%8F%E6%80%BB%E7%BB%93"><span class="toc-number">11.0.7.</span> <span class="toc-text">小小小总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Happens-Before"><span class="toc-number">11.0.8.</span> <span class="toc-text">Happens-Before</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">11.0.9.</span> <span class="toc-text"></span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E5%8E%9F%E5%88%99"><span class="toc-number">11.0.9.1.</span> <span class="toc-text">总原则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8%E5%A4%A7%E5%8E%9F%E5%88%99"><span class="toc-number">11.0.9.2.</span> <span class="toc-text">8大原则</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Happens-Before%E5%B0%8F%E5%B0%8F%E6%80%BB%E7%BB%93"><span class="toc-number">11.0.10.</span> <span class="toc-text">Happens-Before小小总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Volatile%E4%B8%8EJMM"><span class="toc-number">12.</span> <span class="toc-text">Volatile与JMM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89"><span class="toc-number">12.0.1.</span> <span class="toc-text">volatile内存语义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C"><span class="toc-number">12.0.2.</span> <span class="toc-text">内存屏障</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/10/26/MySQL-3/" title="MySQL(3)"><img src="https://w.wallhaven.cc/full/ex/wallhaven-exo2gr.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL(3)"/></a><div class="content"><a class="title" href="/2022/10/26/MySQL-3/" title="MySQL(3)">MySQL(3)</a><time datetime="2022-10-26T02:08:30.000Z" title="发表于 2022-10-26 10:08:30">2022-10-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/26/MySQL-2/" title="MySQL(2)"><img src="https://w.wallhaven.cc/full/9d/wallhaven-9d59xx.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL(2)"/></a><div class="content"><a class="title" href="/2022/10/26/MySQL-2/" title="MySQL(2)">MySQL(2)</a><time datetime="2022-10-26T02:08:16.000Z" title="发表于 2022-10-26 10:08:16">2022-10-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/26/MySQL-1/" title="MySQL(1)"><img src="https://w.wallhaven.cc/full/l8/wallhaven-l8qjwp.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL(1)"/></a><div class="content"><a class="title" href="/2022/10/26/MySQL-1/" title="MySQL(1)">MySQL(1)</a><time datetime="2022-10-26T02:08:05.000Z" title="发表于 2022-10-26 10:08:05">2022-10-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/26/JDBC/" title="JDBC"><img src="https://w.wallhaven.cc/full/kx/wallhaven-kx9d56.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JDBC"/></a><div class="content"><a class="title" href="/2022/10/26/JDBC/" title="JDBC">JDBC</a><time datetime="2022-10-26T02:07:38.000Z" title="发表于 2022-10-26 10:07:38">2022-10-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/26/juc-1/" title="juc(1)"><img src="https://w.wallhaven.cc/full/9d/wallhaven-9d5gpw.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="juc(1)"/></a><div class="content"><a class="title" href="/2022/10/26/juc-1/" title="juc(1)">juc(1)</a><time datetime="2022-10-26T02:06:04.000Z" title="发表于 2022-10-26 10:06:04">2022-10-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Barry</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'http://example.com/2022/10/26/juc-1/'
    this.page.identifier = '/2022/10/26/juc-1/'
    this.page.title = 'juc(1)'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }

  document.getElementById('darkmode').addEventListener('click', () => {
    setTimeout(() => window.disqusReset(), 200)
  })
}

if ('Valine' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><div class="aplayer no-destroy" data-id="60198" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>